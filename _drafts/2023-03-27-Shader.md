---
title: "Shader"
# description: ""
categories: [💫Computer,🌔Game-Engine]
tags: [Unity, Shader]
image: "/assets/img/background/kururu-lab.jpg"

date: 2023-03-27. 13:27
# last_modified_at: 2023-03-27. 14:10
# last_modified_at: 2023-10-26. 13:09
# last_modified_at: 2024-07-26. 13:29
# last_modified_at: 2024-07-30. 22:20
# last_modified_at: 2024-09-02. 11:15
# last_modified_at: 2024-09-27. 22:44
last_modified_at: 2024-10-16. 08:14 # 메모
---

@ TODO : 글 정리  

- HLSL (High Level Shading Language) 가장 유명하고 보편적으로 넓게 쓰임
- GLSL (OpenGL Shading Language) OpenGL에서 사용하는 언어
- CG (C for Graphics) 엔비디아가 마이크로소프트와 협력하여 만든 언어
- 프로그래밍 언어처럼 하나만 잘 배워두면 나머지는 쉽게 터득할 수 있다

- 유니티는 CG 언어를 사용, URP 부터는 HLSL 사용 (언리얼도 HLSL)
- 유니티는 추가적으로 언어를 제작 지원
- Shader Lab 호환성은 가장 높지만, 그만큼 할 수 있는 게 제한적
- Surface Shader 가장 쉽고 멀티 플랫폼에서 잘 대응되는 셰이더, 프로그래머가 아니더라도 배우기 쉬운 개념, 아티스트 레벨에서 배우는
- → Shader Lab 이라는 스크립트 안에 CG 코드가 들어가 있는 형식, 이걸 배워두면 Vertax & Fragment Shader 도 이해할 수 있고, 랜더 몽키로도 갈 수 있고, 노드로도 갈 수 있다
- Vertax & Fragment Shader, Surface Shader의 상위 버전, CG를 더 디테일하게 다룸, Surface Shader가 오토 모드라면. Vertax & Fragment Shader는 수동이라는 느낌

- Swizzling (= mix up)
  - 휘몰아치는, 컴퓨터  용어로는 벡터의 구성 요로를 임의로 재정렬하고 결합하여 벡터를 구성하는 기능 (CG에서)

  - Shader에서는  
    - 그 외에도 Pointer Swizzling 이라는 것도 있음
    - 포인터로 링크된 자료 구조 단위를, ID나 이름 등으로 대체함으로써 프로그램을 다시 시작하더라도 성공적으로 파일 데이터를 로드, 역직렬화 시키는 방법

  - (마인크래프트의 휘몰아치는 칼날은 Sweeping)  

- [The Unity Shaders Bible](https://learn.jettelly.com/unity-shader-bible/#buy-now)  
- 디더링  
- 스크린 스페이스 쉐이더  
- 스텐실 쉐이더
- sssShader  
- [CatLikeCoding](https://catlikecoding.com/)  
- [Graph 그리기, Position에 따른 Color](https://catlikecoding.com/unity/tutorials/basics/building-a-graph/)  
- [Surface Shader (눈)](https://blog.naver.com/PostView.naver?blogId=plasticbag0&logNo=221439156276&parentCategoryNo=&categoryNo=45&viewDate=&isShowPopularPosts=false&from=postView)  
- [Shadertoy](https://www.shadertoy.com/)
- [가짜 투명도, 디더링](https://gall.dcinside.com/mgallery/board/view/?id=game_dev&no=117790&page=1)
- [쉐이더와 머테리얼](https://gall.dcinside.com/mgallery/board/view/?id=game_dev&no=117952&exception_mode=recommend&page=1)
- [알베도, 이미션, 디퓨즈](https://m.blog.naver.com/sorang226/222940558803)  

- Scene Depth : 카메라부터 연산을 시작하는 점까지의 깊이?  
  - Transparent는 통과하는 듯..?

[https://darkcatgame.tistory.com/79](https://darkcatgame.tistory.com/79)  
[https://blog.naver.com/hram01/221489477514](https://blog.naver.com/hram01/221489477514)  
[https://gall.dcinside.com/mgallery/board/view?id=game_dev&no=126408](https://gall.dcinside.com/mgallery/board/view?id=game_dev&no=126408)  

[](https://twitter.com/kjh030529/status/1631561982842396677?s=20)  
[](https://twitter.com/asidys230/status/1635799802100482049?s=20)  
[](https://twitter.com/TheMirzaBeig/status/1658643110409261056?s=20)  
[](https://twitter.com/cmzw_/status/1655536784485527552?s=20)  
[Tiling Vs Hex Tiling](https://twitter.com/_kzr/status/1621052638723993600?s=20)  

## 💫 Shader

---

기술적으로, `3D 컴퓨터 그래픽에서 최종적으로 화면에 출력하는 색을 정해주는 함수`  

- 픽셀의 색을 결정하는 함수.
- 상대적으로 쉬운 문법이라도 해도 엄연히 프로그래밍 언어 기반의 수학적 계산을 통해서 정해진 색상을 출력해주는 것을 목표

감성적으로, `그래픽 데이터의 음영과 색상을 계산하여 다양한 재질을 표현하는 방법`  

- 하지만 쉐이더를 그렇게만 생각하기에는 뭔가 감성적인 다른 영역이 있다.
- 쉐이더는 단지 기계적 영역의 설명뿐 아니라 감성적 영역까지 아우르는 멋진 공예품에 가깝다고 볼 수 있다.

- 자동차를 '이동을 위해 제작된, 금속과 다양한 재질들로 제작된 내연기관과 그 부속물' 이라고 말할 수도 있겠지만 다른 영역에서 바라면 자동차는 품위를 높여주거나 자신의 개성을 나타내며 유행을 선도하는 예술품으로 느껴지기도 한다.  

- 직역하면 음영, 이는 그림자와는 조금 다른 느낌을 주며, 오히려 그늘 이라고 말하는 것이 비슷
- 우리가 미술 학원에서 가장 처음 그림을 배울 때 빛이 들어오는 방향은 밝게 표현하고 빛이 들어오는 반대 방향은 어둡게 표현하였던 바로 그것 말입니다.
- 우리가 그렇게 그림을 그린 이유는, 평면인 종이에 입체감을 나타내기 위해서이며 사람의 눈은 이러한 음영을 통해서 공간감을 느낄 수 있기 때문입니다

- 3D 그래픽에서도 이러한 음영으로 물체의 존재를 표현하게 되는데, 이것을 기본으로 각종 색과 농담을 추가하여 화면에 출력하면 물체의 존재를 더욱더 확실하게 표현할 수 있게 됩니다.
- 이 음역과 색상으로 각종 재질을 나타내고 이 방법을 창의적으로 바꾸어 보면 자신만의 예술적인 개성이 넘치는 드로잉 스타일도 가능하게 되는 것입니다. 마치 자기만의 색역필이나 물감을 만드는 것처럼 말입니다.
- (좀 더 그래픽 아티스트 친화적으로 말하면, '메터리얼(Matetial) 이라는 용어입니다. 언리얼 엔진 : 메터리얼 용어 사용)

## 💫 모니터에 표현되는 색과 빛의 기본원리

---

1. 모니터의 색은 어떻게 표현되는가?

가산 혼합 (빛의 삼원색) : RGB로 이루어진 색을 더하면 더할수록 밝아지며, 모두 더하면 흰색이 되는 색의 체계.  
잉크에서의 감산혼합 (색의 삼원색)과는 반대 개념이며, 우리가 만들어야 할 색의 기본 이론이기도 합니다.  

일반적으로 컬러 모니터는 RGB로 구성된 3개의 '서브 픽셀 (Subpixel)' 로 이루어져 있습니다.  
모니터의 한 픽셀을 이루는 기본구조는 마치 R, G, B (Red, Green, Blue)의 색으로 빛나는 3개의 조명이 붙어있는 모습이라고 생각할 수 있습니다.  
즉, 3개의 조명이 모두 동시에 빛난다고 가정했을 때, 이 3개의 색을 멀리서 보면 하나로 합쳐져서 흰색처럼 보이게 되는 것입니다.  

1. 모니터에 나타내는 색을 숫자로 표현하기

빨간색은 3개의 조명 중 R 조명만 켜지게 되고, 정확하진 않겠지만,밝기로만 따져보면 흰색보다 약 1/3 쯤으로 어두워졌을 것이라고 예상할 수 있겠습니다.

1. 컬러를 숫자로 나타내보기

한 픽셀의 색을 결정하는 코드를 '픽셀 쉐이더(Pixel Shader)' 라고 부릅니다

1. 컬러를 숫자로 인식해 보기

RGB는 합쳐 놓으면 컬러로 보이지만 따로따로 놓으면 흑백으로 표현된다는 것입니다.
예를 들어 R 값만 있고 나머지는 없다고 하면, R 값의 숫자는 더 이상 컬러를 나타내는 것이 아니라 R 값의 '강도'만 표현하는 한 자리 숫자일 뿐입니다.
마치 '붉은색 전구를 켜는데 필요한 전기의 힘' 같은 느낌처럼 말입니다.
그 힘 자체가 붉은색을 나타내지는 않으므로 각 컬러의 채널을 따로 볼 때는 흑백으로 '강도'만 표현됩니다.
그리고 그것은 알파 채널도 마찬가지입니다.
투명도도 따로 떼어 놓고 보면 흑백의 '강도'일 뿐입니다.

1. 컬러를 연산해 보기

노란색 (1,1,0) + 빨간색 (1,0,0) 는 어떻게 될까요?
일단 숫자로는 (2,1,0) 이 됩니다.
정답은 노란색입니다.
비록 숫자는 1을 넘어섰지만 이것은 숫자로 존재만 할 뿐, 모니터에서는 1이상의 색상은 표현할 수 없게 됩니다.
ㄴ [여기에서 우리는 '1보다 밝은색' 즉, '흰색보다 밝은색' 이 실제로 존재한다는 것을 알 수 있습니다. 실제 세계에서도 '눈부실 정도로 밝은 빛' 이 존재하듯이 말입니다. 하지만 모니터로 그 색을 출력해내는 것이 불가는하기 때문에, 눈으로는 1이 넘어가는 밝은색을 구별해낼 수 없다는 것에 주의해야 합니다. 나중에 색상을 추가로 연산할 때 오차가 일어날 수 있기 때문입니다. + {이 부분은 HDR 등에 연관되며, 블룸 (Bloom) 효과 등을 만들 때 유용하게 사용됩니다.}]
마찬가지로 뺄셈도 계산에 따라서는 0 이하의 색상이 만들어질 수 있습니다.
하지만 0 이하의 숫자는 0으로 보이기 때문에 빨간색에서 파란색을 뺀 색은 그냥 빨간색처럼 보이게 됩니다.
물론 숫자로는 -1이 그대로 유지되고 있다는 것으 주의하세여
★ 나눗셈은 상대적으로 곱셈보다 느리다

- 컬러의 반전 (Invert)
1 = float1 (1) = float3 (1, 1, 1) = float4 (1,1,1,1)
이 때 1자리 숫자의 경우 굳이 앞에 float을 붙이지 않음, 그냥 1이라고 씀
1에서 어떤 색을 빼면 그 색이 반전됩니다.
1-x 계산은 흰색을 검정색으로, 검정색을 흰색으로 뒤집어 주는 등의 역할을 할 수 있기 때문에 실제 쉐이더 계산에서 자주 사용되곤 합니다.

## 💫 _2

---

ShaderLab : 유니티에서 쉐이더를 작성하기 위한 스크립트 언어  
ShaderLab을 이용한 제작 방식 3가지  

1. ShaderLab으로만 (고정 파이프라인 쉐이더 : fixed function shader)
   - 매우 가볍고, 하드웨어 호환성이 좋지만, 기능이 상당히 부족 > 고급효과 X
   - 자체 문법 > 다른 쉐이더 문법과 거의 호환 X + 거의 지원 중단
   - ㄴ ☆ 다양한 환경에 맞는 쉐이더로 자동으로 분기되어 만들어줌
   - ㄴ 모바일, PC, 기타 콘솔 기기, 라이트 맵 유무, 조명이 픽셀 라이팅일 때, 버텍스 라이팅일 때 등 모든 경우의 수마다 다른 쉐이더를 만들어야 하지만, 서피스 쉐이더는 이런 경우의 수를 자동으로 제작
   - ㄴ 때문에 편리 > 불필요한 쉐이더 양은 늘어남 > 최적화 X

2. Surface Shader (서피스 쉐이더)
   - ShaderLab 스크립트와 함께 일부분은 CG 쉐이더 코드를 사용
   - 기본적인 조명 코드와 버텍스 쉐이더의 복잡한 부분은 스크립트를 이용하여 자동으로 처리
   - 픽셀 쉐이더 부분만 간편하게 작성할 수도 있음 > 편함
   - 비주얼 쉐이더 에디터와도 상당히 비슷한 개념 > 쉽게 공부하고 응용하기에도 좋음
   - 단, 최적화에는 다소 무리, 일정 수준 이상의 고급 기법 X

3. Vertex & Fragment Shader로 작성하기
   - ShaderLab 스크립트와 함께 CG 쉐이더 코드를 사용, 좀 더 본격적인 쉐이더 작성 방법
   - 자동적으로 처리되는 부분이 별로 없어서 제대로 된 CG 쉐이더 방식으로 버텍스의 좌표변환부터 제대로 처리해야 작동
   - 배우기는 조금 어렵지만, 완전히 수동으로 제어 가능 > 최적화 + 고급 기법 O

## 💫 _3

---

 1. 설정 부분
전처리라고 할 수도 있고 스니핏(snippet)이라고 부르기도 합니다.
 이 부분은 말 그대로 쉐이더의 조명계산 설정이나, 기타 세부적이 분기를 정해주는 부분입니다.

 float의 1/2 크기가 half
half보다 더 작은 크기가 fixed

컬러나 벡터 길이는 fixed로 충분
범위나 정밀도가 필요한 것은 half
나머지는 float을 사용하는 것이 좋습니다.

실제로 Nvidia 쪽 GPU의 경우에는 half로 할 때 연산수가 2배로 빨라집니다. 그렇지만 그렇다고 float 정도로 정밀할 필요가 있는 데이터를 half로 바꾼다면 잘못된 결과가 나올 수 있겠죠?
 ★ Albedo는 빛을 받는다는 의미가 아닙니다. Diffuse와 동일하게 생각하면 곤란합니다.
 ★ 3ds Max에서 셀프 일루미네이션 (Self-illumination) 이라고 부르는 '자기 발광' 기능이 바로 Emission입니다
 ★ o.Albedo와 o.Emission의 값은 최종적으로 서로 더해집니다. 즉, 둘을 모두 쓰면 필연적으로 밝아집니다.
 Albedo > 조명 연산을 추가로 받게 되고, Emission 조명 연산을 받지 않아서
'조명과 상관없는 순수한 색상' 만이 출력 > 순수한 결과물을 보고 싶을 때는 Emission을 즐겨서 사용
 1보다 밝은 색이 있고, 0보다 어두운 색이 있어서 그것이 존재하고 계산되는 상태를 HDR (High Dynamic Range)
 float4.rgb => rgb만 쓰겠다, 자동 형변환 느낌인듯?
 float.rgb
float.grb
float.bgr
float.rrr
 1 = 1,1,1 / 0.5 = 0.5, 0.5, 0.5
 o.Albedo = test.b 라고 쓰면 0을 입력한 것과 같기 때문에 검정색이 출력
 ㄴ 이렇게 변수의 부분값을 자유자재로 바꾸는 것은 스위즐링 (Swizzling) 이라고 합니다
 예전에는 오류가 생기면 무조건 마젠타 색을 출력했지만,
유니티 5.5부터 계산할 수 있을 때 까지 계산하고 오류 메세지 출력
심각한 오류라면 여전히 마젠타 컬러를 보여줌
 float x
x.r 가능

float2 xx
float3(0, xx.rg)
float3(0, xx.gg)
 인터페이스 변수를 CG코드 내에서 사용하려면 똑같은 이름의 변수를 안에서 선언해주면 됨
 밝기를 조절하는 방법
-1 ~ 1 Range로 받아오고
o.Albedo = rgb~ + 변수 값
 struct 안에 아무것도 들어있지 않으면 안됨
 float4 color : COLOR
이 내용은 버텍스 컬러를 받아오는 마법의 주문, 현재로서는 어디에도 쓰진 않습니다. 단지 에러를 피하고자 쓴 것이지요.
 o.Alpha = 1 로 불투명함을 표시, 하지만 '아직은' 0.5 나 0 을 넣는다고 반투명해지거나 투명해지지 않습니다.
 LOD > 이 쉐이더의 환경 설정에 따른 옵션 값에 관련된 내용

<https://celestialbody.tistory.com/5>

텍스쳐는 UV 좌표와 함께 계산되어야 float4로 출력될 수 있기 때문에, 아직 UV와 계산되지 않은 텍스쳐는 색상 (float4)으로 나타낼 수 없다. 그래서 이때까지는 sampler라고 부른다.  

## 💫 _4

---

물리 기반 쉐이더에서 Metalic이 0이면 스페큘러 컬러가 흑백(흰 빛을 비추었을 때)이 되며, Metalic이 1이면 스페큘러 컬러가 Albedo에 넣은 색이 됩니다. 금속은 고유의 스페큘러 컬러를 가지고 있기 때문입니다. 가급적 Metalic에서 0과1 외의 값은 쓰지 않는 것이 정확한 물리 기반 쉐이더를 다루는 방법입니다.  

Smoothness는 재질이 매끄러운지 거친지를 결정하는 부분.  
0이면 완벽히 거칠어서 난반사만 일어나고, 1이면 완벽히 매끄러워서 정반사만 일어나게 됩니다.  

난반사가 일어나는 이유는 '거친 표면' 때문이며, 특히 겉으로는 부드러워 보이더라도 미세한 표면 단계에서의 거칠기 때문에 (거의 분자 단위로) 피부나 천의 경우에는 스페큘러가 적게 나타나는 것입니다.  

즉, 재질이 매끈하면 난반사(Diffuse) 연산보다 정반사(Specular) 연산이 늘어나며, 이것을 조절할 수 있는게 Smoothness 인자 입니다.  

벤타 블랙 같은 특수한 물질을 제외하고는 대부분 어느 정도의 스페큘러를 가지고 있다.  
우리가 질감을 느끼게 되는 요소는 거의 스페큘러, 그래서 스페큘러가 없으면 거의 질감을 느끼기가 힘든 것.  

유니티에서 Standard Shader라는 '물리 기반 렌더링' 의 기본 개념은 '에너지 보존 법칙'으로 '나가는 빛의 양은 들어온 빛의 양을 넘을 수 없다'라고 간단하게 설명할 수 있습니다.  

[](https://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html)  

일반 텍스쳐를 노말맵으로 만들 수 있음.  
Create from Grayscale 옵션을 체크하고, Bumpniss나 Filtering을 적절히 조절  

NormalMap은 일반적인 텍스쳐가 아니다.  
NormalMap은 일반적인 게임용 텍스쳐 포맷인 DXT1 혹은 DXT5가 아니라 DXTnm이라는 파일 포맷이다.  
(플랫폼에 따라 다를 수 있다. 예를 들어 안드로이드에서는 ETC 파일 포맷을 쓰기도 한다. 여기서는 PC 기준으로 설명하겠다.)  

이 파일 포맷은 일반적인 텍스쳐의 압축에 의한 NormalMap 품질의 저하를 막기 위해 만든 AG 파일 포맷이다.  
이 포맷은 NormalMap의 R과 G의 퀄리티를 최대한 보전하여 A와 G에 넣어 저장한다. (B는 가지고 있지 않다)  
이렇게 보전된 R과 G는 NormalMap의 X와 Y로 계산되며, Z는 삼각함수를 이용하여 수학적으로 추출이 된다.  

그러므로 이 텍스쳐를 이용해서 NormalMap으로 온전하게 생성해내려면 앞에 설멍혀나 공식이 적용되어 있는 함수를 이용하면 간편한다.  
`float3 y = UnpackNormal ( float4 x );`  
`o.Normal = UnpackNormal ( tex2D (_BumpMap, IN.uv_bumpMap) );`  

or  

`fixed3 n = UnpackNormal(tex2D(_BumpMap, IN.uv_bumpMap));`  
`o.Normal = float3(n.x * 2, n.y * 2, n.z);`  
강도 조절 (Z축은 거의 영향을 끼치지 않기 때문에 연산해줄 필요가 없다, 물론 1이상을 곱한 후 내부적으로 normalize를 한다면 약하게 만들어 줄 수 있겠습니다만 이 단계에서는 적절치 않으므로 설명을 생략하겠습니다.)  

Occlusion (Ambient Occlusion)은 구석진 부분의 추가적인 음영을 표현하는 기능  
일반적으로 환경광 (Ambient Color)로 가득 차 있느 세상에서 그림자가 드리워진 부분도 사방에서 오는 환경광 정도를 받고 있는 것이 일반적입니다.  
하지만 매우 구석져 있거나 복잡한 물체들로 가려져서 환경광도 닿지 못하는 부분은 더욱 더 어두워지는데 이 부분을 Ambient Occlustion (환경 차폐)라고 부릅니다.  

특이하게도 Occlusion 맵은 독립된 UV를 받으면 에러가 납니다. 반드시 _MainTex같은 UV를 사용해야 정상적으로 작동.  
o.Occlusion이 float을 받기 때문에, RGB를 모두 사용하는 텍스쳐 한 장을 단지 Occlusion 기능을 위해 추가하는 것은 낭비.  
_MainTex의 알파 채널을 Occlusion으로 사용한다던지  

지금까지 유니티에 내장된 PBS 쉐이더인 Standard Shader의 Metail Pass의 기본 조작접에 대해 알오보았다.  

[https://unity.com/kr/releases/editor/archive](https://unity.com/kr/releases/editor/archive)  
다운로드 아카이브에서 내장 쉐이더를 다운 받을 수 있다.  

## 💫 5

---

스탠다스 서피스 쉐이더는 유니티 5부터 기본으로 적용된 쉐이더 형태  
하지만 물리 기반 쉐이더 라이트이기 때문에 모바일과 같은 저사양 기기에서 구동하기에는 다소 무거운 것이 사실

## 💫 DC_TA

---

이펙터는 웬만한 쉐이더를 반투명으로만 사용한다  
Translucent 아니면 Additive 즉 최적화를 크게 신경쓰지 않는  

반면 모델러들은 양면 렌더도 제대로 못 쓰게 한다  
최적화에서 가장 크게 잡아먹는 Shadowdepth도 이펙터들은 크게 신경쓰지 않는다  

모델러들은 라이트 베이킹부터 VRAM 때문에 라이트맵 해상도부터 줄여나가고  
Batching과 Instancing도 해야하는 작업을 가진다

이쁜 gi를 쓰고싶어도 forwardrender 쓰는 모바일에선 라이트베이킹만 써야하고.
하다못햐 그것도 안써서 페이크라이팅 쓰는곳도 많음.

특히 커스텀 셰이딩모델 은 대부분 캐릭터에서 나오지 이펙트에서 나오지 않는다.

TA들 나이가 많은 이유는 모델러 출신에서 점점 올라운더로 바뀌며 다해봐서 그런거임.

이펙터 출신 Ta들이 왜 모바일과 소형 프젝만 있는가 하면 이런 최적화 경험을 해볼수가 없이 연출과 쉐이더만 짜고 가끔 후디니로 파괴까지만 구현해서
나 TA요 거들먹거리는거지

실제 기술과 현장에서 써먹는건 모델러 출신이 더 정확하다.

물리기반 렌더도 전부 모델링에 맞춰져있지 이펙트가 겪어볼일이 많을까?

그리고 이펙터 출신이든 모델러 출신이든

이펙트도 모델링도 두가지 모두 지식 없으면 TA가 아니라 잡부임.

---

- [](https://x.com/cmzw_/status/1834555458444763276)
- [](https://x.com/ryurud_n5/status/1831341519913255228)
- [피직님](https://x.com/kimphysik/status/1781326314118754771)
- [경섭님](https://x.com/ryurud_n5/status/1822665541909434376)
- [2](https://x.com/ryurud_n5/status/1820451843941745102)
  - 명조 스타일 만들기 #1 명조는 Grass가 카메라와 가까워지면 아래로 숨겨짐 Dithering을 활용하는 경우는 봤어도 이렇게 아래로 숨는 경우는 처음 봤음 원래 툰게임들은 이렇게 구현하나? 비슷하게 따라해본 결과 Distance Field 맵과 Pixel Depth를 활용하는 방향이 쉽겠다 싶었는데, 뭔가 명조는 더 딱딱한걸 보면 단순 메쉬의 월드 포지션을 조절하는건가 싶다
- [3](https://x.com/ryurud_n5/status/1756354222159994889)
- [4](https://x.com/ryurud_n5/status/1747572879464833498)
- [5](https://x.com/ryurud_n5/status/1746504485915246713)
- [6](https://x.com/ryurud_n5/status/1845474453024895215)
- [시간 이펙트](https://x.com/cmzw_/status/1793318381313278205)
- [웜홀?](https://x.com/Indiedev_Hub/status/1792867212857950564)
- [](https://x.com/longlong_stone/status/1664844118491553793)
- [키바님 숫자 타일](https://x.com/kjh030529/status/1754052982621274570)
- [키바님 버튼](https://x.com/kjh030529/status/1757252520051888242)
