---
title: "UNITE 2025"
description: ""
categories: []
tags: []
image: "/assets/img/background/chuttersnap-JxxhNRpdRaw-unsplash.jpg"
hidden: true

date: 2025-04-00. 00:00
last_modified_at: 2025-04-00. 00:00 # Init
---

## 🗿 머리말

---

# UNITE

VFX Graph 제가 만든건 아니고 내장 패키지  
VFX Graph는 쓰신 분들이 거의 없을 수 있는데  

GPU를 이용해서 움직이는 파티클  
그래프를 써서 제작 가능?  

특히 VFX Graph를 좋아하느다
선응 좋다  
쓰기 슁누 GUI 등  

최대 장점  
다듬어진 기술 설계  
파티클 쓴 사람 알 수 있겠지만  
용도 다양하고 성능 좋고 그런 게 많이 없다  

기술적으로 우수해서 계속 쓰게 된다?  

특히 아트 분야에서는 활용이 두드러진다  
유니티보다도 VFX 어플리케이션을 쓴다는 느낌  
그만큼 중요하게 느껴진다  

그랠서 VFX Graph Assets Package  
표준 기능에는 부족한 부분이 있다  
그런건 커스터마이징  

공통부분 (공유해서 쓸 수 있ㄴ)  

이 패키지에 포함된  

Texturless Particle Shaader  
Parameter 만으로 Particle 용 텍스쳐만드는  
단순한 파티클을 만들기 위해 텍스쳐를 만드는 것은 비효율  

Depth of Field  
Particle Shader  
보케/블러를 만드는 쉐이더  
일르 통해 깊이감 있는 이펙트를  쉐이더로  
\+ 블러  

Exponential Random  이라는 것은  
난수/ 지수함수적인 편향을 주는 함수  

일반 랜덤은 큰 파티클이 눈에 띄게 많이 보이게 된다  
작은 건 그 그림자에 가려져서 잘 안보인다  

이런 문제를 해결하기 위해  
이 함수가 쓰인다  
함수에 편향을 줘서  
작은 파티클도 잘 보이게  
인상이 평군화되어 있다  
큰 파티클이 비교적 듬성듬성잉쓴ㄴ 

이것과 같은 것은 Particle Lifetime에도 적용할 수 있다  
임펙트를 주고 싶은 경우, 계속 남아있는 경우 좀 그렇다  
여운을 남기는 것은 이 노드를 쓰는 편이  

SetRandom Angle
SetRandom Angular
Velocity  
사실을 복잡한 것  
단순히 각도를 랜덤화하면  
아래와 가운데에 편향성이 생긴다  
이걸 이용하면 평균화되낟 (편향없이 분포가된다)  

마찬가지로 랜덤 벡터도 랜덤을 쓰면 편향이 생기는데  
RandomVectore/Spheere가 있다  

그 외에도 여러 노드  
Tween
Axis Rotation  
Divergance-FreeNoiseField  
Low Frequency Field  

다음  
UI 간련  
VJUTK
VJUI for UI Toolkit  

간단하게  
BUtton, Knob, Toggle에 대한 컨트롤  

Dense Layout Support
몇 가지 중요한 컨셉을 위해 설계된ㄱ 것  

밀드가 높은 레이아웃에 
UX를 희생하더라도 어쨌든 많은 파라메터를 조작해야  
컴팩트하게 줄세기 좋은 디자인을 ㅗ 만들 피룡가 있다  

슬라이거 여러개보다는 노브 쓰는 것이 좋겠다  

이런 컨트롤은 멀티 조작이 가능해야  
한쪽은 부드럽게, 한쪽을 격렬하게 하고 싶ㅍ은 경우  
2개 이상의 컨트롤을 동시에 컨트롤 할 수 있어야  
이것은 이미 지원되고 있어서 쉽게 구현하 ㄹ수 있었다    

Enhanced Visibility  
시인성이 좋은가 <- 중요  

UI랑 Preview가 서로 겹쳐서 잘 보이도록 시인성이 좋아야  
Preview랑 UI를 분리해도 되는데,  
눈 왔다갔다 하는것이 불편  
그래서 요즘은 가능하면 둘을 겹쳐서 보기  
보면서 동시에 파라메터 조정 가능  

VJUI fore Unity GUI (uGUI)  
같은 기능을UGUI에도 만들었느데  
지금은 지원안함  (UI Toolkit 써서)  
줄 세우기 같은 UI는 Toolkit이 좋다  

---

Minis  
MIDI Input for new Inut System  

VJ같이 리얼타임 감각적인 파라메터가 필요한 경우  
MIDI 컨트롤러  
이런 외부 하드웨어  

InputSystem을 MIDI에 대응시키는  

지원하는 타입

- Midi Notes
  - 128Notes
  - Velocity 건반 눌렀을 때의 강도 (pressure)
- MiDI Control Change (CC)
  - 128 controle (쓰로틀, 보통 LR 좌우만 있는데, 128개면 대단하죠 - 주요 이유)
  - 7 bit value 127

MIDI : 건반을 눌렀을 떄 정보 (어떤 트리거적인 이벤트)  
CC는 값의 변화 노드/페이더로 입력하게 된다  

이 것을 nodeGraph로 잘 쓸 수 있게 변환  

이걸을 쓸 수 있게 됐는데,  
C#에서 어케 쓸까?  

PlayInput 같은 걸 쓸 수 있는데,  
이런건 인게임을 위해 만들어진 것이라  
아트 작업에는 ㅆ기 어려울 수 있다  

InputAction을 쓸 수 이다  
이는 범용적  
입력 검출 간으, 물론 MIDI 컨트롤러에 대한 것도 수용 가능  

실제 사용방법  

```cs
public InputAction ~;
// 바인딩 인터페이스 띄우기 가능  
// 이 드롭다운에서 AddBinding
// 더블 클릭하면 Dialog가 나오고 경로를 클릭하고, Listen을 누르면 입력 대기 상태
// 이 상태에서 미디 컨트롤러 누르면 자동으로 설정된

// 자동 검출 뿐만 아니라 
// T를 눌러서 PAth를 이용해 모시꺵할 수 있다

// 문법
// #(Dispaly)/Name -> 복수 여러 개 동시에 설정 가능

// (*Channel)/note060
// (*Channel)/note* -> 와읻드 컨트롤롤

tesetAction.ReadValue<float>();

testAction.Enable();
testAction.performed += _ => ~vfx.Play()

// 미디
// 키보드
// 혹은 둘 다 쓰는 둥 
// 유연하게 대응 가능
```

악기 본래의 사용 방법도 쓸 수 있는  
악기의 연주를 리얼타임 비주얼 활용 가능  

MIDI는 악기를 위한 프로토콜
이것이 본래의 사용 방법일 것  

음악/비주얼  
완전히 싱크되는 것은 보통 어려운데, 잘 할 수 있따  

LASP  
Low-Lantenct Audio Signal Processing Plugin  
직업 음악을 (음형 파형)을 이용해서 비주얼  

저시현 오디오 입력/간단한 파형 분석을 지원하는  

유니티 내장 X
libsoundio 라는d 외부 라이브브 
실시간성 높은 오디오 처리  
멀팉 패널 처리도 가능 (예술 분야에서는 중요한 기능)  

Audio Level Tracker Component  
입력을 얻을 수 있는?  

프로퍼티 바인더를 이용해섶 값을 얻으 ㄹ수 있다  

Frequncy filters  
고음/저음 필터링도 가능  

Spectrum ANalyzer FFT Component  
자세히 주파수 성부 분석  

LASP VFX  
패키지  
연결 가능  
깃허브에 샘플
샘플 전혀 C# X, LASP, VFX만 써서  

---

KlakNDI  
NDI Video Conection Plugin  

랜 상으로 비디오 송신  
NDI를 유니티 내에서..?  (번역 좀 어려움?)

어떤 것이 가능한다  

Camera -> GDMI Capture -> COmputer - HMDI -Computer  
일반적으로는 캡처보드 등을 써야하느데  
이런게 많아지면 복잡하고, 문제 가능성도 높아짐  

그림은 1선인데  
현장은 더 복잡하게 되는데  
케이블 길이도 있고 자유롭지 않다  

이를 같은 것에 연결하는 것 만으로 간단하게 만들 수 있따  
어쨌든 같은 것에 연결되어 있으면 통신가능하기 때문에  
쉽게 추가도 가능하다다

이런것은 길이 자유가 있고, Wfi도 가능하다 (큰 공연장은 어렵지만, 작은 폐쇠된 곳이라면)  

iphone VIdeo를 유니티 에 (같은 랜랜)  
Ndi Receiver 컴포넌트를 추가하기만 하면 되는  
NDI Name 에서 선택하기만 하면 도니다  

이렇게 간편하게 연결할 수 있다  

유사한 프로토콜이 있긴한데, NDI 프로토콜 장점  

설정이 간단하다  
같은 랜 이기만 하면  그 자체로 연결 가능하다  

에코 시스템?  
아 환경  
지원하는 것이 많다  

스마트폰에서 쓸 수 있는 NDI 앱이 있다? 쉽게 카메라를 늘릴 수 있다?  

개인적으로 중요한  
PowerFrame 메타 데이터  
이미지 뿐만아니라 metaDat를 포함하여 보낼 수 ㅣㅇㅆ고, 자유럽게 정의 가능 (사용자가)
XML 형식이라면 뭐든지 가능하다 라는 느낌  
위치 회전 추적 데이터를 같이 보낸다던지  
화면 UI 입력 정보를 같이 보낸다던지  

싱크 깨질 염려가 없다  
엄격하게 동기화 가능  

어떤 의미인가?  

트래킹 같은 확장 뎅터를 보내기 위해서는  
독집된 별개의 스트림을 만들어야 한다  
2개 있다는 것  
이것은 엄격하게 싱크로 되어 있어야  
변화가 있다면 어색해보인다  

타임 코드를 만들거나, 버퍼를 만들거나  
그런 복잡한 방법을 고려해야하는데  

이미지에 메타데이터를 하나로 보이게 되면  
동기화가 어긋날 모시꺵이 없다  

AR 관련 플젝트에서 많이 쓴다  

Color 
Depth  
Human Stencil 이미지  

메타 데이터에는 Camera Positoin + Rotation UIInputData
이런 것들을 Base64 Encoding 해서 XML로 본고  

이런 걸 이용해서 볼류메트릭 미디오를  

동ㄱ화가 어극날 이ㅠ 없고, 스트림 1개, 연결도 간편하다 (랜)  

---

마짐가  

Procedural Motion Packge  
가장 간단하지만  
가장 많은 곳에서 쓰이는  

절차적인 움직임 컴포넌트  

Brownian  
가장 많이 쓰이느  
Noise, 무작위 적인 움ㅈ기임  
주파수, 옥타브 수를 조정해서 세밀하게, 마구작입로 우밎기은 다양한 움지ㅣㄱ임 구현
카메라 랜덤 움직임 (대표적인 사용 사례)  
손으로 들고 있는 것처럼 강ㄹ한 움직힘  
혹은 크레인 등을 이용한 부드러운 (약하게)

- Natural Animation  
  - 짧을 애니메이션을 쓰면 부자연스러운
  - 의미는 없지만, 부드럽게 -> 자연적인 것 등에서 쓰기 적절하게 간편하다다
  - 나비 움직임
  - 풍향계 움직임을 이용한 

- 좀 더 복잡한
  - Human Idle 
  - 정지한 인간의 자연스러운 움직임
  - 무중력 상태 등에서
  - 간단한 구조이지만, 설득력 있는 움직임을 보인다다

cyclic  
Linear  
Random

Smooth Motion 
- Exponential
- Spring
- Damped Spring
- @ Ease 같은?  

마지막  
Procedural Motion Tack Package  
Timeline으로 쓸 수 있도록  
뒤감기/ 반복 / Fade(Cross) 가능  

시간 부족으로 4개만 소개함  

---

점심먹고  

1256  

## Unity 프로젝트 개발시 반드시 체크해야 할 최적화 관련 기능 공유

최적화 가이드, 류태규

공통적 최적화 이슈
모바일 플랫폼 대상

경험적인 부분들이 많이 포함되어 있음  

- 높은 메모리 점유 요소
  - Shader Variants
    - Keyword를 추가하면 2의 지수 형태로 variant가 증가
    - Keyword가 10가 만 있어도 1024
    - Build in Shader나 상용 Asset 수정 시 keyword 증가 주의
  - Dynamic SHader Loading
    - Chunck 단위 Variants 압축/해제
      - PlayerSetting / Shader Variant Loading Settings
      - 유니티 블로그를 통해서도 소개됨 (2021)
  - Stripping 자동 제거
    - Project Settings/Grapjjics
  - " 직접 제거
    - Play log에서 variant 정보 추출
    - GraphicsStateCollection.BeginTrace (Unity6)
- AssetBundle 관련련
  - PersistentManager.Remapper
    - Instance ID와 File GUID, Local ID mapping 정보
      - 늘어나면 즐어들지 않기 떄문에 최대 asset 개수 최소화
  - SerialzedFile
    - Assetbundle metadata
  - 장면에 필요한 asset만 포함된 bundle 구성 (사실상 불가능)
  - 동기 Load된 bundle 개수 제한
  - Instance 직접 관리로 bundle 해제 (개발 비용 상승)
    - AssetBundle.UNload(False)
      - 이때 로드된 인스턴스들도 같이 내려가서
    - Addressable - Custom assetbundle provider
      - 커스텀 필요

```cs
// AssetBundleProvider.cs

// 14번줄
~ m_AssetBUndle.UnloadAsync(true); // 수정?
```


---

IL2CPP Metadata
일부 고정크기, 일부는 실행 중 크기 증가

- 전체 규모 화이
  - Platform seting ScriptBdebbuing 설정 (Debugging 정보 부하)
- Native Profiler
  - `il2cpp:: filtering`

- 관련 성정
  - Managed Code Stripping - Medium
    - Medinum이랑 다른거 성능 20%차이이
    - 코드 삭제 되는 경우
    - namespace 설정 가능
  - IL2CPP Code Generation - Faster (smaller) builds
  - Package Manager - 불필요한 package, plugin 제거
    - Build 후 다음 경로의 dll크기로 module 별 크기 유추
    - Library/Bee/artifact/(platform)
---

단편화 문제

- 잦은 작은 할당에 의한 2가지 이슈
  - Memory hole에 의한 amanaged heap 증가
  - 작은 할당에 의해 거의 빈 bucket의 해제 ㅂㄹ가
- 일반적인 가이드 (난이도 상)
  - 수명이 긴 데이터를 미리 할당하고 최대한 유지
  - ~
  - ~

고민해볼 만한 내용  

- 할당 규모와 빈도가 높은 주요 구간
  - Text data parsing - parsing 별 string 할당 규모 확인
  - 명시적 장면 전환 - 장면간 빈 장면 추가로 heap 확장 억제
    - 이전 씬, 다음 씬 메모리 모두 올라가는 경우가

- GarbageCollector..GCMode를 사용한 해제 시점 관리
  - (사례 부족으로 비추)
  - 동시 해제를 통한 단편화 감소 효과 ㄱ댜
  - 해제 시점의 CPU 부하 주의

---

CPU Stuttering

주의점  - Profiler Marker 수집 부하  

- Call count에 비례한 오차 증가
  - 의심스러운 경우 native profiler의 결과와 꼭 비교
- GC Allocation의 call stack 확인
  - Deep Profiler대신 call stack 옵션 사용

Shader.CreateGPUProgram  
쉐이더 로드  

Shader warmup

- OpenGGL, DX11
  - Shader.WarmupAlShaders
  - ShaderVariantCollection.WarmUp
- +
- off ScreenRendering
  - 가장 안전?

Instantiate

- 최적화
  - 오브젝트 풀 사용
  - Serialized field 구모에 비례한 CPU 부하
  - 생성시점분리 예) 캐릭터 렌더러와 정보
  - Object. Instantiate Async
    - Produce & Copy 비동기 (Deserialied 크기) -> Job으로 돌리고, AWake 비동기

GC.Collect

- GC allocation 제거로 GC.Collect 지연
  - 특히 Update, 반복문 비명시적 할당 (object.name 이런 복사본 반환 멤버 주의)
- Incremental GC
- 가장 확실한 방법 GCMode 활용에 대한의견
  - 메모리 사용량 증가에 대해 관리가 가능한 사왕인지 검토

---

주요 CPU 부하 요인

REndering

- Draw 고급 기능 활용
  - **SBP Batcher, Instancing
  - Indirect draw, Batch Render Group API
  - GPI Resident Drawer (MeshRenderer, Foward*, Unity 7)
- Cull
  - 원거리 초소형 물체 및 사전 제거
    - Camera Cull
    - Light
    - ~
  - Culling Group (장면 구조에 따라 유효, 그림자 문제)

UGUI

핵심 최적화 및 고려사항

- 동적 요소에 의한 Batc 비용 최소화
  - 동적.정적 요소 canvas 분리 (Animator, Scroll , ...)
- Layout system 부하
  - 계층 구조 최소화 및 비활성화
- REctMask2D cull query 부하
  - 대상 요소 규모에 비례함 (특히 Text 포함 시 급격한 증가 - 글자 단위로 Culling 하기 때문에)

Animator
~ 사진 참고  
Job을 통해서 돌아가는데  
Event 등을 쓰면?? MainThread에서 돌아가도록 되어 있음음

Skinning
~ 사진 참고
X  

기타  
불필요한 카메라  
 RenderObjects에 Override ?
 커스텀 렌더 피처?
 사용에 따라서는 ..?

동일한 REdnerer를 지정하는 경우도 잇는데  
서브 카메라가 꼭 필요한 경우가 아니라면 ,최적화된 별개의 Renderer를 만드는 방식으로..

물리  
Fixed UPdate


RayCase  
D
rawMesh는 직적 Culcing해야하는 부분이 고려  


--- 마지막

GPU 부하  

PixelOVerDraw  
주로 복잡한 UI, Particle에서 겹쳐져 있는 부분  
파티클, 주로 Billboard를 쓰는데, 완전 투명한 영역이 있음  
타이트한 지오메트리를 쓰는 것을 추천  

훔질이 허용하는 선에서는 병합해서,  

UI, 복잡도가 높기 떄문에  
꼭 가려지는 1,2개 정도 있는데  
꼭 꺼주시고  

Alpha 0 일때 아예 꺼주는 것이 있는데  
최신와서는 활성화되어 있는지 여부를 확인해야야


Shader  
SHader가 가지는 Pixel Coverage  
Native Profiler를 쓰면 , 쉐이더, 스크린 기준으로 픽셀? 이 얼마나 쓰이고 있는 지 확인 가능  
직접 Shader 최적화 한다고 했을때, 정적 정보를 수집하시고, 사용되는 인스트럭션의 정밀도?? 등이 포함되는데, 높은 정밀도의 인스트력션인 경우 정밀도를 낮추는 경우 효과?? 위치나 시간과 과련된 인스트력션인 겨우는 주의를 해야 ㅎ마.

- 동적 분기 제거?
  - 동기성을 위해 제거할 필요가 있다?

픽셀보다 작은 삼각형의 경우 3개의 버텍스? 낭비가  
Micro triangle  

측정이 쉽지 않다  
모바일..?  
HDRP만 제공하느 ㄴ중  

NativePRofiler 쓸 수 있지만 ,쉽지 않다  

설명하기 어려운 GPU 부하는 이것을 의심해볼 수 있다.  

---

## Mobile Native Debugging & ANR

### ANR 정의

Applicaftion Not Responding  
int Android  

App freezing  
IOS

Unity Main Thread != Android Main Thread  
연동이 안되면서 발생  

크게 5가지  

5초는 설정가능 (절대적 수치 X)

입력 전달 타임아웃  
- 입력 에 5초 이내 응답하지 않음
서비스 실행
- 서비스 수 초내 실행을 ㅡ완료하지 않음
StartForeground()
tjqltmrk "를 호출하지 않음
브로드캐스트
JobScheduler  

입력 전달에 집중 설명  

ANR Thread 동작
- Dump 작성

이부분에 문제  

AND 감지 시점 stack trace가 정확한 시점 알기 어려움  

MAinThread BLco kStarted  
UserInputEvetn  
5초 timeout  
OS Triggers the ANR  
수초후에 ANR Dlialog Shwon  

처음 시작했을때의 StrackTrace가 아니라  
수초 지나서 캐치할떄의 StackTarce를 보여주기 떄문에  (정확하지 않음)

다양한 레벨에서 숨겨져 있을 수 있음  

이것은 유니티에서 Crash 등으로 취급됨  

## Debugging 방법

Natice Device의 로그 수집
-> Android Logcar Pakcage

Wifi도 페어링도 가능??  

Package, Input도 가능하네?   

ADB dumpsys?

adb bugreprot <directory>  

- Tip
  - 가장 빈번한 Andoid Version 체크
  - " Device 체크
  - 발생 싲가 APP Version 체크
  - 개발자 모드 + Perfetto
    - MainThread 체크
  - Third-party package 제거 테스트
  - Android Studio Simulator 사용??

Methodology

- 보고 서비스 통합
- 리포트를 분석, 스택 트레이스가 의미있는지 확인
  - 게임 관련 문제 != 안드로이드 런타임 라이브러리 or 저수전 라이브러리
  - 빌드 ID ghkrdls
    - ㅣㅑㅠㅑㅣ2체ㅔ..내 vkdlfdl dnlcl
    - ㄱㄷㅁㅇ딜 -ㅜ ㅣㅑㅠㅑㅣ2체ㅔ.내 ~~~~

발생 위치별 ANR  

- 게임 코드
  - cpp로 변환된 C#
  - 스택 트레이스 libil2cpp.so
    - C# 코드에서 오류 발생
  - 스크린 Game.cpp에서 올 발생
    - Logger는 C#스크립트의 클래스 이름
    - Log는 함수 이름
  - C# 프로젝~~
    - 사진 참고
- 엔진코드
  - 사진 참고
- 타사 SDK 플러그인
  - 사진 참고
- 시스템 라이브러리
  - 일반적으로 개발자가 제어할 수 없음
  - Google 문의, 로그를 추가하여 문제 범위 좁히기, ANR 가능성 적음음

- 메모리와 ANR 관련성
  - 종종 보고되는 사례 중 LowMemory 콜백 호출 확인
  - Activity가 백그라이누드로 전화되고 AOS에서 메모릴 경고를 수신할 때 발생 추정
  - 유휴메모리와 ANR 밀접한 관계 확인

## 사례

유니티 최대 정지는 4초?  

@비동기 작업 시간 어떻게 탐지?  

Surface Desrotyed  
재현 어볇고
APp & 그래픽 장치 간의 잘못ㅅ된 상태와 관련이 있을 가능성  

---

## 최적화 모시꺵

5가지 내용 

### 성능타겟러정

가장 중요한 것은  Mindsetㅇ르  성능 주도적으로  
성능에 대해서 이야기 할 때는 

타겟 프레임 타임  
이것을 밀리타임 단위로 생각해야 함  
특정 프레임을 렌더링/마무리 CPU에서 마무리ㅏ는데 얼마나 많은 시간이 ㅓㄹ리는 지 중요하니까요  

주의할 부분  
특정 FPS 예로 30으로 하면 33, 60이면 16ms, 90ms 11ms 초가 됩니다  
그래서 밀리초 단위로 계산을 해야  

일관성이 있어야?  
FPS가 울렁이면 디터, 물리, 애니메션 등이 튄다  

성능 버퍼을 만들어야 한다  

그 가운데 65%만 써야 한다  
배터리를 아낄 수 있고, 성능이 약간 저하될 때 버퍼역할을 한다  
발열, 등  

숨을 돌릴 수 있는 공간을 둬야 한다  
공간을 둬서 쿨다운 할 수 이쎅  

버킷을 전부 쓰면 어렵다  

33ms 21ms초  
60FPX 16 10ms 초 등  

다양한 부분에서 프로파일링  
여러 종류의 기기 (저가 고가 OS ㅔ조자 드라이버 등)

일관성있는 프로파일링을 재현가능한 환경에서  
언제나 이씬을 자동으로 재생하면서  혹은 렌더링함녀서  
일반적인 고객처럼 일관성 있게 재현 가능해야  
일관성 확보가 중요하다  

Profile early, oftne, and on the target device  

프리프로덕션, 등등 성능 검증 등  
모발일 - 모든 디바이스가 성능이 다르고 뭔가 고민거리를 주고  
에디터 재현 불간으 

- 렌더 타겟 아키텍켜

Dedicated Graphics Memory  
OldSchool  
노트북, 컴 등 개별적인  처리  

이게 Old School 인이유  
이제 대부분은 Unified  
CPU GPU 공유한 RAM을 쓰고 있다는 뜻  

아닌경우가 이것이 정말 리소스를 많이 쓰고 있다  

PC, Labtop은 전기 연결하면 되는데  
모바일은 그렇지 않죠  

그래서 (타일 메모리)를 쓰는 것이 중요  
렌더링이 화면 한 번ㅇ ㅔ그리지 않고, 타일 상으로 된다  ?

좀 더 효율적으로  

실제 렌더링 워크 플로우  

씬이 렌더링 되면 씬이 프로세싱을 핞다  
버테긋가  어떤 숫ㄴ서로 렌더링 되어야 하는지  

카메라 안보이는 오브젝트를 제거한다던지 Culling  등을  

모든 리소스가 Ram쪽으로  

이것을 GPU가 읽어낸다  Struct Resoruces  

타일 메모리를 쓰게 되고  

Vertex, Fragment SHader를 쓰고  
전부 기억하지는 않아도 되고  

하나하닁 프레임에 
계속 카피하고 읽어내고 바녹되기 떄문에  

나눠서 효율적으로 하는 것이 중요  

너무 많이 생성되지 않도록 유의해야 한다 (데이터 카피, 읽는 과정)

- 프로파일 툴

Project Auditor  
새로운 기능  
WIP  
코드 이슈가 뭐가 있는지, 그 강도는 어떤지 등
정적인 분석  
런타임이 안리 ㅏ최적화 첫걸음으로 ㅗ게된ㄴ 

Profiler  

Frame Debugger 
유니티 파이프라인에서 뭐가 어떻게 벌어지고 있느지 등  
자세하진 않지만, 어떻게 되고 있거나  

Shader DrawCall Batching 등을 디버깅 간으  

Frame Debugger 좀 더  

어떻게 씬이 만들어져 있는지 확인 가능  
Bath, Batch Break가 어디서 어떻게 되느지 안ㄹ 수 있고  
그것을 알아내는 것을 시작으로 ~  

역에는 GPU Profierl  
추천되는 것은 (유니티에서도 쓰이는)
RenderDOc AOD
Metal GPI Debugger IOS  

RenderDOc 예시  

TimeLine 등이 있고  (이벤트들)  
좌긏ㄱ 상단에는 Event 브라우저가 있다  
어느정도 느리게 진행이 되는ㄷ, 상대적으로 각각의 콜들이 그래픽스 콜에서 얼마나 차지하는지 (쌍대적으로 (절대 X))  

그리고 오른쪽은 텍스쳐 뷰어  
실제로 어떤 Output이 나오는지  
느린데 뭘 그리고 있는건지?  

등을 알려주는  

구체적으로 하면 끝이 없고  
핵심은 시작을 잡을 수 있다

- 성능저하 그래픽 실수들

가장 중요한 것은 우리 모두가 한다는 것  

Mesh Mistiakes  

복잡한 지오 메트리대쉬  

많은 삼각형  
삼각형의 형태도 중요하다  
모바일은 타일 기준으로 화면을 쪼개는데, 이 삼각형이 타일에 딱 맞아 떨어지면 좋을 수록 좋다  
납작한 게 좋다?  
완벽하면 GPU가 더 효율적으ㅗㄹ 가능  

마이크로 삼각형  
엄청나게 많은 삼각형 (하나의 타일에 엄청 많음)  

LOD를 사용하지 안흔 것  
타일 렌더링을 십분 화룡하려명 LOD 

카메라 사용 숫자 줄여야한다  
2개 이상은 하나로 줄일수있냐 언제나 물어본디 - 엄청 복잡하긴 하죠
CPU 오버헤드가 엄청 걸린다

컬링 레이어를 쓰는 것을 추천  
Read/Write enabled 화성화 하지 않기?  


텍스쳐 실수들  
Max Size를 사용하지 않는 것  


- 내부 지식? 교훈?
