---
title: "OOP | 객체"
# description: ""
categories: [컴퓨터, 프로그래밍]
tags: []
image: "/assets/img/background/kururu-lab.jpg"

# 객체지향의 사실과 오해

date: 2024-04-23. 05:18
# last_modified_at: 2024-04-27. 13:30
# last_modified_at: 2024-08-29. 21:06
# last_modified_at: 2024-08-30. 00:54
last_modified_at: 2025-05-28. 21:52 # +Q: 왜 OOP
---

{% include custom/computer/programming-paradigm.html %}

## Q

---

- OOP 설명
  - OOP의 개념
  - OOP의 요소
  - SOLID
  - 상속, 다형성, 가상함수
  - 오버라이딩과 오버로딩 정의
  - 왜
- 의견
  - OOP에 대한 자유로운 의견
  - 클래스 세분화(단일책임원칙)에 대한 자유로운 의견

## OOP

---

객체 지향 프로그래밍 (Object Oriented Programming)  

- 객체와 클래스를 중심으로 코드를 구성. (기본 단위/블록)
- (재사용 -> 코드 중복 최소화 -> 간결한 코드, 변경 최소화) -> 유지보수, 확장성 용이

새 SW 개발을 위해서는 처음부터 모든 것을 개발해야...  
-> 코드를 재사용하는 방법?  
-> 객체 지향 프로그래밍  

Like 컴퓨터  
객체를 조립해서 프로그램을 만들자.  

- 컴퓨터
  - 부품 하나하나를 자신들이 만들지 않고 다른 업체의 부품을 구입하여 조립
  - 부품이 고장나면 해당 부품만 고치거나 교체

## Object

---

객체 `Object`:  
상태와 동작을 가진, 실재하는 대상(물체, 개념 등 인지할 수 있는 모든 것).  

- 속성 `State`: 객체의 특징, 상태 (데이터) -> 변수 `Variable`
- 행동 `Behavior`: 객체의 동작, 기능, 행위 (알고리듬) -> 함수 `Function`

클래스 `Class`:  
객체를 만들기 위해 구현하는 코드 블록 (형틀 `Templete`, 청사진 `Blueprint`).  
어떤 종류의 모든 객체에게 공통적인 변수와 함수를 정의.  

인스턴스 `Instance`:  
클래스로부터 만들어지는 개체  
여러 인스턴스가 필요한 경우 (객체 지향에서도) -> 같은 클래스로부터 생성  
인스턴스들은 하나의 함수 공유, 변수는 각각 가지고 있음.  

## OOP의 요소

---

### 추상화

- 복잡한 객체를 간결하고 명확하게 표현하기 위해,
- 세부 사항들은 제거, `본질`(공통적인 특성이나 기능)을 강조
- -> 프로그램을 이해하기 쉽게 만들어주며 관리하기 편하게.

Like 지하철 노선도 (지리를 추상화)  

`Abstract Class`, `Interface` (역할과 구현의 분리)  

### 상속

- 기존 클래스를 재활용하여 새로운 클래스 생성
  - 부모 클래스로부터 변수와 함수, 인터페이스를 물려받고, 이를 간편하게 사용 가능
  - 자식 클래스에만 필요한 기능을 추가할 수 있음.

- 이미 작성된/검증된 클래스 재사용, 계층구조를 형성
- 코드 재사용 -> 코드 중복 감소 -> 유지보수 용이

### 다형성

- 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질
- 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것

- 맥락에 따라 동일한 이름으로, 서로 다른 속성/기능을 구현할 수 있는 기능
  - `Overloading`: 매개변수의 개수나 타입이 다른 여러 메소드를 정의하는 것.
  - `Overriding`: 상속 관계에 있는 부모 클래스의 메서드를 자식 클래스에서 재정의 하는 것

- 여러 종류의 객체를 하나의 타입으로 다루기 (같은 하나의 모양으로 접근, 처리, 컨테이너에 담기)

- 객체 A가 객체 B의 속성과 기능에 직접 접근한다
- -> 객체 B가 수정되면 객체 A도 수정되어야 한다 -> 의존한다 -> 결합도가 높다

- 객체 A가 객체 B의 인터페이스에만 의존한다
- -> 객체 B가 수정되어도 객체 A는 수정할 필요가 없다 -> 의존하지 않는다 -> 결합도가 낮다!

### 캡슐화

관련된 데이터와 알고리듬이 하나로 묶고, 외부에서 접근을 제한  

#### 목적 1. 연관된 데이터와 알고리듬 묶기

- 다른 사람이 작성한 코드를 쓰기 위해서는 코드 자체가 잘 정리되어 있어야 한다
- 캡슐로 싸여 있지 않으면 내용물이 흩어지게 되고 복용하기 힘들 것이다.
- Like 캡슐약

#### 목적 2. 정보은닉

객체의 실제 구현 내용을 외부로부터 감추는 것  
By [접근 제어자](/posts/access-modifier/), `Getter/Setter`  

캡슐로 싸여 있지 않으면 내용물이 보호되지 않을 것이다 (변질, 조작)
Like 캡슐약  

- `Data Protection` 데이터 보호: 외부에서 데이터를 직접 접근하지 못하도록 함.
  - -> 오류를 줄이고 유지보수를 용이하게 해 줍니다.
- `Data Hiding` 데이터 은닉: 내부 데이터를 외부로부터 숨김.
  - 외부에서 객체의 내부 구조를 알 수 없으며 객체가 노출되는 UI/UX를 통해서 상호작용만 가능합니다.
  - -> 객체의 내부 구조를 숨기고 외부에서 접근을 제한하여 객체의 무결성을 보호합니다.

#### 외부에서 세부 사항을 알 수 있다면?

세부 사항을 수정하다 고장이 나면, 원작자가 고칠 수 없다  
수정하지 않아야 원작자가 고칠 수 있다  

단, 외부 인터페이스를 통해서는 얼마든지 수정/사용할 수 있다  
공식적으로 허용한 부분이니까  

Like 전자기기  

#### So?

다형성과 마찬가지로, 느슨한 결합!  
(`Car.StartEngine()`, `Car.MoveForward()`, `Car.OpenWindow()`) -> `Car.Operate()`

## 메모

---

### 참고

- [참고: '객체 지향 프로그래밍의 4가지 특징ㅣ추상화, 상속, 다형성, 캡슐화'](https://codestates.com/blog/content/객체-지향-프로그래밍-특징)
