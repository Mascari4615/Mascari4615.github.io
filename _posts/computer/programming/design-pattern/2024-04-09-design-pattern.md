---
title: "프로그래밍 디자인 패턴"
# description: ""
categories: [💫Computer, 🌗Programming]
tags: [Design-Pattern]
image: "/assets/img/background/kururu-lab.jpg"

date: 2024-04-09. 16:18
# last_modified_at: 2024-04-23. 05:28
# last_modified_at: 2024-05-22. 02:40
# last_modified_at: 2024-09-02. 12:55
# last_modified_at: 2024-09-29. 19:11
last_modified_at: 2024-10-19. 11:55 # 메모 정리
---

## 💫 Q

---

- 알고 있거나 써 본 디자인 패턴이 있다면 설명해 주세요.
- `디자인 패턴`이 뭔가요?
- `싱글톤`이 뭔가요?
- `옵저버 패턴`이 뭔가요?

## 💫 프로그래밍 디자인 패턴

---

- 반복적으로 발생하는 문제와 해법의 쌍
- 재사용할 수 있는 방식

- 그대로 쓰기보다는 상황에 맞게 알잘딱하게

- 주로 객체 지향 프로그래밍에서 사용

### 🫧 디자인 패턴의 구성요소

- 이름: 의미 있는 패턴 식별자
- 문제
- 해결책: 완전한 설계가 아니라 다양한 방식으로 실현될 수 있는 설계 해결책을 위한 템플릿
- 결론: 패턴을 적용한 결과와 트레이드 오프

## 💫 GoF, 23가지 디자인 패턴

---

- 대표적으로 구체화된 디자인 패턴은 GoF \| Gang of Four에서 제시한 총 23개의 패턴이 있음

### 🫧 목적에 따른 분류

#### 생성

객체 생성에 관련된 패턴.  
특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 최소화할 수 있도록 유연성 제공.  

- **`싱글턴 | Singleton`**:
  - 한 클래스마다 인스턴스를 하나만 생성하여 어디서든 참조
  - 어디서든 참조/접근 가능하다는 점은 장점이자 단점이 될 수 있음
  - In Unity
    - 씬을 여러번 불러오는 상황 등
- **`팩토리 | Factory`**:
  - **`추상 팩토리 | Abstract Factory`**: 구체적인 클래스를 지정하지 않고 인터페이스를 통해 연관되는 객체들을 묶어줌
  - **`팩토리 메소드 | Factory Method`**: 객체 생성을 서브 클래스로 분리하여 위임 (캡슐화)
- `빌더 | Builder`: 객체의 생성과 표현을 분리하여 객체를 생성
- `프로토타입 | Prototype`: 원본 객체를 복사하여 객체를 생성 (클론)

#### 구조

프로그램 내 자료구조나 인터페이스 구조 등 프로그램 구조를 설계하는데 사용되는 패턴.  
클래스나 객체를 조합하여 더 큰 구조를 만들 수 있게 해줌  

- `어댑터 | Adapter`: 클래스의 인터페이스를 어떤 클래스에서든 이용할 수 있도록 변환
- `브릿지 | Bridge`: 구현부에서 추상층을 분리하여 각자 독립적으로 변형하고 확장할 수 있도록 함
- `컴포지트 | Composite`: 객체들의 관계를 트리 구조로 구성하여 표현하는 방식으로 복합 객체와 단일 객체를 구분없이 다룸
- `데코레이터 | Decorator`: 주어진 상황에 따라 객체에 다른 객체를 덧붙임
- `파사드 | Facade`: 서브시스템에 있는 인터페이스 집합에 대해 통합된 인터페이스 제공
- `플라이웨이트 | Flyweight`: 크기가 작은 여러 개의 객체를 매번 생성하지 않고 최대한 공유하여 사용하도록 메모리 절약
- `프록시 | Proxy`: 실제 기능을 수행하는 객체 대신 가상의 객체를 사용해 로직의 흐름을 제어

#### 행동/행위

반복적으로 사용되는 객체들의 커뮤니케이션을 패턴화.  
객체 사이의 알고리듬 또는 책임을 분배하는 방법에 대해 정의됨.  
결합도를 최소화 하는 것이 주 목적 |Loose Coupling.  

- **`옵저버 | Observer`**: 객체 상태가 변할 때 관련 객체들이 그 변화를 전달받아 자동으로 갱신
  - `발행-구독 | Pub-Sub`: 발행자와 구독자가 서로를 모르도록 브로커 - 이벤트 버스를 이용
  - <https://velog.io/@luz0415/Unity디자인-패턴-옵저버-패턴-발행-구독-패턴>
- `책임 연쇄 | Chain of Responsibility`: 요청을 받는 객체를 연쇄적으로 묶어 요청을 처리하는 객체를 만날 때까지 객체 Chain을 따라 요청을 전달
- `커맨드 | Command`: 요청을 객체로 캡슐화하여 재사용하거나 취소
- `인터프리터 | Interpreter`: 특정 언어의 문법 표현을 정의
- `반복자 | Iterator`: 컬렉션 구현 방법을 노출하지 않으면서 모든 항목에 접근할 수 있는 방법을 제공
- `중재자 | Mediator`: 한 집합에 속해있는 객체들의 상호작용을 캡슐화하여 새로운 객체로 정의
- `메멘토 | Memento`: 객체가 특정 상태로 다시 되돌아 올 수 있도록 내부 상태를 실체화
- `상태 | State`: 객체의 상태에 따라 동일한 동작을 다르게 처리
  - <https://velog.io/@jinmin2216/디자인-패턴-스테이트상태-패턴-State-Pattern>
- [`전략 | Strategy`](/posts/strategy-pattern/): 동일 계열의 알고리듬군을 정의하고 캡슐화하여 상호 교환이 가능하게 함
- `템플릿 메소드 | Template Method`: 상위 클래스는 알고리듬의 골격만을 작성하고 구체적인 처리는 서브 클래스로 위임
- `방문자 | Visitor`: 객체의 원소에 대해 수행할 연산을 분리하여 별도의 클래스로 구성

## 💫 그 외

---

### 🫧 Finite State Machine (FSM) | 유한 상태 머신

상태를 전이 기반으로 동작을 제어하는 방식.  
하나의 상태만을 가진다.  

상태가 다양해지고 복잡해질수록 상태의 흐름을 파악하기 어렵고, **상태의 흐름을 재사용할 수 없다.**  

### 🫧 Behaviour Tree (BT) | 행동 트리

노드들의 집합.  
트리처럼 루트 노드로 부터 위-아래, 왼쪽-오른쪽으로 내려오면서, 현재 상황에 맞는 Action \| 행동을 취하도록.  

각 노드가 개별 로직으로 모듈화 돼있어서 상황과 목적에 따라 재사용이 가능하고, 결합 순서에 따라 순차적으로 실행되기 때문에 특정 행동의 연결과 해제가 용이하다.  

### 🫧 Object Pooling | 오브젝트 풀링

오브젝트를 미리 생성해둔 후 필요할 때 쓰고, 필요하지 않을 때 비활성화, 다시 꺼내쓰고, 재사용 가능한 객체 집합을 관리하는 패턴.  

## 💫 메모

---

{% include embed/youtube.html id='Mq4MwPXWarI' %}
{% include embed/youtube.html id='iyeRmq24HVk' %}
