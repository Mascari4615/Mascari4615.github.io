---
title: "Register | 레지스터"
# description: ""
categories: [💫Computer, 🌘System]
, Memory]
image: "/assets/img/background/kururu-lab.jpg"

date: 2023-11-17. 02:50
# last_modified_at: 2023-11-26. 01:45
last_modified_at: 2024-08-29. 22:13
---

[여치의 프로그래밍 강좌 #6](http://yuchi.duckdns.org/xe/Programming_QA/5950)  

## 💫 Register | 레지스터

---

CPU 안에 들어있는 고속 메모리.  
CPU와 직접적으로 연결되어 있어 빠르다.  

CPU의 상태를 저장하거나, 데이터 이동, 산술 연산 등의 용도로 사용된다.  
프로그래머가 짠 코드는 레지스터를 제어하는 코드라고 볼 수 있다.  

단순히 데이터를 저장하는 용도로 쓰이기도 하지만, 저장된 데이터 값에 따라 하드웨어 등의 상태에 영향을 미치기도 한다.  

레지스터는 CPU 내 번호, 주기억장치 주소의 일부 영역, 입출력 포트 번호 등으로 접근 가능하다.  

컴퓨터 구조에 따라 크기와 종류가 다양하다.  

@ 인텔계 x86 cpu는 메모리 → 메모리 전송도 가능하지만, 그 외 상당수 CPU는 데이터 이동에서도 레지스터를 거쳐야만 한다.  

## 💫 레지스터의 유형

---

### 🫧 CPU 레지스터

CPU 내에서 위치하여 CPU 제어  

- 연산 (누산기) = A Register  
- 값의 임시 저장 용도 = S Register 로 사용
- A, PC, MBR, MPN \| S, T

### 🫧 특수 레지스터

컴퓨터 전반에 걸친 상태를 설정하거나 현재 상태 표시  

- SFR Special Function Register \| 특수 기능 레지스터
- SPR Special Purpose Register \| 특수 목적 레지스터
- SR Special Register \| 특수 레지스터

### 🫧 입출력 레지스터

입출력 장치와 연결되어 입력이나 출력할 때 데이터 전달 통로 역할  

## 💫 레지스터의 선행자 X, E, R

---

x86 CPU 기준, 특수한 몇 개의 레지스터들을 제외하고는 모두 32비트 레지스터이다.  
16비트, 32비트는 선행자 E (32비트 386부터), 64비트는 선행자 R을 붙인다.  

16-bit, X → heX.  
32-bit, E → Extended.  
64-bit, R → Register.  

[선행자 어원 - 참고](https://stackoverflow.com/questions/43933379/what-do-the-e-and-r-prefixes-stand-for-in-the-names-of-intel-32-bit-and-64-bit-r)  

## 💫 범용 레지스터 - 데이터 레지스터

---

### 🫧 데이터 레지스터

보통 산술 연산에 많이 쓰이고, 몇 가지 특수한 기능이 있는 레지스터다.  
4개의 레지스터 모두 같은 규칙을 따른다.  

8비트씩 쪼개서 사용 가능한데, 이는 단순히 나눠 쓰기 위함도 있고, 과거 8086과 호환성을 유지하기 위한 것도 있다.  

예를 들어보면 다음과 같다.  
AL(Low) + AH(High) = 16-bit AX.  
+16-bit = 32-bit EAX.  
+32-bit = 64-bit RAX.  

### 🫧 AX, DX

곱셈 나눗셈을 할 때는 반드시 이 레지스터들을 사용해야한다.  
연산의 결과 혹은 소스의 값이 64비트일 때 하위 32비트 = EAX, 상위 32비트 = EDX에 저장된다.  
인텔계 컴파일러에서는 함수의 리턴값이 EAX 레지스터를 통해 전달된다.  

### 🫧 BX

기본적인 범용 레지스터 기능을 가지고 있다.  

### 🫧 CX

Counter, loop/movs 등의 명령과 함께 쓰일 경우 카운터로 쓰인다.  

## 💫 범용 레지스터 - 포인터 레지스터

---

### 🫧 Stack Pointer, SP/ESP/RSP

현재 스택의 위치를 가리키는 레지스터
임의로 조작할 수도 있지만 일반적인 프로그램을 짤때는 건드리지 않는 것이 좋다.  
push, pop 명령과 연동된다. push하면 4바이트 감소, pop하면 4바이트 증가한다.  
스택은 미리 일정 사이즈를 확보해놓고 그 상태에서 사용할때마다 0을 향해서 감소해가는 형태이기 때문에, push했을 때 스택포인터가 감소한다.  
메모리 공간에서 push는 할당, pop은 해제라고 생각하면 된다.  

### 🫧 Base Pointer, BP/EBP/RBP  

일반적으로 함수 진입 시에 스텍 프레임과 함수 안에서 자유롭게 사용하게 될(push, pop) 스택 공간과의 경계를 지정하기 위해 사용한다.

물론 EBP를 사용하지 않고 바로 ESP로 억세스 해도 되지만 (실제로 컴파일러가 최적화할땐 그렇게 한다) 짤 때 엄청나게 헷갈린다.  
가령 함수에 진입했을 때 첫 번째 인자는 EBP+8의 메모리에 존재하지만 ESP 기준으로는 어디가 될지 모른다.  
push, pop할때마다 ESP의 값이 바뀌기 때문에 기준점으론 삼을 수가 없는 것이다.  

## 💫 범용 레지스터 - 인덱스 레지스터

---

### 🫧 인덱스 레지스터

인덱스 레지스터는 범용 레지스터들처럼 쪼개서 사용할 수 없다.  
32비트 그 자체로만 사용할 수 있다.  
데이터 이동에 관련된 특수한 명령들을 사용할 때 source와 destination 어드레스를 지정하는 등 주소지정에 관련된 특수 기능을 가지고 있기 때문에 인덱스 레지스터라고 한다.  

### 🫧 Source Index SI(16-bit)/ESI/RSI

왜 source인고 하니 특수한 데이터 이동 명령 movs 등을 사용할 때 esi에 source 메모리의 어드레스를 넣어야 하기 때문이다.  
그 밖에는 일반적으로 메모리의 주소를 지칭할 때 이 레지스터를 사용한다.  

### 🫧 Destination DI(16-bit)/EDI/RDI

ESI와 기본적으로 같고 movs등을 사용할 때 destination 어드레스를 넣어야 한다.  

## 💫 특수 기능 레지스터 - IP 레지스터

---

### 🫧 Instruction Pointer IP 레지스터  

프로그래머가 사용할 수 없는 레지스터,  
다음으로 실행될 프로그램 명령행의 위치를 저장한다.  

IP + 1, 연속적으로 실행해 명령행을 순차적으로 실행한다.  
IP = n, 다른 위치로 한번에 이동해 if, while 과 같은 명령을 수행한다.  

## 💫 그 외

---

디버그 레지스터, 플래그 래지스터 같은 특수한 레지스터들은 유저모드 프로그래밍에선 쓸 일이 없다.  

### 🫧 MMX레지스터  

펜티엄 클래식 MMX버전부터 추가되었다.  
정확히는 물리적으로 존재하는 레지스터가 아니고 FPU 스택을 레지스터처럼 사용한다.  
MM0 ~ MM7, 8개가 있다.  

### 🫧 SSE레지스터

펜티엄3부터 추가되었다.  
32비트 float 데이타 4샘플을 동시에 처리할 수 있는 128비트 레지스터이다.  
XMM0 ~ XMM7 8개가 있다.  
