---
title: "IO"
# description: ""
categories: [💫Computer, 🌘System]
tags: []
image: "/assets/img/background/kururu-lab.jpg"

date: 2023-11-10. 09:21
# last_modified_at: 2023-11-15. 15:51
last_modified_at: 2024-08-29. 22:12
---

## 💫 IO

---

Input/Output, 입출력  

사람의 뜻 (조이스틱, 마우스, 키보드 등)을 CPU에, CPU의 뜻 (산술연산 결과, 디스크에 저장된 이쁜 누나 사진 등의 데이터)을 여러분에게 전달하기 위해서(일반적으로 모니터를 통해서)는 반드시 입출력이 필요한 것이다.
CPU 입장에서 메모리에 쓰고 읽어오는 것 자체도 I/O지만, 통상 주변 장치들과의 I/O를 뜻한다.
@ 여치  

## 💫 입출력 장치 IO Device

---

- 입출력 장치 IO Device
  - 입력 Input
    - CPU, DMA 등 프로세서가 주변 장치의 데이터 레지스터 Data Register로부터 데이터 값을 읽어 주기억장치로 복사하는 작업
    - 데이터 레지스터로부터 값을 읽을 때에는 상태 레지스터 Status Register의 데이터 준비 상태를 확인해야 함
      - 준비되지 않은 상태에서 읽을 경우 엉터리 값을 읽게 됨
  - 출력 Output
    - 입력과 반대로 주기억장치으 데이터 값을 읽어 주변장치의 데이터 레지스터로 복사하는 작업
    - 데이터 레지스터에 값을 쓰기할 때에는, 상태 레지스터에서 이전 데이터의 출력이 완료되었는지 확인해야 함
      - 이전 데이터의 출력 완료 전 또 다른 데이터를 쓰기하면 출력 데이터의 정확성이 보장되지 않음

- 입출력 장치 구조
  - 입출력 장치 제어기 IO Device COntroller 입출력장치인터페이스
    - 상태 레지스터 Status Register
      - 데이터가 입력되었는가 혹은 데이터 출력이 완료되었는 가 등 장치의 상태를 표시하는 곳
    - 명령 레지스터 Command Register
      - 입력 혹은 출력 하라는 등의 명령을 보내는/쓰는 곳
      - 입력 명령에 따라 입력 => 동기적 입력 (디스크 등)
      - 입력 명령없이 수시로 입력 => 비동기적 입력 (키보드 등)
      - 출력은 언제나 동기화
    - 데이터 레지스터 Data Register
      - 입력된 데이터나 출력될 데이터를 임시 보관하고 있는 곳
    - 입출력 장치 구동기 IO Device Driver
      - 장치 제어기 인터페이스를 이용하여 입출력을 처리하는 소프트웨어

- 입출력 장치의 식별
  - 메모리 대응 입출력 Memory Mapped IO
    - 입출력 장치의 레지스터들의 위치를 주기억장치의 주소영역 일부에 대응
    - 주기억장치 (변수, 주소)에서 읽고 쓰기하는 동일한 방법으로 입출력이 이루어짐
    - 즉, 메모리 접근 명령어와 동일한 기계 명령어 (load, save 등)를 사용하여 입출력을 진행함
      - 개발자 입장에서 편리하나, 메모리 공간의 일부는 사용할 수 없음

- 입력 예  
  - load r1, 10
    - 메모리 10번지에 대응된 입력 레지스터에서 CPU의 r1 레지스터로 읽음 (입력)
  - save r1, 1000  
    - 입력된 데이터를 메모리 1000번지에 저장
- 출력 예
  - load r1, 2000
    - 메모리 2000번지의 데이터를 CPU의 r1 레지스터로 적재
  - saver1, 20
    - 적재된 데이터를 메모리 20번지에 대응된 출력 레지스터에 기록 (출력)

- 격리된 입출력 Isolated IO
  - 주기억 장치의 주소 영여과 별개로 입출력 장치 주소 영역 (포트, Port)이 따로 있음
  - 즉, 메모리 10번지와 입출력 포트 10의 숫자는 동일하지만 지시하는 위치는 전혀 다름
  - 따라서, 메모리 접근 기계어 외에 입출력 포트 접근을 위한 전용 기계 명령어 (in, out 등)가 필요함
  - = 메모리 공간을 모두 사용할 수 있으나, 시스템 설계가 다소 복잡해짐

- 입력 예  
  - in r1, 10
    - 입력 포트 10번지의 입력 레지스터에서 CPU의 r1 레지스터로 읽음 (입력)
  - save r1, 1000
    - 입력된 데이터를 메모리 1000번지에 저장
- 출력 예
  - load r1, 2000
    - 메모리 2000번지의 데이터를 CPU의 r1레지스터로 적재
  - out r1, 20
    - 적재된 데이터를 메모리 20번지인 출력 레지스터에 적재 (출력)

@@ Storage  

문제 4-2 명령어  
한 자리씩 오른쪽으로 밀린다, 가장 오른쪽에 있었던 것은 가장 왼쪽으로 간다

- 입출력 개관

- 입출력 과정
  - 응용 프로그램의 입출력 요구 => 운영체제 => 입출력 장치 (입출력 하드웨어) 인터페이스
  - 디스크, 키보드, 모니터, 인터넷 통신, 블루투스 통신, 시리얼 통신  

- 직접 데이터 입출력과 간접 데이터 입출력
  - 직접 입출력
    - 운영체제가 응용 프로그램과 HW 사이에서 데이터를 가공없이 그대로 전달
    - #RAW Device
    - #Special File (!Regular File)
    - #Major Number, Minor Number
  - 간접 입출력 (대부분이)  
    - 운영체제가 응용 프로그램과 HW 사이에서 데이터를 가공하여 전달  
    - #계층적 저장구조를 위해서  
    - #파일 시스템
    - #TCP/IP 프로토콜 네트워크 패킷(헤더) 같은 걸 붙이는  

- 문자 Character 입출력 장치와 블록 Block 입출력장치
  - 문자 입출력 장치
    - 바이트 단위의 가변적 크기의 입출력 (키보드, LAN 등)
  - 블록 입출력 장치
    - 디스크의 512바이트 단위 입출력과 같이 일정한 크기의 블록 단위 입출력  
    - #하드디스크는 한 바이트를 수정하려면 그 바이트가 포함된 한 섹터를 수정하고 전체를 덮어씌워야 함  

파일 기술자 File Descriptor : 파일의 상세 정보에 대한 지시자  

- 파일 입출력 절차 (유닉스/리눅스)
  - 입출력 시스템 호출 (시스템 콜)
    - Open Read Write Close  
    - SW 인터럽트 기법으로 OS에 진입
    - Copy in  
      - 사용자 영역 => 운영체제 영역 방향으로 데이터 복사
    - Copy-out
      - 사용자 영역 <= 운영체제 향으로  

- fd  = open("path", ...) <= 파일 기술자
- n = read(fd, buf, size)
- n = write(fd, buf, size)
- close(fd)

- 파일 테이블

- 대기 입 출력 Blocking IO과 비대기 입출력 Non-Blocking IO

- 입력 대기 방안
  - n = read(fd, buf, size)
    - 1바이트라도 입력될 때 까지 대기 → Blocking IO
    - size 바이트까지 대기 → Blocking IO
    - 입력이 없으면 대기없이 오류 리턴 → Non-Blocking IO

- 출력 대기 방안
  - n = write(fd, buf, size)
  - 1 바이트라도 출력될 때까지 대기 → Blocking IO
  - size 바이트까지 대기 → Blocking IO
  - 현재 출력이 불가능하면 대기 없이 오류 리턴 → Non-Blocking IO

- 왜 중요하냐, 인터넷에서 클라가 어떤 포털 사이트에 로그인을 신청하면 이 프로그램은 이제 뭘 받아야해 아이디하고 패스워드를 읽어들어야겠지 그게 이걸로 하는거야 인터넷에서는 read 대신 receive도 가능, 서버 입장에서는 합리적인 시간 내에서 입력을 받아야 하겠지, 근데 클라가 만약에 입력을 안해 그러면 요 방시그올 (Block) 운영체제를 운영하고 있다면, 입력이 없으니까 입력 대기 상태에서 멈춰있겠지, 한 사람이면 문제가 없는데 클라가 많은 사람이 연결해서 입력을 안하고 있다면.., + 접속할때마다 메모리도 할당을 해주는데 그게 안딘다, DOS 고의로 연결을 하고 입력을 안하는것, 그래서 Non-Blocking 방식으로, 어느 일정 시간 동안 입력이 없으면 끊어버림, 그런것과 관련이 있다  

- 입출력 장치 구동기 (드라이버 드라이버 Device Driver)
  - 메모리 대응 입출력, 격리된 입출력
  - 동기 입력
    - 디스크 등과 같이 데이터가 컴퓨터 내부에 저장되어 있는 경우
    - 명령 레지스터에 '읽기' 명령을 명시적으로 설정
  - 비동기 입력
    - 키보드, LAN 등과 같이 데이터가 컴퓨터 외부에서 언제 얼마만큼의 데이터가 입력될 지 예측할 수 없는 경우
    - 상태 레지스터의 '준비' 상태로만 확인하여 입력
  - 동기 출력
    - 출력은 항상 동기식으로만 이룽짐
    - 명령 레지스터에 '쓰기' 명령을 명시적으로 설정

- 프로그램 입출력 (바쁜 대기 입출력 Busy-waiting I/O)  
- 입출력 장치를 반복구문으로 지속적으로 체크하여 입출력  

---

- 인터럽트 기반 입출력 Interrupt-Driven I/O  
- 입출력 완료 인터럽트 활용  
- vs Busy-Waiting  
  - 계속 기다리지 않고, 입력이 왔을 때에만 잠깐잠깐 다른 일  
  - CPU 효율 증가

- ISR Interrupt Service Routine

- DMA (Direct Memory access) IO
- 입출력 전담 프로세서 활용  

- 입출력은
- 단순히 외부 장치의 3가지 레지스터중 Data 레지스터에 대해  
- 레지스터에서 메모리로 데이터 복사 = 입력
- 메모리에서 레지스터로 데이터 복사 = 출력

- DMA는 위 내용만 할 수 있는  
- (Address, Count, Command)  
- vs Busy-Waiting  
  - CPU를 더 불려먹을 수 있다  
  - 주기억장치가 주기억장치인 이유는 CPU가 메모리에 접근하기 때문인데,  
  - DMA도 CPU처럼 직접 메모리에 접근하여 데이터를 넣거나 빼거나  
  - = Direct Memory Access

- 입출력 채널 IO Channel
  - 입출력이 지나가는 통로  
  - IOP IO Processor 라고 부르기도 함
  - DMA도 채널 중이 하나임
  - 실렉터 채널, 멀티플렉서 채널, 블록 멀티플렉서 채널 등의 유형이 있음  
  - Selector Channel 한 번에 하나 (속도가 빠름), Multiplexer Channel 병렬 처리 (속도가 느려서), Black Multiplexer Channel
