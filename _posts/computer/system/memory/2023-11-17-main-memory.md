---
title: "RAM, Main-Memory"
# description: ""
categories: [컴퓨터, 시스템]
tags: []
image: "/assets/img/background/kururu-lab.jpg"

date: 2023-11-17. 03:58
# last_modified_at: 2023-11-28. 09:50
last_modified_at: 2024-08-29. 22:13
---

## RAM, Main-Memory

---

- 임시 기억 장소, 기억장치 대신에 책상, 즉 작업공.
- 책상이 크면 그만큼 많은 것들을 올려놓고 작업할 수 있으니 빠르고 편하다. 책상이 손바닥만하다면 뭐 하나 하려고 하면 올렸다 내렸다 손은 바쁘게 움직이되 일 전체는 느려질 것이다.
- 메모리에 뭔가를 저장하고 다시 꺼내오려면, 주소(Address)가 필요하다. Like 물품 보관소

### RAM | Random Access Memory

랜덤 액세스 메모리 = 임의의 주소에 접근  

### Main Memory

주 기억장치.  
CPU가 직접 참조하기 때문에 '주' 기억장치.  

## Address

---

- 바이트 별 주소 지정
  - 대부분의 컴퓨터는 바이트 단위로 주소를 부여
- 바이트 단위 저장
  - 읽거나 쓰기는 반드시 바이트 단위로 이루어짐
- 1/2/4/8 바이트 동시 접근 (읽기/쓰기)
  - 기계 명령어 Machine Instruction에 따라 동시 접근하는 바이트 수가 다름
- 메모리 얼라이먼트 Memory Alignment
  - 1 바이트는 어디서든 되는
  - 2 4 8 등의 바이트 동시 접근 시 목표시작 주소를,
  - 2 4 8의 배수가 되도록 요구하는 기계 CPU가 있음

## 구조

---

### Text/Code

실제 실행되는 코드 등이 저장  

### Data

전역 변수 등이 저장  

### Heap

주로 메모리 동적 할당  
i.e. malloc, calloc, realloc  

### Stack

@@ Assembly  

Assembly가 빈번하게, 저장되는 값 저장, Subroutine, Procedure 등  
Stack 자료 구조  
BasePointer 시작 위치를 BP 레지스터, StackPointer 제일 위 위치를 SP 레지스터  
Glow Down, 다른 메모리 영역과 달리 거꾸로 자란다  

## 관리 개념

---

- 메모리 할당 및 회수가 이루어지는 시기
  - 디스크의 프로그램이 메모리에 적재되어 생성될 때 ← 첫 할당
  - 프로세스가 종료되었을 때, 회수
  - 프로세스가 메모리르 추가 요청할 때, 추가 할당
  - 프로세스의 실행을 잠시 보류하고 디스크로 옮길때, 회수
  - 디스크의 보류되었던 프로세스를 다시 실행 재개할 때, 재할당

- 할당 메모리 위치
  - 메모리 할당은 반드시 비어있는 곳에 이루어짐
  - 재 할당의 걍우 꼭 동일장소에 이루어져야 할 수도 있고, 다른 빈 공간에 이루어질 수도 있음

- 메모리 관리의 필요성
  - 위와 같이 메모리는 할당과 회수가 역동적으로 이루어지므로 어느곳이 비어있는지 어느 프로세스에게 어디에 어느만큼의 메모리가 할당되었는지에 대한 관리가 필요함

- 메모리 관리 전략(방법)의 분류
  - ~

- 전체 적재와 일부 적재, 그리고 가상 메모리
  - 전체 적재
    - 프로세스를 실행하기 위해 프로세스 이미지 (Text,Data,Stack등) 전체를 적재
    - 가장 기본적이고 이해가 쉬운ㅇ 전략
    - 실행중인 프로세스들 크기의 총합은 컴퓨터 메모리(주기억장치) 용량 초과 불가
      - 다중 프로그래밍 정도 Degree of Multiprogramming 가 낮아질 수 밖에 없음
  - 일부 적재
    - 프로세스 이미지의 필요한 일부만 적재하여 실행
    - 복잡하고 기교스런 관리 기법이 요구됨
    - 실행 중인 프로세스들 크기의 총합이 메모리 용량을 훨씬 초과할 수 있음
      - 가상 메모리 Virtual Memory
      - 다중 프로그래밍 정도를 높일 수 있음
  - 연속 ~
  - 논리 주소와 물리주소 Logical & Physical Address

@0516  

- 단일 프로그래밍 메모리 관리
  - 특징
    - 메모리에 오직 하나의 프로세스만 존재
    - 굳이 논리주소와 물리주소를 분리하거나, 이곳저곳에 분산 배재할 필요성없음
    - 메로이의 사용자 영역에 연속 할당
    - 다만, 프로그램의 크기가 메모리 용량을 초과할 경우에 대한 처리 방안 필요
  - OS 보호
    - 사용자 프로세스로 OS 영격 침범방지
    - 경계 레지스터에 경계값 설정, 주소가 이 범위를 벗어나면 예외발생으로 프로세스 분산시키
  - 오버레이
    - 프로그램의 크기가 메모리 용량을 초과하느 경우 처리방법
    - 프로그램을 여러 개의 작은 부분으로 분리
    - 분리된 부분을필요할 때 마다 동일 장소에 교체하여 적재 (동적 적재 Dynamic Loading
      - 개발자의 설계에 따라 OS에 요청하여 적재
    - 즉, 프로그래믱 분리 및 운영은 SW 개발자의 설계에 의해 이루어짐  

- 고정 분할
  - 개념
    - 메모리를 몇 개의 부분을 고정 분할하여 프로세스를 적
    - 목적 코드들은 특정 분할을 목표로 작성되거나, 임의의 분할에 적재될 수 있도록 재배치 가능 Eolocatable 하에 작성되어야 함  

- 고정 분할, 가변분할
  - 다중 프로그래밍 환경에서는 어떤 형태로든 메모리를 분할하여 할당해야함
  - 메모리를 분할하여 프로레스를 하나의 분할에 연속적으로 적재하는 방법은

- OS 및 다른 프로세스 보호
  - 다중 프로그래밍 환경에서는 OS 뿐만 아니라 프로세스를 끼지도 보호
  - 각 프로세스별로 자시느이 집 영역을 벗어나 참조한는 것을 방지하기 위해서는 주소의 상-하한을 성정하여 관리해야함 말하기도 한다
  - 즉 상-하한 경계 레지스터를 활용함

- 분할의 크기
  - 프로세서의 크기와 분할의 크기가 정확하게 일치하지 않아 메모리 일부가 낭비되는 내부 단편화 문제 Internal Fragmentation 발생
  - ~를 최소화하기 위해서는 분할의 크기를 가급적 아양하게 해야함

- 가변 분할
  - 메모리 전체를 풀로 보고 필요할 때마다 정확한 크기로 분할하여 할당
  - 프로세스들이 분할된 할당 하나에 연속저긍로 적재된다는 점은 고정 분할과 동일
  - 목적 코드들은 어느 주소 적재될지 예측할 수 없으므로 반드시 재배치가 가능해야 함
  - 혈당과 반납이 반복되면서 사용도가 극히 앉은 작은 빈 공간 (존재하는 외부 단편화, External Fragmentation) 문제 대두
  - 병합 과 통합 절차 필요

- 인접한 빈분할들의 병합 Coalescing
  - 할당되었떤 분하이 반납되어 빈분할이 되었을 때, 앞이나 뒤에 인접한 빈분하링 존재하면 이들을 병합하여 하나의 큰 빈분할을 만듦
  - 외부 단편화 최소화

- 분산된 빈 분할들의 통합 Compaction
  - 여기저기 흩어저잇는 작은 분할들을 이동시켜 하나의 큰 빈 분할로 관리
  - 빈 분할뿐만아니라, 사용중인 분할들도 이동이 불가피
  - => 모든 프로세스들에 대해 실행을 중단하고 재배치 작업이 필요함

- 가변 분할의 할당 정책
  - 죄적 적합 Best fit 할당
  - 최악 적합 Worst-fit 할당
  - 최초 적합 First-fit 할당
  - 순차 적합 Next-fit 할당
  - 인접한 빈 분할들의 병합 Coalescing

- 비연속 할당

- Paging & Segmentation
  - 프로그램을 원래 모양 그대로 적재하지 않음 (나눠서)
  - 여러 개의 논리적 조작으로 분리하여 메모리의 이곳저곳에 분산하여 적재
    - => 비연속 적재 (할당) 정책
  - 프로그램의 일부분을 적재하는 방법 (가상 메모리)으로의 발전이 용이
  - 페이징과 세그먼테이션은 프로그램을 논리적 조각으로 나누는 방법을

- Paging
  - 개념
    - 프로그램을 일정한 크기의 작은 조각으로 분리하고, 각각의 조각을 페이지라 함
    - 페이지 크기는 시스템에 따라 512~8K바이트
    - 메모리 또한 페이지와 동일한 크기로 분할하여 각 분할을 페이지 프레임 PageFrame이라 함
    - 프로그램의 페이지를 임의의 빈 페이지 프레임에 적재하고, 그 정보를 페이지 테이블로 관리
    - 페이지 테이블의 위치는 PTBR, Page Table Base Register에 설정

- 논리 주소의 물리 주소 변환
  - CP가 올린 논리 주소 (기계 명령어 내의 피ㅣ연산자 주소)는 MMU에 의해 대응되는 물리주소로 변환됨)
  - 논리주소는 프로그램의 페이지 번호와 그 페이지 내에서의 거리 Offset / Displacement
  - 물리 주소는 페이지 프레임 번호와 그 프레임 내에서의 거리로 구성됨
  - 즉, MMU는 논리주소의 페이지 번호를 해당 페이지가 적재된 페이지 프레임 번호로 대치하면 됨
  - 해당 페이지가 적재된 페이지 프레임 버번호는 페이지 테이블을 참조하여 얻어냄
  - 페이지 크기는 2^n의 크기 (512 1024 2048 4096 8192,...)

- 페이징을 위한 MMU 구조
  - MMU는 그림 7-12의 절차에 따라 논리 주소를 무리주소로 변환함
  - 페이지 크기가 2^n이므로 페이지 번호, 페이지 내 거리, 페이지 프레임 번호를 다루기가 용이함

- 성능 개선을 위한 페이징 MMU 구소
  - 페이징의 가장 큰 단점은 메모리를 접근할 때마다 페이지 테이블을 참조해야 함
  - 즉, 두 번의 메모리 참조가 일어남 → 성능이 절반으로 저하됨
  - 이를 해결하기 위해, 한 번 참조된 페이지 테이블 내용을 연관 메모리 Associative Memory 소자로 구성된 TLB, Translation Lookaside Buffer에 캐시시킴
  - TLB 검색에서 실패한 경우만 페이지 테이블을 참조
    - TLB에서 성공한 비율은 적중률 Hit Ratio 라하는 데, 적은 용량으로 90% 이상의 효과를 얻을 수 있음음

- 페이징 시스템 분석
  - 장점
    - 마지막  페이지에서의 내부 단편화 외에, 단편화에 따른 메모리 낭비가 없음
    - 페이지 크기가 클수록 마지막 페이지의 내부 단편화는 커짐
    - 논리 주소와 물리 주소가 분리되므로, 모든 프로세스가 논리 주소 공간을 공유할 수 있고, 재배치가 불필요함
    - 예를 들어, 모든 프로그램의 목적 코드가 0번지 부터 시작하더라도 대응되는 물리주소는 다름으로 전혀 문제 없음
  - 단점
    - 페이지 테이블을 위한 메모리 낭비가 존재함
    - 페이지 크기가 작으면 페이지 테이블 엔트리 수도 늘어나므로 페이지 테이블 크기도 증가함
    - 논리 주소와 물리주소 변환을 위한 성능 저하가 존재함

- 다단계 페이징 - 패스

- 페이지의 보호와 공유
  - 페이지 테이블이 보호 비트 (읽기, 쓰기, 실행 등)를 설정하여 해당 페이지 보호
  - 여러 페이지 테이블에서 동일한 페이지 프레임을 참조함으로써 여러 프로세스가 페이지 공유 가능
  - 즉, 페이지 보호와 공유가 매우 용이함

- 세그멘테이션
  - 개념
    - 전체적인 할당 및 관리방식은 페이징과 동일
    - 다만, 프로그램을 규격화된 페이지로 나누지 않고, 프로그램 이미지의 논리적인 특성에 따라 큰 덩어리 즉, 세그먼트 단위로 분리
    - 대표적인 세그먼트로 텍스트 (기계 명령어 부분), 데이터 (전역 변수 부분), 스택 (지역 변수 및 제어 스택 부분), 등이 있음
    - 각 세그먼트의 크기는 매우 다름
    - 따라서, 세그먼트 테이블은 해당 세그먼트가 적재된 시작 주소와 크기를 명시

- 세그먼테이션을 위한 MMU 구조 ~

- 세그먼트의 보호 및 공유
  - 기본적인 방법은 페이징과 동일
  - 즉, 세그먼트 테이블에 보호 비트를 설정할 수 있고, 할당된 세그먼트를 여러 프로세스가 공유 가능

@0518

- 페이지화 된 세그먼테이션 Segmentation with Paging
  - 개념
    - 패이징의 단점은 적재단위가 너무 작아 보호와 공유 관리를 위한 부담이 있음
    - 세그먼테이션의 단점은 가별 분할 방식으로 메모리 할당 정책으로 외부 단편화 발생
    - 페이지화된 세그먼테이션은, 분리된 각 세그먼트를 페이지 단위로 재구성하여 할당하고 적재함
    - → 페이징과 세그먼테이션의 장점만을 추한 방법
    - 논리 주소에서 세그먼트 주소와 페이지 번호를 도출하고, 세그먼트 테이블 및 페이지 테이블을 참고하여 물리 주소로 변환
    - 주소를 한 번 더 참조하기 때문에, 성능 저하가 한 번 더 생기는 데, 신경쓸 정도는 아니다

- 가상 메모리 관리 (VS 실, 물리, Real, Physical 메모리 관리)

- 가상 메모리의 개념
  - 가상 메모리
    - 사용자들이 실제 무리 메모리보다 훨씬 크게 사용하는 메모리
    - 프로그램 전체가 적재되어야 한다는 전체 하에서는 불가능
    - 프로그램 일부만 적재하려면, 프로그램의 분리 적재가 불가피
    - → 페이징 기법에 기반
    - 프로그램의 적재되지 않은 부분은 디스크에 존재
    - 디스크와 메모리를 오가며 필요한 부분만이 적재됨 (Swapping)

- 요구 페이징 Demand Paging
  - 요구 페이징
    - 페이징 기법의 확장으로, 페이지에 대한 참조가 일어날 때 실시간으로 적재
    - 페이지에 대한 참조 인식 및 적재는 인터럽트 메커니즘을 활용
    - 페이지 테이블에 해당 페이지의 적재 여부를 표시하고, 만약 적재되지 않는 페이지에 대한 참조가 일어나면 인터럽트 (페이지 부재 트랩, Page Fault Trap) 가 발생
    - 해당 인터럽트 핸들러에서 페이지 적재 (스왑 인, Swap in)
    - 참조가 일어나지 않은 페이지는 디스크에 저장하고 (스왑 아웃, Swap out) 할당되었던 페이지 프레임 회수

- 페이지 부재 트랩 처리 과정 (ISR, 인터럽트 서비스 루틴)
  - 페이지 참조시 부재 페이지일 경우 발생하는 인터러트의 하나
  - 페이지 프레임을 할당하고, 그 곳에 디스크에 존재하는 해당 페이지를 입력
  - 부재 페이지 처리부담으로 인한 성능 저하는 불가피

@Locality 지역성  

- 페이지 교체 Page Replacement
  - 페이지 부재 트랩이 발생하여 페이지를 적재하고자 할 때, 빈 페이지 프레임이 없다면?
  - 이미 적재된 페이지 중 적절한 것 (희생양 Victim)을 선택하여 디스크에 보관하고, 할당되었던 페이지 프레임 회수
  - 위와 같이, 적재된 페이지를 디스크로 보내고, 그 곳에 다른 페이지를 적재하는 과정을 페이지 교체라 함
  - 희생 페이지를 선정하는 과정을 성능에 영향을 미침

- 최적 OPT, Optional 페이지 교체
  - 개념
    - 교체 대상 페이지로 미래에 사용되지 않거나 가장 오랫동안 사용되지 않을 페이지를 선택
    - MIN, Minimal 페이지 교체라고도함
    - 미래를 예측하는 일은 불가능하기 때문에 구현 불가 ← 비교 대상 방법으로서의 의미

- FIFO, First in First out 페이지 교체
  - 개념
    - 적재된 지 가장 오래된 페이지를 선택하여 고체
    - 페이지별 적재 시간을 관리할 장치가 필요 (큐 혹은 타임 스탬프)
    - 벨러디 모순 (Belady's Anomaly) 현상이 나타날 수 있음

- LRU, Least Recently Used 페이지 교체
  - 개념
    - 사용 (참조)된 지 가장 오래된 페이지를 선택하여 교체
    - 오랫동안 사용되지 않았으니, 앞으로도 사용될 가능성이 낮을 것이라는 판단에 근거
    - 페이지별 참조 시간이 관리되어야 함 (스택 구조나 타임 스탬프)

@0523 낮잠자다가 못 일어나서 자체휴강  

- NUR, Not Used Recently 페이지 교체
  - 개념
    - 비교적 최근에 사용되지 않은 페이지를 교체
    - 모든 페이지들 사이의 참조 순서를 일려로 가르지 않고, 참조 된 등급과 참조되지 않은 등급으로 분류하는 방법과 같이 개략적인 참조 상황을 기반으로 페이지 들을 몇 가지 그룹으로 분류함으로써 관리 부담을 줄이면서 LRU에 가까운 효과를 얻는 방법
    - 근사 LRU, LRU Approximation 이라고 부르기도 함

@0525  

- 프로그램 지역성 Locality of Program 이론
  - 시간적 지역성 Temporal Locality
    - 장소(변수)들이 일정한 시차를 두고 반복적으로 재참조되는 현상
      - 프로그램 로직은 보통 반복(루프)으로 구성되므로 지금 참조한 기계 명령어는 머지않아 곧 다시 실행될 가능성이 높음
      - 반복 구문에서 참조되는 변수도 마찬가지
  - 공간적 지역성 Spacial Locality
    - 현재 참조되고 있는 부분의 인근 지역이 머지 않아 참조되는 현상
      - 지금 실행중인 기계 명령어 인근이나, 참조 중인 배열 원소의 인근 지역
- 스래싱을 예방하기 위해서는 시간적 지역성이나 공간적 지역성이 높은 페이지들이 메모리에 적재되어 있어야 한다
- 작업 집합은 시간적 지역성과 공간적 지역성이 높은 페이지들의 집합

- 작업 집합 관리와 페이지 부재 빈도
  - 작업 집합의 크기
    - 작업 집합 W(t, delta t)의 크기는 결국 delta t의 크기에 좌우 됨
    - delta t를 너무 크게 하면 작업 집합에 지역성이 약한 페이지가 포함될 가능성이 있음
    - delta t를 너무 작게 하면 작업 집합에 지역성이 강한 페이지가 누락될 가능성이 있음
      - delta t를 지속적으로 적절하게 관리하여야 함
  - 적절한 delta t 유지 방안
    - 해당 프로세스의 페이지 부재 빈도 PFF, Page Fault Frequency 가 기준치보다 높으면 delta t 확대
    - 해당 프로세스의 페이지 부재 빈도 PFF 가 기준치보다 낮으면 delta t 축소
  - 작업 집합관리의 예
    - delta t를 현 시점부터 과거 페이지 참조 회수로 정의
    - 최근 두 번의 페이지 참조 중 페이지 부재가 일어난 회수를 PFF로 정의
    - PFF가 1이면 적절한 것으로 정의
      - PFF > 1 이면 delta 1 증가, PFF < 1 이면 delta t를 1 감소

- 기타 논점들
  - 페이지 크기
    - 페이지 크기가 크면?
      - 페이지 테이블 엔트리 수가 감소하여 페이지 테이블 크기가 작아짐
      - 스와핑을 위한 입출력 대기 시간을 줄일  수 있음
      - 페이지 교체 및 적재의 회수가 줄어 성능 향상에 도움이 됨
      - 정보의 적중률이 낮아 짐
      - 프로그램의 마지막 페이지에서의 단편화 낭비가 증가함
  - 페이지 크기 대소에 따른 영향을 상호 배타적
  - 다차원배열 접근
    - 행 위주, 열 위주 접근
  - 함수 배치
    - 프로그램 작성 시, 자주 호출되는 함수는 가까이 배치
  - 테이블 인덱싱
    - 해싱과 같이 참조 공산을 랜덤하게 확장시키는 기법은 지역성에 약 영향을 미침
  - 프로그래밍 언어
    - 포인터를 사용하여 임의의 공간을 참조할 수 있는 언어는 지역성 유지에 불리함
    - 실시간 연결이 잦은 객체지향 언어 역시 지역성 유지에 불리
  - 입출력 버퍼 잠금
    - 입출력 데이버 버퍼
      - 입출력을 대기 중인 데이터가 보관 중인 영역이 희생 페이지로 선정되어 교체된다면 입출력이 이루어지기 전 스왑 인/스왑 아웃으로 입출력을 많이 하게됨
      - 이런 경우 해당 메모리는 교체를 예방하기 위한 잠금 장치가 필요함
      - 특시, 시스템 입출력 버퍼는 OS 내에 두어 교체를 예방하고, 사용자 데이터를 복사해 둠 Copy in/out
    - 실시간 처리
      - 가상 메모리는 페이지 교체를 위한 스왑핑 입출력으로 인해 처리 완료 시간에 대한 예측이 곤란
      - 따라서, 엄격한 실시간 시스템에서는 가상 메모리를 제공할 수 없음
