---
title: "Rendering Pipeline"
# description: ""
categories: [컴퓨터, 그래픽]
tags: []
image: "/assets/img/background/kururu-lab.jpg"
hidden: true

date: 2024-07-26. 12:23
# last_modified_at: 2024-10-16. 08:16 # Init
last_modified_at: 2025-05-28. 21:25 # +~Q
---

## Q

---

- 렌더링 파이프라인
- draw-call, set-pass가 무엇이고, 많으면 왜 느리고, 줄이려면 어떻게 해야하는가?
- 그래픽스 API 이해: OpenGL, DirectX, Vulkan 등의 그래픽스 API에 대한 깊은 이해.
- 3D 수학: 벡터, 행렬, 퀘터니언 등을 사용한 3D 변환과 관련된 수학적 이해.
- 렌더링 기술: 리얼타임 렌더링, 레이 트레이싱, 포스트 프로세싱 등의 기술에 대한 지식.
- 퍼포먼스 최적화: 그래픽스 성능을 분석하고 최적화하는 능력.
- 3d물체가 2d좌표로 렌더링 되는 과정
- cpu의 일을 gpu가 어떻게 처리하는가?
- ta -> api

## Rendering Pipeline

---

근본적으로 셰이더의 시작은 원래 '그래픽 아티스트들이 원하는 3D의 질감을 자유롭게 제어하도록 하자' 라는 것이 목표
컴퓨터 그래픽스 (Computer Graphics)
렌더링 파이프라인 (Rendering Pipeline: 더링 순서)
이것을 이해하며 셰이더의 제작 흐름을 알게 되고, 여러 가지 발생할 수 있는 문제의 해결, 최적화에도 도움이 됩니다

### 오브젝트 데이터 받아오기

GPU는 버텍스 (Vertex: 점) 로 이루어진 물체의 데이터 값을 받아옵니다.  
아직 화면에는 아무것도 존재하지 않고, 그래픽 카드 내부의 값으로만 존재하는 데이터일 뿐입니다.  
(엄밀히 말하면, 엔진으로 넘어가는 것은 버텍스 데이터 뿐이다. '면까지 생성된 모델링' 모습으로 3D 모델링 데이터가 넘어가는 것이 아니다.)  

버텍스는 인덱스 넘버 (Index number), 포지션 (Position), 노멀 (Normal), 컬러 (Color) 등의 정보를 가지고 있다.  
GPU는 버텍스의 정보들을 가지고 버텍스들이 이어진 삼각형 면을 생성하게 될 것입니다.  
오브젝트의 기본적인 형태가 갖추어졌고, 이 정보들을 버텍스 셰이더로 넘길 준비가 되었습니다.  

### 버텍스 셰이더 (정점 셰이더)

이 데이터를 가지고 본격적인 쉐이딩 작업이 가동되기 시작합니다.  
이 셰이더에서는 데이터를 가지고 좌표 변환을 하게 됩니다.  

이 때가 그래픽 아티스트들이 처음으로 셰이더를 제어하는 데이터에 접근하게 되는 것  
각종 버텍스 연산을 자유롭게 조절할 수 있게 됩니다.  

#### 2.1

버텍스의 위치 값은 현재 로컬 (Local) 좌표계 상태입니다.  
로컬 좌표계란 물체가 가지고 있는 '자기중심적인' 위치 값을 의미합니다.  
오브젝트 별로 가지고 있는 본인의 피봇이 0, 0, 0 위치 값 (중심값)인 상태입니다.  
여기에서는 게임 안에 존재할 수 있는 다른 오브젝트의 위치는 전혀 고려되지 않았습니다.  
즉 모든 오브젝트들은 자기가 세상의 중심인 상태입니다.  

현재 카메라가 없어서 그럴 일은 없겠지만, 만약 그림대로 모니터에 여러 오브젝트들이 출력된다면 마치 그림처럼 서로 한 곳에 동시 생성되어 엉킨 모습일 것입니다.
왜냐하면, 모든 오브젝트들을 자신이 세계의 중심이며, 자신이 있는 곳이 원점 (0, 0, 0)이라고 생각하기 때문입니다.  
유니티에서는 이 로컬 (Local) 좌표계를 오브젝트 (Object) 좌표계라고도 부릅니다.  

#### 2.2

이제 여기에 '월드 변환 행렬(월드 좌표계)(매트릭스: artrix)' 을 곱해줌으로써, 로컬 좌표계를 월드 좌표계로 변환해줍니다.  
월드 좌표계란, 절대 좌표인 월드 좌표계의 위치로부터 각 물체의 상대적 위치 값을 의미합니다.  
월드 좌표계에서는 실제 이 월드의 중심점이 0, 0, 0이며, 다른 물체들은 여기서 얼마나 떨어져 있는지로 표현됩니다.  

여기서 각 오브젝트들은 더 이상 자기가 세상의 중심이 아니란 것을 알게 됩니다.  
유니티에서는 이 월드 (World) 좌표계를 `모델(Model)'이라고 부릅니다.  
그렇지만 여전히 카메라가 없기 때문에 화면에 출력할 수 없는 상태입니다.  
머릿속에서만 존재한다고 생각하면 됩니다.  

#### 2.3

월드 행렬로 변화된 물체들은 이제 이 월드에 위치 값을 가지게 되었습니다.  
그러나 여기에 아직 고려되지 않은 것이 있는데, 바로 '카메라' 입니다.  
월드에 존재하는 것은 알겠지만, 카메라가 없으면 화면에 보일 수 없습니다.  
그래서 월드 좌표계의 버텍스들은 이제 다시 '카메라 행렬' 로 곱해서 월드 좌표계에서 살고 있던 오브젝트의 버테스 위치 값들이 카메라의 중심점으로부터의 상대적 거리로 다시 연산됩니다.  
즉, 이 세계에서는 카메라의 중심점이 0, 0, 0이며, 다른 물체들은 여기에서 얼마나 상대적으로 떨어져 있는지로 표현됩니다.  
드디어 물체들은 화면애 볼 수 있게 되었지만, 원근감은 고려되어 있지 않습니다.  
카메라 행렬은 '뷰 (View)'라고 불리며, 오쏘그래픽 프로젝션 (Orthographic Projection) 이라 불리기도 합니다.  
그리고 이 시점부터 모니터에 출력하는 것이 가능한 상태가 됩니다. 카메라가 있으니 말입니다.  
ㄴ(물론 출력을 위해서는 픽셀 셰이더까지 순서가 진행되어야 합니다.)  

#### 2.4

이렇게 카메라 행렬로 정렬된 버텍스들은, 다시 한번 '프로젝션 (Projection) 행렬'로 곱해집니다.  
ㄴ (이 경우는 퍼스펙티브 (Perspective) 프로젝션일 경우에 일어나는 순서이고, 오쏘그래픽 프로젝션 등의 경우에서는 일어나지 않는 순서입니다. 퍼스펙티브 프로젝션을 사용하는 것이 일반적이므로 이렇게 설명하였습니다. )  
'프로젝션 행렬' 이란 원근감을 부여해주기 위한 방법으로, 카메라에서 먼 곳은 좁혀진 것처럼 버텍스 위치를 조정해주는 것입니다.
사실상으로 카메라에서 멀수록 크기가 작아지는 물체가 되겠지요.  
그리고 드디어 우리가 흔히 볼 수 있는 뷰의 모습이 되었습니다.  

#### 2.FIN

여기까지의 작업을 그대로 모니터에 출력한다면 여전히 텍스쳐도 음영도 없는, 말 그대로의 폴리곤 덩어리가 생성됩니다.
화면에 찍힐 수 있는 준비는 되었지만, 이 오브젝트는 아직 픽셀 셰이더를 거치지 않았기 때문에 결과적으로 우리가 모니터로 볼 수도 없는 단지 3D 공간에서 존재하는 오브젝트일 뿐입니다.
ㄴ [물론, 이 버텍스 셰이더 단계에서 라이트 (Light: 명)를 연산하면 '버텍스 라이트' 라는 매우 가볍고 부정확한 라이트가 연산될 수 있긴 합니다. 이 기법 중 가장 유명한 것은 고라우드 쉐이딩 (Gouraud Shading) 이라는 것이 있으며 결과물은 44p 그림과 같습니다.]

### 래스트라이져 (Rasterizer)

ㄴ [최근 Direct-X에서는 여기에 여러 가지의 셰이더가 추가로 들어갑니다. 버텍스 셰이더와 픽셀 셰이더의 중간에 위치하는 이 셰이더는 헐 셰이더 (Hull Shader), 테셸레이터 (Tessellator), 도메인 셰이더 (Domain Shader), 지오메트리 셰이더 (Geometry Shader), 컴퓨트 셰이더 (Compute Shader) 등이 있습니다. 하지만 이 책은 아티스트를 위한 책이므로, 일단 다이렉트X 9 정도의 기초적인 수준으로 다루었습니다.]
어쨌든 우리는 이렇게 좌표계가 조정된 버텍스를 이용해서 화면에 오브젝트를 출력할 준비가 되었습니다.
이번에는 모니터에 이 오브젝트를 출력해줄 것입니다.
그래서 이 오브젝터가 모니터에서 표현될 때 어는 픽셀로 표현될 것인지를 나타내는 장치를 거치게 되는데 이걸을 래스터라이져(Rasterizer)라 부르며, 2D 픽셀로 표현되는 세계로 넘어오게 됩니다.

이제 3D 오브젝트는 모니터에 보이도록 '픽셀(Pixel)'이 되었고 이 과정을 '래스터화'라고 합니다.
3D로 있던 '석고상'을 촬영하는 순간 그 석고상은 2D 이미지가 되듯이, 3D 이미지가 2D 이미지가 되는 순간입니다.
모니터에 보이려면 2D 이미지로 만들어야 하니 말입니다.
ㄴ ( 이 모든 작업이 매 프레임마다 일어나는 것입니다, )

이렇게 수학적인 가상 공간 안에서 입체로 떠돌던 오브젝트는 픽셀이 되고, 드디어 픽셀셰이더에서 이 픽셀에 접근할 수 있게 되었습니다.

### 픽셀셰이더 (Pixel Shader) / 프레그먼트 셰이더 (Fragment Shader)

이렇게 모니터까지 넘어온 3D 그래픽 데이터는 본격적으로 화면에 픽셀로 찍히게 됩니다.
물론 아직 텍스쳐도 없고 라이팅도 없는 상태입니다.
ㄴ (버텍스 쉐이터 단계에서 라이팅을 연산하지 않았다면 말입니다.)
이제 여기에서 픽셀셰이더가 가동되면서 조명과 텍스쳐, 그림자와 각종 특수효과 등을 연산하게 되는 것입니다.

그러므로 이 프로세스를 아우 간략하게 정리해 보면 다음과 같습니다.
물론 실제 렌더링 프로세스가 이렇게 간략하진 않습니다만, 그래픽 아티스트 입장에서는 우선 여기까지만 알아두어도 큰 도움이 될 것입니다.
정점 데이터 => [GPU (버텍스 셰이더 - 정점 좌표 변환) = 정점위치 > (레스터라이저) = 픽셀 위치 > (픽셀 셰이더 - 픽셀 색상결정)] => 픽셀 색상=

---

다렉에서 렌더링 파이프라인 공부가  
로컬 뷰 - 월드 뷰 - 카메라 뷰 전환 과정?

그림자 만들기?

셰이더에서 정점이나 픽셀 계산. ex: 정점 셰이더에서 모델 어떻게 만들고, 화면에 띄우기 전에 픽셀마다 깊이 같은거 새겨서 노멀 맵핑 하는거.

대충 이런 것들 이해하면 렌더링 파이프 라인 얼추 이해했다고 생각하면 됨?

네 좌표계가 계속 변하는데 그 명칭들이랑 수행하는 작업들 알면될꺼같아요
동차좌표계랑 퍼스펙티브 디바이드전후 xyzw값이 뭔지 아는게 중요한듯

- [https://techartnomad.tistory.com/281](https://techartnomad.tistory.com/281)
- [https://gall.dcinside.com/mgallery/board/view/?id=gamejob&no=29237&exception_mode=recommend&page=1](https://gall.dcinside.com/mgallery/board/view/?id=gamejob&no=29237&exception_mode=recommend&page=1)
