---
title: "🌑 알고리듬 과목"
date: 2023-09-07. 10:29
# last_modified_at: 2023-09-07. 10:29
# last_modified_at: 2023-09-12. 13:31
# last_modified_at: 2023-09-14. 10:30
# last_modified_at: 2023-09-19. 13:37
# last_modified_at: 2023-09-21. 10:24
# last_modified_at: 2023-09-26. 13:33
# last_modified_at: 2023-10-05. 10:32
# last_modified_at: 2023-10-10. 13:32
# last_modified_at: 2023-10-17. 13:30 ?
last_modified_at: 2023-10-19. 10:38
categories: ⭐Computer 🌑Computer-General
---

### 💫 2차시

---

알고리듬  
미리/이미 만들어진 문제 풀이  
범용적 절차/명령어 집합  

- 조건
  - I/O
  - 각 명령어의 명확성(분명, !모호)
  - 각 명령어의 유효성(컴퓨터 실행 가능)
  - 알고리듬의 유한성(시작-끝, 현실적인 실행 시간)
  - 정확성(해답)

표현  
자연어, 의사(Pseudo) 코드, 흐름도/순서도, 코드  

[유클리드 호제법](https://mascari4615.github.io/posts/Euclidean-Algorithm/)  

### 💫 3차시

---

성능 평가, F Evaluation

알고리즘에서, 실행 시간과 메모리 공간 (동일한 목적, 결과 정확을 가정)  

일반적인 상황에서 실행 시간이 더 우선 (임베디드 등을 제외하고)  
메모리가 넉넉해져서  

- 같은 문제, 다른 성능
  - 다항식 계산 : 각 항 계산 < 호너의 규칙
  - 1~n 정수 합 : for 계산 < 등차수열의 합 공식
  - 정의역 밖 요소 탐색 : 순차탐색 < 순차탐색(정렬, Invalid 값 미리 처리) < 이진탐색

- 실행 시간 측정
  - 컴퓨터 스펙
  - 언어, 컴파일러, 프로그래밍 스타일/코딩 표준
  - 실행 시 마다 다른 시간
  - 가능한 모든 입력, 정확한 결과 (!근사)

측정은 문제가 많음  
-> 복잡도 분석  

- 복잡도 분석 (시간 복잡도, 공간 복잡도)

- 시간 복잡도
  - 측정 없이 불가능
  - 대안 : 간접적 지표

시간 복잡도 기준  

1. 연산 실행 횟수
   - 입력 N에 대해, T(N) 함수 관계, 그래프
2. 명령문 실행 횟수
   - 큰 알고리듬에서 연산 실행 횟수 계산 어려움
3. 기준 연산 실행 횟수
   - 기준 연산이 명확하지 않으면 어려움

### 💫 4차시

---

점근 분석, Asymptotic Analysis  
= 복잡도 함수를 '단순한' 근사 함수(무한으로 가면 비슷한 꼴)로  
-> 최고 차항을 계수를 1로 하여 추출  

계수, 나머지 항 생략해도 되나?  
-> 무한으로 갈수록, 식에서 최고 차항 비율은 겁나 커진다  
-> 무한으로 갈수록, 계수 \< 지수  

복잡도 등급 - 입력 크기(n) 비례 복잡도(결과, 처리시간) 증가  
-> 상수, 로그, 선형, 선형로그, n차, 지수, 팩토리얼, ...  

@ 정렬 - 선형로그  
@ 제곱 - 행렬 합  
@ 세제곱 - 행렬 곱  

@ msps - 초당 백만번 연산  
@ 단순 연산(비트 연산 등)과 상대적 복잡 연산과의 괴리  
@ flops - 초당 부동소수점 연산  

점근 표기법  

Big O, Big Θ, Big Ω  
@ 소문자와 구별되기에, Big 붙여야  

Big O, 점근적 상한  
아무리 많아도 이정도 걸린다  

I.E.  
-> T(n) = 2x + 4 일때, O(3x)  
-> 5n^2 + 3n - 10 = O(n^3)  
-> 5n^2 + 3n - 10 = O(n^2)  
-> 5n^2 + 3n - 10 != O(n)  

When  
-> 입력 데이터에 따라 증가율이 달라지는 경우  
-> 정확한 복잡도는 모르고, 상한은 아는 경우  
-> 관례적 (그냥 많이 써서)  

상한의 불확실성 (빡빡한 상한, 느슨한 상한)  
-> 정의를 만족하는 가장 낮은 차수를 사용하는 것이 원칙  

@ =은 equal, is가 아니라 포함되어 있다 라는 의미  

Big Ω, 점근적 하한  
최소한 이정도 걸린다  

I.E.  
-> T(n) = 2x + 4 일때, Ω(n)  

When  
-> 입력 데이터에 따라 증가율이 달라지는 경우  
-> 정확한 복잡도는 모르고, 하한은 아는 경우  
-> 다른 점근 표기법 보완 (보통 혼자 쓰지 않음)  

### 💫 5차시

---

f(n) = O(g(n)) \<=> g(n) = Ω(f(n))  

Big Θ, 점근적 상한과 하한이 일치  
대략 이정도다  

I.E.  
-> T(n) = 2x + 4 일때, Θ(n)  

When  
-> 정학한 복잡도 함수를 아는 경우  

복잡도 - O, Ω  
(~한 경우) 복잡도 - Θ  

동일한 기능의 알고리즘 비교  
A = O(n^2), B = O(n^3)  

A가 B보다 빠르다 X  
A가 B보다 점근적으로 빠르다 O  

n의 값이 고려되어야 한다  
I.E. A = 10^5 * n^2, B = n^3, n \< 10^5 라면 A < B  
n이 작으면 시간 차이 별로 없거나, 오히려 점근 복잡도가 낮은 알고리즘이 더 느릴 수 있다  

점근 복잡도는 수학과 공학의 절묘한 균형을 요구  
@ TODO : 공학 ?  

점근 복잡도 쉽게 구하기  

1. n에 따라, 순차적인 명령문(블록)은 점근 복잡도 함수를 더한다
2. n에 따라, 중첩된 명령문(블록)은 점근 복잡도 함수를 곱한다
3. 부프로그램(함수)도 점근 복잡도를 반영

최악, 최선, 평균 복잡도  

n 같더라도 집합-순서에 따라 실행 시간 달라지는 알고리즘  
Big O 점근석 상한 만을 나타내기도  

최선 \<= 평균 \<= 최악 복잡도  
최악과 최선 복잡도가 같다면, 평균적인 경우도 같고, 이는 Θ 표기법으로  

평균 복잡도  
최악에 가까운, 버블 정렬, 삽입 정렬  
최선에 가까운, 퀵 정렬  

의미 차이  

최악의 경우 Θ(n^2)  
-> 최악의 경우 n^2가 걸린다  
최악의 경우 O(n^2)  
-> 최악의 경우, 정확하게는 모르겠지만 그 상한이 n^2이다  

최악의 경우, 최선의 경우, 평균적인 경우 Θ(~)  
== O(~), Ω(~)  

### 💫 6차시

---

최적해  
최고 좋은 해답  

부문제  
원래의 문제와 똑같은 성질을 가지면서 단지 크기만 작은 문제  

Greedy  
지금 최적해 선택  
지금만을 생각하므로 비교적 구현 쉬움  
취소/변경 X -> 비교적 빠름  
오래 걸린다면 근사 알고리듬  

- 조건 (1 && 2 && 3)
  - 최적화 문제 Optimization Problem
    - 최적해 문제 (가장 가까운 길, 최소 비용 신장 트리, ...)
  - 최적 부분구조 Optimal Substructure
    - 문제의 최적해, 부문제들의 최적해보루터 효율적으로 생성
  - 최적 선택
    - 각 단계 선택이 최적임을 수학적 귀납법으로 증명

1. 선택 작업
   - 현 상태에서 최적해에 포함시킬 대안을 선택
2. 타당성 조사
   - 선택된 해가 주어진 문제의 조건을 만족하는지 검사
3. 해답 조사
   - 원래의 문제가 해결되었는지를 검사

동전 거스름돈 문제  
큰 액면 동전부터 차례로 선택하여 남은 거스름돈 액수보다 작을 경우 해답에 포함시켜 나가면 된다  

항상 최적해를 구할 수 있는가? X  
150; 130, 10, 10 \< 100, 50  

최적 부분구조를 갖는가?  

@ TODO : 푹 졸았다. 다시 공부.  

최소 신장 트리  

### 💫 7차시

---

크로스컬 알고리듬  
최소 신장 트리을 구하는, 그리드 알고리듬의 일종  

1. 선택 작업
   - 최소값 찾기 알고리듬을 여러 번 실행 (x)
   - 미리 모든 간선을 가중치에 따라 정렬
     - I.E.
     - a-b 1, a-d 2, b-d 2, b-c 3, c-d 4
   - 최소 가중치 간선 선택
2. 타당성 조사
   - 선택한 간선 때문에 사이클이 만들어진다면 선택한 간선을 버림
     - 깊이 우선 탐색 DFS을 이용 (x)
     - 배타적/서로소 집합 (Disjoint Set)의 개념을 이용하는 Union-Find 연산

받아들여진 간선의 수가 n-1개가 되면 종료  
-> n개의 트리로 구성된 프로시트에서 출발하여 최종 1개의 트리를 생성  

Union-find  
Disjoint Set 서로소 집합을 표현하는 자료구조  

Union  
서로 다른 두 집합을 병합  

Find  
집합 원소가 어떤 집합에 속해있는지  

어떤 정렬 알고리듬을 쓰냐가 시간에 영향을  

@ TODO : 또 졸았다. 다시 공부.  

### 💫 8차시

---

프림 알고리듬  
최소 신장 트리을 구하는, 그리드 알고리듬의 일종  

- 아무 정점에서 시작 트리 초기화
- 매 단계 + (1 간선, 1 정점) 하며 트리 유지
- MST가 아닌 모든 정점과 간선에 대해, 가중치가 낮은 간선부터 선택
- 모든 정점 선택 (= n-1개 간선 선택) 시 종료

타당성 (사이클 존재 여부) 조사 X  
MST 아닌 (선태되지 않은) 정점만 선택하기 때문  

행렬 or 인접/연결 리스트, 배열 or 우선 순위 큐 or 최소 힙

### 💫 N차시

---

단일 시작점 최단 경로  
다익스트라 알고리듬  

허프만 코딩  
무손실 압축에 쓰이는 엔트로피 부호화 방법  

@ 중간고사 3장 끝나면  
@ 11월 첫 주 화요일 예정  

TSP  

NP-Complete 완전 문제  
~ 아무튼 오래 걸리는 문제  
-> 특별한 값 제외하고 처리  
-> 최적해와 근사한 값  

@ Theory of Computation 계산 이론에서 주로 하는 이야기  

70~80년 전  
수학 문제를 어떻게 해결할 것인가?  

정형화된 문제  
풀 수 있는 문제와 없는 문제  

@ TM : Turing Machine  

Tracktable  
Intracktable 아무리 빨리 풀어도  

Polynomial Time 다항식 시간 :  
O(n^k)  (상수, 로그, 지수 함수를 포함)  
n^3 정도만 되어도 복잡하긴한데, 이론적으로는  

P Class : 풀기 쉬운 문제, 다항식 시간 내에 풀 수 있는 문제  
Polynomial Time Class  
결정적 TM 을 이용해 다항식 시간 내에 풀 수 있는 문제  

NP Class :  
NonPolynomial Time Class  
비결정적 TM 을 이용해 다항식 시간 내에 풀 수 있는 문제  
병렬처리 할 수 있는 문제, 컴퓨터 마다 다른 처리할 수 있게 하는 문제  
다항식 시간 내에 해답을 검증할 수 있는 문제 (누군가 낸 해답을 맞는 지 없는 지 검증할 수 있는)  

P 이면 NP 일것이라고 강한 추측  
~ 시간 내에 풀 수 있으면, ~ 시간 냉 검증할 수 있을 것이라는  
P 가 NP 의 부분집합  
@ 아닌 사례를 아직 발견한 적 없지만, 수학적으로 증명되지는 않은  

NP 중에 P 가 아닌 애들 중, NP-Complete 라는 문제가 있음  
NP-Complete 문제들 중 어느 하나라도 P 로 풀리는 문제가 있다면,  
그 문제는 전부 P 로 풀리는 문제인 집단  

A 문제 -> B 문제 -> C 문제 ... Reduce  
~ 시간 내에 축약(= 치환) 될 수 있음  

C 문제가 P 로 풀린다면, A, B 문제도 P로 풀림  
~ 시간 * 상수 = ~ 시간 내에 축약(= 치환) 되기에  

TSP  
Traveling Salesman Problem  
여행하는 외판원(세일즈맨) 문제  

모든 도시 한 번씩 방문하고 돌아오는 최단 경로  

TSP 조건  

1. 대칭성 : 두 도시 사이 간 거리 양방향으로 동일 -> 방향성이 없는 가중치 그래프
2. Triangle Inequality 삼각 부등식 만족 : 삼각형으로 위치한 세 도시를 잇는 도로 가운데 두 도로의 길이의 합은 다른 한 도로의 길이보다 같거나 길다는 것
3. 완전 그래프 : 모든 도시들 간에 반드시 도로가 존재

Brute Force => O(n!) 중 가장 작은  
동적 계획법 => O(n^2 * 2^n)  

근사 알고리듬  
Nearest Neighbor Algorithm 최근접 이웃 알고리듬  
안 간 곳 중에 가장 가까운 곳 부터  

구현 쉬움, 나름 짧은 경로를 짧은 시간에  
완전 그래프가 아니라면 경로가 존재해도 못 찾는 경우가  

근사 알고리듬  
MST 이용 알고리듬  

기본 아이디어  
MST는 연결되어 있음, 상대적으로 낮은 가중치를 갖는 간선들로 구성  
-> TSP의 최적해에 가까울 수도  
But, MST는 선형 구조가 아니므로, 차례로 방문 못하는 경우가  
-> SO, MST로부터 선형순서를 만듦 (DFS, 삼각 부등식 이용)  
-> -> 1213 방문이라면, 정점 2 1 3 은 삼각 부등식을 만족하므로 돌아갈 필요 없이 정점 2에서 3으로 바로 방문  

방법  
MST 구하고  
S 출발점으로 부터 DFS 실행  
방문 순서에서 두 번 이상 중복 방문되는 정점 제거 (마지막 방문 출발점 제외)  

근사해 <= ~ < MST 가중치 < 최적해  
MST 가중치 + 1 간선 = Cycle (최적해)  

### 💫 N+1차시

---

@ Deduce 연역 : 추론  
@ Induce 귀납 : 유도, 돌려서 말함 -> 사례 -> 확률 (<= 100%)  
@ Induction 인덕션 : 자기장 `유도` 를 통해 열 생성  
@ 수학적 귀납법 : 100%  

분할 정복  

REVIEW  

Iteration 반복  
N번 or 조건 만족까지 반복  

Recursion 순환  
스스로 호출하여 문제 해결  
순환적 특징 갖는 문제 or 순환적 데이터 구조 (Like Tree)를 다루는 프로그램에 대해  
밀접한 연관 : Inductive Definition 수학의 귀납적 정의, Recurrence Relation 점화식  
함수 호출(시스템 스택)으로 인해 반복보다 느림  
대부분 동일 기능의 반복 구조로 변환 가능  

귀납적 정의  

팩토리얼 n!  
기본조항 f(0) = 1  
귀납조항 f(n) = n * f(n-1), n >= 1

자연수 n  
기본조항 n ∈ N  
귀납조항 (n-1) ∈ N 이면, n ∈ N, n >= 2  

피보나치 수열 fib(n)  
0, n = 0  
1, n = 1  
fib(n-1) + fib(n-2), n >= 2  

중복작업  
I.E. f(3) 의 중복 계산  
f(5) = f(4) + `f(3)`  
f(4) = `f(3)` + f(2)  

순환호출  
-> 호출 시 비용  
-> 중복 실행  

분할정복  

Divide 문제를 부문제로 분할 (어디까지 어떻게 몇 개로 나눌지는 재량)  
Conquer 재귀적으로 해결  
Combine 결합 (필요하다면)  

마스터정리  
a = 부문제 수, n/b = 부문제 크기, O(n^c) = 분할 결합 시간  
a = b^c : T(n) = O(n^c log n)  
a \> b^c : T(n) = O(n^d), d = log<sub>b</sub> a  
a \< b^c : T(n) = O(n^c)  

이진탐색  
나누고 하나만 씀, 부문제 1개 = 결합 X  
a = 1, b = 2, c = 0  
a = b^c, T(n) = O(n^c log n) = O(log n)  
순환호출 트리의 높이 log<sub>2</sub>n에 비례  

최대값 찾기  
Like 이진탐색, 토너먼트 방식  
배열을 반으로 나눠 각 최대값 구하고, 더 큰 값을 최대값으로  
a = 2, b = 2, c = 0  
a \> b^c, T() = O(n^d), d = log<sub>b</sub>a = 1 = θ(n)  

거듭제곱 power(x, n)  

IN 순환 알고리듬  
1, n = 0  
x * power(x, n-1), n >= 1  

IN 분할정복 알고리듬  
1, n = 0  
power(x^2, n/2), n != odd  
x * power(x^2, (n-1)/2), n = odd  
a = 1, b = 2, c = 0  
a = b^c, T(n) = θ(n^c log n) = θ(log n)  

감소 정복?  
이진탐색인 거듭제곱 처럼 부문제를 만들때 크기를 줄이는  
