---
title: "🌑 프로그래밍 언어 - Primitive Data Type"
date: 2023-11-24. 09:20
#last_modified_at: 2023-12-01. 10:20
last_modified_at: 2023-12-08. 08:58
categories: ⭐Computer 🌑Computer-General
tags: Programming-Language Data-Type
---

## 💫 기본 데이터 타입 - Primitive Data Type

---

프로그래밍 언어에서 기본적으로 제공하는 타입  
다른 타입으로 정의되지 않는 타입  

- 프로그래밍 언어는 기본 데이터 타입을 제공
  - 하드웨어 반영 기본 데이터 타입: 정수(int), 실수(float)
  - 약간의 비하드웨어적 지원을 받는 기본 데이터 타입도 있을 수 있음

기본 데이터 타입은 구조화된 데이터 타입(배열, 구조체 등)을 제공하기 위해 활용  

## 💫 수치 타입

---

초기의 프로그래밍 언어들은 수치 기본 타입만 제공  
오늘날 프로그래밍 언어에서도 수치 타입은 기본적으로 제공됨  

### 🫧 정수

- 가장 공통적으로 제공되는 수치형 기본 데이터 타입
- 현대의 컴퓨터는 다양한 크기의 정수 타입을 지원하고 프로그래밍 언어 또한 이를 반영하여 지원
  - Java는 4가지 크기의 부호 정수를 지원: byte, short, int, long
  - C/C++은 부호화 비부호화 정수를 지원: int, unsigned int, short, unsigned short 등
- 하드웨어에의해 직접 지원되지 않는 정수 타입 (비하드웨어적 지원을 받는 정수 타입)
  - Python의 경우 길이에 제약이 없는 정수 타입을 제공
- 음의 정수 표현
  - 부호-크기 표기법
    - 부호 비트가 0이면 양수, 1이면 음수
    - 크기는 절대값을 표현
    - 문제점: 산술 연산을 위한 컴퓨터 하드웨어 제작이 매우 어렵다
  - 2의 보수 표기법
    - 음수를 표현하는데 2의 보수 표기법 사용
    - 산술 연산을 위한 컴퓨터 하드웨어 제작이 아주 쉽다
    - 1의 보수를 만든 후 1을 더해줘서 2의 보수를 쉽게 생성 가능

### 🫧 부동 소수점 수

- 실수 값을 표현 함 하지만 대부분 실수 값에 대한 근사값 임
- 산술연산 시에 정확도를 상실한다는 문제점이 있음
- 과거에는 컴퓨터마다 부동 소수점을 표현하는 방식이 달랐으나, IEEE에서 부동 소수점 표현을 표준화 함 -> IEEE 754
  - 단정도(Single precision) -> float, 배정도(Double precision) -> double
- @ PIC 0001, 0002

### 🫧 복소수

- Python, 복소수와 복소수 연산을 지원
- Python의 복소수 표현에서 허수부는 j 혹은 J로 표현현
  - 3+4j 혹은 3+4J

```py
>>> (5 + 2j) + (7 + 2j)
(12 + 4j)
>>> (5 + 2j) * (7 + 2j)
(31 + 24j)
```

### 🫧 십진수 데이터 타입

@ PIC 0003

- 십진수 데이터 타입은 고정된 개수의 십진수 데이터를 저장, 소수점은 고정된 위치를 가짐
  - 제한된 범위에 포함된 십진수 값들을 정확하게 저장 할 수 있음
    - 사무용 데이터 처리를 위한 기본적인 데이터 타입
      - COBOL에 필수, C#, SQL 등 지원
      - Python 등 많은 프로그래밍 언어에서 라이브러리로 제공
  - 컴퓨터의 십진수 표현(BCD: Binary Coded Decimal) 지원 여부
    - 사무 시스템 응용 분야를 지원하기 위해 설계된 큰 규모의 대부분의 컴퓨터에서 십진수 데이터 타입을 위한 하드웨어 지원을 포함
    - Intel CPU의 경우 제한적 지원
    - 하드웨어적으로 BCD처리가 지원되는 경우 하드웨어적으로 처리 그렇지 않으면 소프트웨어 적으로 처리(에뮬레이팅) 함

```py
>>> from decimal import Decimal
>>>  0.1 + 0.2
0.30000000000000004
>>> Decimal(‘0.1’) + Decimal(‘0.2’)
Decimal(‘0.3’)
```

### 🫧 불리안 타입

- 참과 거짓을 표현하는 가장 단순한 타입
  - ALGOL 60에서 처음 도입된 후 1960년 이후에 설계된 대부분의 언어에서 포함
    - 예외 C89
      - 수치식이 조건식으로 사용되는 것 허용
        - 0이아닌 모든 값은 참, 0은 거짓
    - C99와 C++은 불리안 타입 제공
      - 수치식이 불리안 식처럼 사용되는 것을 허용
    - Java, C#등 대부분의 언어에서 수치식을 불리안 타입으로 사용하는 것을 허용하지 않음
  - 스위치나 플래그를 표현하는데 사용
    - 정수와 같은 타른 타입이 이런 목적으로 사용될 수 있지만 가독성 측면에서 불리안 타입을 사용할 것
  - 한 비트로 구현이 가능하나 컴퓨터에서의 최소한의 접근 단위 때문에 한 바이트로 구현

### 🫧 문자 타입

- 문자 데이터는 수치 코딩으로 컴퓨터에 저장
  - ASCII: 가장 공통적으로 사용되는 코딩
    - C에서 char 타입은 ASCII 코드를 저장
  - ISO 8859-1: 8비트 문자 코딩 기법으로 256개의 문자를 제공
  - Unicode: 세상에 존재하는 대부분의 자연 언어에 속한 문자를 표현
    - Java, JavaScript, Python, C# 등에 채용
  - 대부분의 언어에서 단일 문자를 위한 타입 Char 제공
    - Python, 단일문자를 길이 1 문자열로 표현

### 🫧 문자열 타입

아래에서 계속.  

## 💫 문자열 (Char String) 타입

---

- 일련의 문자들로 구성되는 타입
- 문자열 상수는 출력에 레이블을 부여하기 위해 사용되며, 모든 유형의 데이터인 입력과 출력은 흔히 문자열 관점에서 이루어짐
  - 문자열은 문자 조작을 하는 모든 프로그램에 대해서 필수적인 타입임
    - C, C++, Java, JavaScript, Python 등 대부분의 프로그래밍의 언어에서 제공
  - 설계 고려사항
    - 문자열이 단순히 문자 배열의 특수한 유형인가 혹은 기본 타입인가?
    - 문자열이 정적 길이 혹은 동적 길이를 갖는가?

### 🫧 문자열과 연산

- 가장 공통적인 문자열 연산
  - 배정, 접합, 부분 문자열 참조, 비교, 그리고 패턴 매칭 등
- 배정, 비교의 고려사항
  - 길이가 다른 문자열간 배정과 비교는 어떻게 처리할 것인가?
- 부분 문자열 참조(Substring reference)
  - 주어진 문자열의 부분 문자열에 대한 참조 -> 슬라이스(Slices)

- in c/cpp
  - C/C++에서는 char 배열을 이용하여 문자열 저장
    - 문자열은 반드시 문자 '\0'으로 끝나야 함
      - C/C++에서의 문자열 타입은 길이를 따로이 저장하지 않고 '\0'로 끝을 표시
    - 문자열 리터럴의 경우 컴파일러가 자동으로 '\0'을 첨가
      - i.e. char str[] = "apples";
  - 표준라이브러리를 통해 문자열 연산을 제공
    - 문자열 연산 함수는 '\0'을 만날때까지 해당 연산을 수행
      - 문자열 복사: strcpy
      - 문자열 연결: strcat
      - 문자열 비교: strcmp
      - 문자열 길이: strlen

```cpp
char temp[4] = ['T', 'e', 'm', 'p'];
char temp[5] = ['T', 'e', 'm', 'p', '\0'];
char temp[5] = "Temp"; // 컴파일러가 끝에 \0 추가

// Data 영역에 ReadOnly로 "Temp"가 저장되고, Stack에서 temp 변수가 "Temp"를 가리킴
char* temp = "Temp"; // 주소 크기
char temp[] = "Temp"; // 문자 수 만큼

// malloc, Heap에 만들기

char a[10];
char b[6] = "Hello";
char c = "Hello World";
strcpy(a, c);
printf("%s\n", b); // "d" 출력
```

Stack에는 무조건 참조만  
Heap에 개체가 만들어지는 것  

- 각 언어별 문자열과 연산
  - C
    - 표준라이브러리의 문자열 조작 함수가 안전하지 않음
      - 목적지 문자열에서 오버플로우가 발생하는 것을 보호하지 않음
        - i.e. strcpy(dest, src) : src가 dest보다 길이가 긴경우 오버플로우가 발생
  - C++
    - 표준 클래스 라이브러리를 통해서 문자열(string) 지원
      - C 문자열 라이브러리의 불안정성을 보완하기위해 가급적 string을 사용 권고
  - Java
    - String 클래스와 StringBuffer 클래스에서 지원
      - String 클래스 객체는 Immutable, StringBuffer 클래스 객체는 Mutable
  - C#과 Ruby의 문자열은 Java와 비슷
  - Python
    - 문자열을 기본 타입으로 제공하며 Immutable 하다.
    - 탐색, 대체, 부분 문자열 참조, 접합, 개개 문자 접근 등의 연산 제공
  - JavaScript, PHP, Perl, Ruby
    - 문자열을 기본 타입으로 제공하며 Immutable 하다.
    - 내장된 패턴 매칭 연산(정규식, regular expression)을 제공

### 🫧 문자열 길이 선택사항

- 정적 길이 문자열
  - 문자열 길이는 정적이고 문자열이 생성될 때 설정
    - Python, Java의 내장 문자열, C++의 클래스 라이브러리 내 string 타입
- 제한된 동적 길이 문자열
  - 변수 정의에 선언되고 고정된 최대 길이까지의 가변적인 길이를 갖는 것을 허용
    - C의 문자열, C++에서 사용하는 C 스타일 문자열
- 동적 길이 문자열
  - 문자열이 최대 길이 제한없이 가변길이를 갖는 것을 허용
    - JavaScript, Perl에서의 문자열
    - 동적 기억장소의 할당과 해제로 성능에 부담이 있으나 최고의 유연성을 제공
    - 웹 데이터는 대부분 문자열이다 보니 많이 쓰여서

### 🫧 평가

- 문자열 타입은 언어의 작성력에 중요한 영향을 미침
- C 스타일의 문자열 지원 방식의 부자연스러움
  - C에서는 문자열이 기본 데이터 타입이 아니고 문자 배열로 처리
    - 만약 strcpy가 제공되지 않는다면 문자열의 단순 배정도 루프를 사용해야 함
- 문자열을 기본 타입에 포함시키는 것의 비용이 많지 않음
  - 따라서 오늘날 대부분의 언어에서 문자열을 기본 데이터타입으로 포함
  - 단순 문자열 비교나 문자열 접합 연산이 기본 제공

### 🫧 문자열 타입의 구현

- 문자열 타입을 하드웨어로 직접 지원할 수 있지만 대부분 문자열 기억공간, 검색, 조작을 구현하기 위해 소프트웨어적으로 접근
- 문자열이 문자 배열로 표현될 때 (C의 경우) 언어에서 문자열 연산을 거의 제공하지 않음 -> 라이브러리로 제공

## 💫 레코드 타입

---

- 각 요소들이 이름으로 식별
- 구조의 시작부터 오프셋을 통해 접근
  - 개개의 원소들이 동일한 타입이나 크기가 아닌 데이터의 모임을 모델링 할 때 빈번하게 사용

@ ? Java 구조체 따로 없는데?  
@ TODO : Java 메모리 구조  
  class loading (code + data)  
  stack  
  heap (managed by JVM GC)  

### 🫧 평가_레코드 타입

설계는 간단하며 사용은 안전하다.  

- vs 배열
  - 레코드는 이질적인 데이터를 허용
  - 레코드의 요소는 필드로 접근 (색인 X)
  - 순서를 고려할 필요가 없음

## 💫 튜플

---

- 레코드 타입과 비슷하나 요소들을 이름으로 명명하지는 않음
  - 레코드 타입처럼 요소들이 이질적인 타입으로 구성 가능
- Python은 immutable한 튜플 타입을 기본 데이터 타입으로 제공
  - 이질적인 요소를 허용하며 요소에 접근시에는 첨자로 접근
- 튜플은 함수가 여러개의 값을 반환하는 것을 허용하기 위해

@ TODO : Python 괄호 종류에 따른 컨테이너 종류  

## 💫 리스트

---

- C#, Java : 표준라이브러리, List, ArrayList

- Python : 기본 데이터 타입
  - [ ] 대괄호
  - mutable (튜플은 immutable)
  - 요소 삭제 del temp[1]

- Python List Comprehension
  - 리스트를 생성하기 위한 매커니즘으로 집합 표기법에 기반
    - [식 for 요소 in 배열 if 조건]
    - i.e. [x * x for x in range(12) if x % 3 == 0]
  - 슬라이스 연산도 제공

## 💫 공용체(Union) 타입

---

```c
union FlexType
{
	int intE1;
	float floatE1;
};

union FlexType el1;
float x;

// ...

eli.intE1 = 27;
x = eli.floatE1;
```

- C/C++는 타입 검사에 대한 언어 지원이 없는 자유 공용체 구조를 제공
  - C/C++에서 union 키워드는 union 구조체를 명세하는데 사용
  - i.e. el1.floatE1을 x에 배정, 이때 타입 검사를 하지 않음
  - 왜 쓰냐? Low-level 시스템 프로그래밍에 공용체를 사용 (임베디드 시스템/네트워크)

- 변수가 프로그램 실행 중에 다른 시기에 다른 타입의 값을 저장할 수 있는 타입
- 설계 고려사항
  - 타입 검사가 요구되는가?
  - 공용체가 레코드에 포함될 수 있는가?
- 판별 공용체와 자유 공용체
  - 자유 공용체: 타입 검사에 대한 언어 지원이 없는 형태의 공용체: C/C++
  - 판별 공용체: 공용체 구조에 타입 지시자(판별자)가 포함되어있어서 이를 이용하여 타입 검사를 수행하는 공용체

- 평가
  - 강타입 언어가 아닌 경우, 공용체는 안전성에 문제가 생길 수 있음
    - C/C++ 은 강타입 아님
    - Java/C#은 공용체가 없음

- vs 구조체
  - 구조체와 같은 문법
  - 구조체는 각 요소가 각자의 메모리 공간을 가짐
  - 공용체는 모든 요소가 하나의 메모리 공간을 공유
    - 요소들 중 가장 큰 요소 크기 만한 메모리 공간
  - 공유하는 똑같은 메모리 공간을 어떤 타입으로 접근하냐 - 어떤 모드로 접근할거냐

- 왜 씀?
  - 메모리 절약
  - 현대에는 메모리 널널해져서 구조체 쓰기 공용체는 잘 안쓰는 듯?

## 💫 포인터 타입

---

- 포인터 변수는 메모리 주소와 특수값 NULL(NIL)로 구성되는 값들의 범위를 갖는 타입
  - NULL은 유효한 주소가 아닌 메모리 참조를 할 수 없음을 나타냄
- 포인터 설계의 용도
  - 간접 주소지정 방식을 지원하기 위해
    - Scope룰에 의해 직접 접근이 안되는 대상에 간접적으로 접근하기위해 사용됨
  - 동적 기억공간(힙 heap)을 관리하는 방식을 제공하기 위해
- 힙-동적 변수
  - 힙공간에 동적으로 할당되는 변수
  - 식별자(이름)가 없음 -> 무명 변수 (힙이 Nameless 로 불리기도 함)
    - 따라서 포인터를 이용하여 간접적으로 접근이 가능

- 포인터는 동적 자료구조의 작성력을 향상시킴
  - Fortran 77에서는 동적 기억공간이 없음 그리고 이진 트리와 같은 동적 구조를 배열과 같은 이용하여 구현해야 하므로 작성력이 떨어짐

- 설계 고려 사항
  - 포인터 변수의 영역과 존속기간은 무엇인가?
  - 힙-동적 변수(포인터가 참조하는 값)의 존속기간은 무엇인가?
  - 포인터는 가리킬 수 있는 값에는 제약이 있는가?
  - 포인터가 동적 기억공간 관리, 간접 주소지정 또는 두 가지 모두를 위해 사용되는가?
  - 언어가 포인터 타입, 참조 타입, 또는 두 가지 모두를 지원하는가?

- C/C++의 포인터
  - 어셈블리에서 주소를 사용하는 방식으로 C/C++에서 주소를 사용 가능
    - 유연성을 제공하나 허상 포인터(dangling pointer)나 메모리 누수(memory leaking)과 같은 문제에 어떤 해결책도 제시하지 않음 -> 매우 조심해서 사용해야 함
  - 포인터 연산
    - *: 역참조 연산
    - &: 변수의 주소를 생성하기 위한 연산
    - +: 포인터의 주소 덧셈 연산
    - 배열의 요소 접근을 위해 사용
  - 포인터 정의
    - "타입 *"을 이용하여 포인터를 정의 함
  - 변수의 주소 계산 및 역참조
    - 변수의 주소를 계산할 경우 & 연산자를 사용
    - 주소값에 대한 역참조를 수행할 경우 * 연산자를 사용
    - 예) pointer_basic.c
  - Scope이 다른 변수에 대한 간접 참조
    - Scope룰에 의해 직접 접근이 안되는 대상에 간접적으로 접근 하기 위해 사용 됨
    - 예) pointer_indirect.c
  - 배열과 포인터
    - C/C++에서 배열명은 주소값, 포인터는 변수
    - C/C++에서 배열 자체를 함수의 인자로 넘길 수 없으며 포인터를 사용해야 함
    - 주소값 연산을 통해 항목들을 접근하는 것이 가능
      - 배열의 요소 접근 a[1]은 실제로 C 컴파일러에의해 *(a + 1)로 처리
    - C Programming Language의 "5.3절 Pointers and Arrays" 참조
    - 예) pointer_array_1.c, pointer_array_2.c, pointer_array_cpp.cpp
  - 구조체와 포인터
    - 구조체의 멤버를 접근할 경우 . 연산자를 사용
      - 구조체를 포인터로 지정할 경우 (*ptr).member로 사용해야하며 이는 ptr->member로사용 가능  
    - 예) pointer_struct.c, pointer_struct_cpp.cpp

- 포인터가 유발할 수 있는 문제
  - Dangling pointer (Stray pointer, 허상 포인터)
    - 이미 회수된 힙-동적 변수의 주소를 가지고 있는 포인터
    - 문제점
      - 포인터가 가리키는 메모리가 회수된 후 다시 할당 된 경우 이전 포인터를 이용한 값의 변경은 문제를 발생시킬 수 있음
      - 예) dangling_pointer.c
    - 해결책
      - 포인터가 가리키는 메모리가 회수된 경우, 포인터를 NULL로 설정한다.
  - Memory leaking (메모리 누수)
    - 더 이상 접근할 수 없는 힙-동적 변수(쓰레기)가 발생하는 현상
      - 쓰레기(Garbage): 변수들이 원래의 목적에에 유용하지 않고, 프로그램에서 새로운 용도로 다시 활용할 수 없는 메모리
    - 예) memory_leaking.c
    - 해결책
      - 힙-동적 변수를 다 사용하고 나면 반드시 반납을 하라.
        - C에서는 free함수 C++에서는 delete 연산

- 참조 타입
  - 메모리의 객체나 값을 참조하는 용도
    - 포인터는 메모리의 주소를 참조
  - 포인터는 주소에 대한 산술 연산이 가능하나, 참조는 주소에 대한 산술 연산이 허용되지 않음
  - C++에서의 참조 타입
    - 묵시적으로 역참조되는 상수 포인터로 변수의 정의의에서 &를 사용
      - C++의 참조 타입은 한번 초기화되면 다른 변수를 참조하도록 설정할 수 없음
      - 예) reference_1.cpp
    - 참조 타입을 이용하여 형식 매개변수의 전달에 활용 (컴파일러가 주소 전달)
      - 포인터는 가독성이 떨어지고 안전하지 않은 연산을 유발할 수 있음
      - 하지만 참조 타입 또한 원본 값을 변화시키는 부작용을 유발할 수 있음
      - 예) reference_2.cpp
    - Java에서의 참조 타입
      - 안정성 향상을 위해 C/C++ 유형의 포인터를 제거
      - Java에서는 객체를 참조할 수 있도록 사용하며 변수 임(상수가 아님)
      - Java에서 객체들은 Managed-Heap에 할당되며 참조를 통해 접근됨
        - 어떤 참조도 되지 않는 객체는 GC(Garbage Collector)에 의해 회수 -> 메모리 누수가 없음
      - 예) StudentExam.java
    - C#
      - 포인터와 Java 스타일의 참조를 모두 포함, 하지만 포인터 사용은 권장치 않음
        - C/C++과의 연동을 위하여 포함됨, 포인터 사용시 unsafe라는 지정자 필요
        - 참조된 객체는 묵시적으로 회수되나 포인터를 이용하여 참조된 객체는 명시적 회수가 필요
    - Smalltalk, Python, Ruby, Lua
      - 모든 변수는 참조 타입이며 모든 대상은 객체임
      - 예) student_exam.py

- 평가
  - 포인터는 허상 포인터(Dangling Pointer)와 메모리 누수(Memory Leaking)과 같은 문제 내포
  - 포인터 변수는 메모리의 참조 범위를 확대하는 경향이 있음
    - "고급언어에서 포인터의 도입은 결코 회복할 수 없는 한 걸음의 후퇴였다" - Hoare
  - 포인터는 디바이스 드라이버(장치 관리자)와 같은 시스템 프로그램  작성에는 필수적인 요소
  - Java, C#, Python등의 참조 변수는 안정성과 유연성을 제공
    - 결국 포인터와 참조 변수는 성능(혹은 자유)와 안전성의 Trade-off

## 💫 타입 검사

---

- 연산자에 포함된 피연산자들이 호환 가능한 타입인지를 확인하는 행위
- 호환 가능 타입 (Compatible type)
  - 연산자에 의해서 적법하거나, 컴파일러-생성 코드(또는 해석기)에 의해서 적법한 타입으로 묵시적으로 변환되는 것이 언어 규칙에 허용되는 타입
- 강제 형변환(Coercion, 묵시적 형변환)
  - 연산에 참여할 때 컴파일러나 인터프리터가 적법한 타입으로 형을 강제로(암묵적으로) 변화시키는 행위
    - 예) int + float 에서 int 형을 float 형으로 변환 혹은 배정문에서 int 형을 float형으로 변환
    - 예) coercion.c, CoercionExam.java
  - 강제 형변환은 때때로 신뢰성을 약화시킴
    - Fortran, C, C++은 상당히 많은 강제 형변환을 허용
      - 예) strong_type_coercion.c
    - Ada, ML, F#은 강제 형변환이 거의 없거나 없음
    - Java, C#은 강제 형변환을 반정도 허용
      - 예) CoercionExam.java
- 정적 타입 검사
  - 변수들에 대한 타입 바인딩이 정적이면 타입 검사는 항상 정적으로 가능
  - 장점
    - 컴파일 시점에 타입 오류를 발견하므로 비용이 적게든다.
  - 단점
    - 유연성이 부족
- 동적 타입 검사(Dynamic Type Checking)
  - 실행시간에 타입 검사가 가능한 언어
  - 예) JavaScript, Python, Ruby 등은 동적 타입 바인딩이 되므로 동적 바인딩만 허용
  - 장점
    - 유연성이 증가
  - 단점
    - 오류를 실시간에 파악 가능하므로 타입 검사 비용이 많이 든다.
    - 오류를 초래하기 쉽고 가독성을 약화시킴

- 강 타입
- 강 타입 언어(Strong type language)
  - 프로그래밍 언어의 타입 오류가 항상 감지되는 언어
    - 모든 피연산자의 타입이 컴파일 시점 혹은 실행 시점에 타입이 결정되어야 함
    - 변수들의 잘못된 사용을 감지해 냄으로 안전성을 증대
      - 예) StrongType.java
  - Ada, ML, F#, Java, C# 등은 강 타입 언어에 속함
    - Java, C#은 명시적 타입 캐스팅을 허용하며 이는 오류를 낼 수 있음
  - C/C++는 강타입 언어가 아님(Weak type language)
    - 공용체의 경우 타입 검사를 하지 않음
- 강제 형변환(Coercion) vs 강 타입 언어
  - 강제 형변환은 강 타입 언어의 특성을 약화 시킬 수 있음
    - 가급적 명시적 형변환을 수행 할 것 - 예) StrongTypeCoercion.java
    - 타입 검사 프로그램(lint)를 사용할 것 - Ubuntu splint
