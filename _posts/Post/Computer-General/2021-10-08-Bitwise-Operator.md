---
title: "🌒 비트 연산, 시프트 연산"
date: 2021-10-08. 19:35:00

# last_modified_at: 2021-10-10 #?
# last_modified_at: 2023-11-26
last_modified_at: 2024-02-10. 01:47

categories: ⭐Computer 🌒Programming
tags: Computer Bit Bitwise-Operator Bitwise-Operation Shift-Operator Shift-Operation
---

## 💫 공통

---

정수형 데이터의 연산만 가능 (실수형 데이터 X)  

- And, Or, Not, Exclusive-Or/XOR
- Bit Operator, Bit Operation & \| ~ ^
- Bit Vector, 길이 w의 0/1로 구성된 데이터
- 비트 벡터를 이용한 집합의 표현과 운영 (비트 연산)

- Bit 인자(피연산자)들을 Bit Vector로써 비트 단위 연산 Bit Wise Operate
- 마스크 연산
  - 일종의 비트 패턴으로, 원하는 비트를 추출
  - 워드 중 일부 선택된 비트 집합

- 비트 연산자 vs 논리 연산자
  - \|\| OR, && AND, ! NOT
  - 0 = false, !0 = true
  - 항상 0이나 1 산출
  - Early termination
    - Short-Circuit Evaluation
      - p && *p, avoids null pointer access
    - 반면 비트 연산자는 모두 연산

### 2.1.9 C의 비트이동 연산

- 좌측 이동 x << k
  - 왼쪽 초과 비트들은 버림
  - 우측 0로 채움
- 우측 이동 x >> k
  - 오른쪽 초과 비트들은 버림
  - 논리 쉬프트, 왼쪽 0로 채움
  - 산술 쉬프트, 오른쪽 최상위 비트 복제
    - 2의 보수 정수 표현에 유용

## 💫 비트 연산

---

### 🫧 &

AND, 비트 AND 연산자  
양쪽 피연산자의 각 비트를 비교하여 양쪽 모두 1이면 1, 아니라면 0으로 설정.  

```c
int x = 3;
//      3, ...0011
int y = 5;
//      5, ...0101
int z = x & y;
//      1, ...0001
```

### 🫧 ^

- XOR, 포괄적 비트 XOR 연산자, (eXclusive OR)
- 양쪽 피연산자의 각 비트를 비교하여 서로 다르면 1, 아니라면 0으로 설정.

```c
int x = 3;
//      3, ...0011
int y = 5;
//      5, ...0101
int z = x ^ y;
//      6, ...0110
```

### 🫧 |

- OR, 배타적 비트 OR 연산자
- 양쪽 피연산자의 각 비트를 비교하여 한 쪽이라도 1이면 1, 아니라면 0으로 설정.
- `Shift + 역슬래시 (Enter 위에 있는 키, ₩)` 로 입력할 수 있음.

```c
int x = 3;
//      3, ...0011
int y = 5;
//      5, ...0101
int z = x | y;
//      7, ...0111
```
  
### 🫧 ~

- NOT, 비트 보수(또는 비트 NOT) 연산자
- 피연산자의 비트 보수를 만듦 (0에서 1, 1에서 0으로 수를 뒤집음)
- 여담으로, `~` 는 단항 산술 연산자로 분류됨. (MSDC 기준)

```c
int x = 15;
//      15, ...0000'0000'0000'1111
int y = ~x;
//     -16, ...1111'1111'1111'0000
```

## 💫 비트 시프트 연산자

---

- 주의 할 점
  - 비트 시프트 연산자로 수행된 변환은 오버플로, 언더플로 조건을 지원하지 않음.
    - 때문에 연산 결과가 첫 번째 피연산자 형식으로 표현할 수 없는 경우,
    - 오류가 발생하지 않으며, 정보가 **손실**될 수 있음.

### 🫧 <<

- 첫 번째 피연산자를 두 번째 피연산자 만큼 왼쪽으로 이동.
- 계산에 오버플로가 없는 경우, 첫 번째 피연산자에 2<sup>두 번째 피연산자</sup> 를 곱한 값과 같음.
- 시프트 이후 비워진 비트는 0 으로 설정됨.

```c
int x = 15;
//      15,  ...0000'0000'0000'1111
int y = x << 4;
//      240, ...0000'0000'1111'0000
//      240 = 15 * 2^4
```

### 🫧 >>

- 첫 번째 피연산자를 두 번째 피연산자 만큼 오른쪽으로 이동.
- 첫 번째 피연산자가 부호가 없거나, 음수가 아닌 경우, 2<sup>두 번째 피연산자</sup> 로 나눈 값과 같음.
- 시프트 이후 비워진 비트는 첫 번째 피연산자의 형식에 따라 채워짐.
  - 부호 없는 `unsigned` 형식이면, 0으로 채워짐 (최상위 비트 설정 해제)
  - 부호 있는 형식이라면 부호 비트가 복사되여 채워짐. 양수 0, 음수 1 (최상위 비트 설정된 채 유지)

```c
int x = 240;
//      240, ...0000'0000'1111'0000
int y = x >> 4;
//      15,  ...0000'0000'0000'1111
//      15 = 240 / 2^4
```

- 음수 값을 오른쪽으로 이동하면 원래 값의 반을 정수로 내림한 값이 생성됨.
  - -253 (11111111 00000011) 을 오른쪽으로 1비트 이동하면,
  - -127 (11111111 10000001) 이 생성됨.
  - 253 (00000000 11111101) 을 오른쪽으로 1비트 이동하면,
  - 126 (00000000 01111110) 이 생성됨.

## 💫 할당 연산자

---

- 다른 연산자들과 마찬가지로 할당 연산자를 통해 값 변형과 할당을 동시에 할 수 있음.
  - `&=`
  - `^=`
  - `|=`
  - `~` 는 단항 산술 연산자라 할당 연산자가 존재하지 않음.
  - `<<=`
  - `>>=`

## 💫 참고

---

- [MSDC](https://docs.microsoft.com/ko-kr/cpp/c-language/c-bitwise-operators?view=msvc-160)
- [Wikipedia - 비트 연산자](https://ko.wikipedia.org/wiki/%EB%B9%84%ED%8A%B8_%EC%97%B0%EC%82%B0)
- [Wikipedia - 산술 시프트](https://ko.wikipedia.org/wiki/%EC%82%B0%EC%88%A0_%EC%8B%9C%ED%94%84%ED%8A%B8)
- [Wikipedia - 논리 시프트](https://ko.wikipedia.org/wiki/%EB%85%BC%EB%A6%AC_%EC%8B%9C%ED%94%84%ED%8A%B8)

비트 마스크

& = ?

웹에서 계산기 만들기

```cs
(value >> 16) & byte.MaxValue
(value >> 8) & byte.MaxValue
(value >> 0) & byte.MaxValue
```
