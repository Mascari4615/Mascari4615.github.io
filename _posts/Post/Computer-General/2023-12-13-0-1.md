---
title: "🌑 0-1 배낭 문제"
date: 2023-12-13. 11:04
# last_modified_at: 2023-12-13. 11:04
categories: ⭐Computer 🌑Computer-General
tags: Algorithm
---

## 💫 0-1 배낭 문제

---

- 0-1 배낭 문제는
  - 욕심쟁이 방법으로 해결할 수 없음(2장)
  - 분할정복과 동적 계획법을 이용하여 해결(4장)
- 문제
  - 각 물건을 통째로 넣거나 아예 안 넣거나 택일해야 한다는 조건이 있을 때, 배낭의 용량을 넘지 않으면서 배낭에 담을 수 있는 물건들의 최대 이익이 얼마인가?
  - 최대 이익을 얻어내기 위해 어떤 물건들을 담아야 하는가?

최적화 문제  

@ 사진  
어떤 방법으로 풀든 다 같은 조건인데, BT에서는 요소 내림차순 정렬 조건이 붙음  

## 💫 Solve By BackTracking

---

추가 조건  
주의) 물건을 단위 무게당 이익에 따라 내림차순으로 정렬  

- 최적화 문제 해결을 위한 백트래킹 알고리즘 구조
  - 모든 해답을 다 찾아야 하는 문제에 대한 백트래킹: n-여왕 문제
  - 결정 문제에 대한 백트래킹: 해밀턴 사이클 문제
  - 최적화 문제에 대한 백트래킹
    - 상태 공간 트리를 모두 뒤지는 것이 목표
    - 현재까지의 최적해를 항상 기억하고 있다가, 방문하는 새 노드의 해와 비교한 후 새 노드의 해가 더 낫다면 최적해 값을 변경(갱신)

```cs
void BT_OPT(Node v)
{
	optimal = Winner(optimal, Solution(v));
	
	if (Promising(v))
		foreach (Node child in v.childNodes)
			BT_OPT(child);
}
```

### 🫧 상태 공간 트리

- 주요 변수
  - weight = 현재까지 담은 물건의 무게 합
  - profit = 현재까지 담은 물건의 이익 합
  - max_profit (optimal) = 현재까지의 최적해 즉 현재까지의 최대 이익
- 최적해를 변경하는 조건
  - 배낭에 물건을 넣어야 하는 노드를 방문 → weight와 profit의 값이 증가
  - 배낭의 용량을 넘어서지 않으면서 지금까지의 최대 이익보다 큰 이익이 발생하면 max_profit 값은 변경된 profit 값으로 바뀌어야 함
  - 따라서 다음 조건을 만족하면 최적해가 변경
  - (weight <= M) ^ (profit > max_profix)

### 🫧 알고리듬

- 유망하지 않은 노드의 판별(현재 i번째 물건까지 결정된 상태)
  - 규칙 1) 더 이상 물건을 담을 수 없는 경우, weight >= M
  - 규칙 2) 아직은 배낭에 여유가 있지만 현 상태에서 어떻게 진행하더라도 현재까지의 최대 이익보다 더 큰 이익을 기대하지 못하는 경우(현재까지 담은 물건의 이익에다가 남아있는 물건들을 최적으로 추가하여 얻을 수 있는 이익을 합한다 하더라도 현재까지의 최대 이익을 능가하지 못하는 경우)
    - 부분 배낭 문제로 풀었을 때의 최대 이익 ≥ 0-1 배낭 문제로 풀었을 때의 최대 이익
      - ∴ 최대 이익의 상한을 구하기 위해 부분 배낭 문제로 변신
    - 현재까지 담은 물건의 이익(profit)+남은 물건을 대상으로 부분 배낭 문제로 전환하여 풀었을 때의 최대 이익(exp_profit)이 현재까지의 최대 이익(max_profit)보다 작다면 절대로 유망할 수가 없음 → 처음에 물건을 단위 무게 당 이익의 순에 따라 내림차순으로 정렬한 이유
      - profit + exp_profit <= max_profit
      - @ 사진 배낭 0001

- 배열을 이용하여 상태 공간 트리를 관리하는 방법
  - 부분 집합의 합 문제와 동일
  - 기억해야 할 정보는 “걸어온 길”
  - 레벨 i 노드는 i 개 물건가운데 배낭에 넣은 물건들을 기억해야 함
    - 해당 노드가 유망하여 자식 노드로 내려간다면 i+1개 물건가운데 배낭에 넣은 물건들을 기억
    - 유망하지 않아 부모 노드로 백트래킹한다면 i -1개 물건가운데 배낭에 넣은 물건들을 기억
  - 배열 인덱스: 물건, 배열 값: 물건의 포함 여부
    - ∴ n 개의 값(true/false)색을 저장할 수 있는 1차원 배열이 필요
  - [그림 5.19]의 해답 상태
    - 1 2 3 4 인덱스
    - flase true true 포함여부
  - 단말 노드가 아닌 노드가 해답이라면 해답 노드의 레벨까지 저장된 값만이 유효

### 🫧 구현

알고리즘 01_ks_BT(0,0,0);을 호출함으로써 시작, 전역 변수 max_profit의 초 기 값은 0  

```cs
void 01_ks_BT(int i, int profit, int weight)
{
	if (weight <= M && profit > max_profit)
	{
		max_profit = profit;	// 최대 이익의 변경 
		optimal = (X[1]..X[i]); // i 개의 물건들의 포함 여부
	}

	if (Promising(i, profit, weight))
	{
		X[i+1] = true;
		01_ks_BT(i+1, profit+P[i+1], weight+W[i+1]);
		X[i+1] = false;
		01_ks_BT(i+1, profit, weight);
	}
}

bool Promising (int i, int profit, int weight)
{
	int k, exp_weight=0;
	float exp_profit=0;

	// 꽉 차거나 찢어짐
	if (weight >= M)
		return false;

	for (k = i+1; k <= n; k++)
	{
		if (weight + exp_weight + W[k] > M)
			break;
		exp_weight += W[k];
		exp_profit += P[k];
	}

	if (k<=n)
		exp_profit += (M-(weight+exp_weight))*P[k]/W[k];

	if (profit + exp_profit <= max_profit)
		return false; 

	return true;
}
```

### 🫧 분석

- 상태 공간 트리의 노드 수
  - 부분집합의 합 문제와 상태 공간 트리가 동일: 1 + 2 + 2^2  + … + 2^n = 2^(n+1) - 1
  - NP-완전 문제 중에는 비교적 노드수가 적지만 여전히 지수 복잡도
- 유망한 노드 수
  - 유망한 노드 개수를 계산할 수 없음
  - 같은 개수의 노드를 갖더라도 배낭 용량이나 물건 무게에 따라 유망한 노드의 수가 달라짐
  - 최적화 문제 → 상태 공간 트리를 모두 뒤져야 함. 단지 탐색하는 노드의 수가 달라질 뿐
- 동적 계획법 vs. 백트래킹
  - Horowitz와 Sahni의 명저 “Fundamentals  of  Computer  Algorithms”에는 Venkatesh가 실제 컴퓨터상에서 실행시켜 본 결과가 수록: 다음 4가지 경우의 데이터 집합 사용
    - ➊ 각 물건의 무게와 이익을 1~1,000 범위 안에서 임의로 생성한 경우
    - ➋ 각 물건의 무게와 이익을 1~100 범위 안에서 임의로 생성한 경우
    - ➌ 각 물건 무게를 1~100 범위 안에서 임의로 생성하고 이익은 무게에 10을 더한 경우
    - ➍ 각 물건 무게를 1~100 범위 안에서 임의로 생성하고 이익은 무게에 1.1을 곱한 경우
    - 배낭 용량 M은 물건 무게의 합에 절반이 되도록 하고 물건의 개수 n에 대해 10개씩의 인스턴스에 대한 측정값을 비교 → 일반적으로 백트랙킹 알고리즘이 동적 계획법 알고리즘보다 우수
