---
title: "🌓 CPP 공부"
date: 2023-02-22. 02:35
last_modified_at: 2024-02-17. 20:13
categories: [⭐Computer, 🌓PS-Algorithm]
tags: [Algorithm, CPP]
---

[size_t, unsigned int](https://love-every-moment.tistory.com/38)  
[size_t, unsigned int](https://pvs-studio.com/en/blog/posts/cpp/a0050/)  
[size_t, unsigned int](http://mwultong.blogspot.com/2007/06/c-sizet-unsigned-int.html)  
[특정 문자 제거 erase remove](https://wooono.tistory.com/475)  
[특정 문자 제거 erase remove](https://cho001.tistory.com/164)  
[string 생성자](https://modoocode.com/237)  
[배열 특정 요소 개수](https://codechacha.com/ko/cpp-check-if-element-is-in-array/)  
[Vector 탐색](https://notepad96.tistory.com/41)  
[size_t, unsigned int](https://pvs-studio.com/en/blog/posts/cpp/a0050/)  
[size_t, unsigned int](https://pvs-studio.com/en/blog/posts/cpp/a0050/)  
[size_t, unsigned int](https://pvs-studio.com/en/blog/posts/cpp/a0050/)  

- ++ ++ a O, a ++ ++ X  
  - 오른쪽에서 왼쪽으로 실행되기 대문에  
  - 무튼 연산자 만들 때 그래서 위쪽은 되게, 아래쪽은 안되게 만들어야함  
  - 이걸 간단히 구현하게 해주는 방법이 있음  
  - 객체& operator++() 에서 &을 붙여주는 이유  
  - 예를 들어 Temp a = v1 + v2 를 봤을 때  
  - v1 + v1 의 결과값은 임시 객체임, v1이나 v2의 실체 객체가 아니라는 것  
  - 이를 바탕으로 ++ ++ a 를 보면  
  - 객체를 반환값으로 보내면  
  - a = a + 1 에서 a(왼쪽) 를 반환하지 않고 a + 1(오른쪽) 의 임시 객체를 보내버림  
  - 그래서 자기 자신을 반환하기 위해 레퍼런스를 보냄  

- C++ time  

```cpp
#include <time.h>

using namespace std;

int main()
{
	time_t cur;
	time(&cur);
	tm* gmTM = gmtime(&cur);
	printf("%d\n%02d\n%02d", 1900 + gmTM->tm_year, gmTM->tm_mon + 1, gmTM->tm_mday);
}
```

- [[C++] 코딩테스트를 위한 C++ 기본](https://suyeoniii.tistory.com/13)
- [코딩 테스트 입문 (with C++)](https://gamedevlog.tistory.com/6?category=892157)

for (auto item : ~)  
for (auto& item : ~)  

[iter find](https://modoocode.com/261)  
[string find](https://naakjii.tistory.com/104)  

find(v.begin(), b.end(), )  
s.find(c)  

string::npos == -1  
find 실패 시 리턴  

pow sqrt -> cmath  
min max -> algorithm  

[rotate](https://notepad96.tistory.com/59)  

toupper, tolower  
isupper, islower, isdigit, isalpha  

split 대신  

```cpp
#include <sstream>
stringstream ss(s);  
string word;
while (ss >> word)
{
	cout << word << endl;
}
```

ceil ceiling 올림  
round 반올림  
floor floor 내림  

vector<T> v2(v1)  

memset(ptr, value, size)  

오름차순 정렬되어 있는 자료구조에 대하여,  
lower_bound : k <= 요소가 배열 몇 번째에 처음 등장하는 지  
upper_bound : k < 요소가 배열 몇 번째에 처음 등장하는 지  
iterator로 반환되므로 자료구조 주소를 빼주면 인덱스가 나옴  

특정 범위의 숫자가 몇 번 나오는 지  

```cpp
while(!cin.eof())
	cin >> temp;
```

> [C++ C3861](https://docs.microsoft.com/ko-kr/cpp/error-messages/compiler-errors-2/compiler-error-c3861?view=msvc-170)  
> 에러 : '뭐시깽' 식별자를 찾을 수 없습니다.  
> 해결 : 함수 위치 밑 선언 확인  

---

> [C++ C2360](https://docs.microsoft.com/ko-kr/cpp/error-messages/compiler-errors-1/compiler-error-c2360?view=msvc-170), [C++ C2361](https://docs.microsoft.com/ko-kr/cpp/error-messages/compiler-errors-1/compiler-error-c2361?view=msvc-170)  
> 에러 : '뭐시깽' 초기화가 'case'/'default' 레이블에 의해 생략되었습니다.  
> 해결 : 변수 선언하는 case에 스코프 {} 달아주기  
> [설명](https://ansohxxn.github.io/cpp/chapter5-1/) : case/default 이전 공간에서는 메모리 할당 안됨

포인터 delete 후 어떤 코드가 없더라도 = nullptr 대입  

---

2의배수  
int overflow  
IEEE-754 format  

실수의 성질  
저장/연산 과정에서 반드시 오차가 발생한다  
실수는 double을 쓸 것  
보통 실수를 써야하는 문제라면 오차범위를 알려주는데, 없으면 정수만으로 풀 수 있는 문제일 것  

double에 long long을 담지 말 것 (범위로 인한 오차)  

실수를 비교할 때 부호를 쓰지 말 것 (마찬가지로 오차)  
`if (abs(a-b) - 1e-12)` (10<sup>-12</sup>)  

STL을 쌩으로 함수 인자에 넣어서 보내면 **복사**해서 보낸다  

표준 입출력  

c scanf printf (C++의 string을 쓸 수 없다)  

c scanf printf  
c++ cin cout  
둘 다 공백 포함 문자열 입력을 받기 어려운데  

3가지 방법이 있다  

```cpp
// 1. scanf의 옵션
char a1[10];
scanf("%[^\n]", a1);

// 2. gets 함수 (보안상의 이유로 C++14 이상에서는 제거됨)
char a2[10];
gets(a2);
puts(a2);

// 3. getline 함수
string s;
getline(cin, s);
cout << s;

// cin cout을 쓸 때  
// 입출력이 많으면 시간초과가 날 수 있음

```cpp
ios::sync_with_stdio(0);
// or
ios::sync_with_stdio(false);

// scanf printf 에서 쓰는 c stream과  
// cin cout 에서 쓰는 cpp stream이 분리되어있다  

// 근데  

cout << "11111\n";
printf("22222\n");
cout << "33333\n";

// 같이 섞어 쓰는 상황이면  
// 순서대로 실행 되는게 일단 직관적이기 때문에 c stream과 cpp stream을 동기화 시켜주고 있다  

// 근데 cpp stream만 쓰는 거면 굳이 동기화 할 필요가 없음  
// 시간적 이득을 얻기 위해 끊어주기  

// vs2017 2019에서는 써도 강제적으로 동기화를 해버림  
// 채점 서버는 gcc라 차이가 있음  

cin.tie(0);
// or
cin.tie(nullptr);

// 입출력 버퍼  
// 버퍼에서 모았다가 입력/출력  

for (~)
{
	cin >> a >> b;
	cout << a + b << '\n';
}

// 이것도 순서대로 나오는 게 직관적이니까
// 지본적으로는 cin 명령을 수행하기 전에 cout 버퍼를 비워준다 (출력을 한다)

// 근데 온라인 채점 서버는 그냥 출력값만 보고 채점을 한다
// 굳이 cin 명령을 수행하기 전에 cout을 비워주지 않아도 됨
// 그걸 끊어주는

// endl
// 개행문자를 출력하고 버퍼를 비워주는
// 버퍼를 비워줄 이유가 없으니까 절대 쓰지 말 것
```

코딩 테스트와 개발은 다르다  
클린코드를 짜는게 아니라, 제한된 시간안에 내가 편한 방법으로 정답을 맞추는 게 더 중요  

출력 마지막에 공백, 줄바꿈이 추가로 있어도 상관이 없다  

디버거는 굳이 사용하지 않아도 된다.  
그냥 cout  
