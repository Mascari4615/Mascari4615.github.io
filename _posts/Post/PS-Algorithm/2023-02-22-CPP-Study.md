---
title: "🌓 C++"
date: 2023-02-22. 02:35
# last_modified_at: 2024-02-17. 20:13
# last_modified_at: 2024-02-21. 18:09
last_modified_at: 2024-02-23. 03:50
categories: [⭐Computer, 🌓PS-Algorithm]
tags: [Algorithm, CPP]
---

[size_t, unsigned int](https://love-every-moment.tistory.com/38)  
[size_t, unsigned int](https://pvs-studio.com/en/blog/posts/cpp/a0050/)  
[size_t, unsigned int](http://mwultong.blogspot.com/2007/06/c-sizet-unsigned-int.html)  
[특정 문자 제거 erase remove](https://wooono.tistory.com/475)  
[특정 문자 제거 erase remove](https://cho001.tistory.com/164)  
[string 생성자](https://modoocode.com/237)  
[배열 특정 요소 개수](https://codechacha.com/ko/cpp-check-if-element-is-in-array/)  
[Vector 탐색](https://notepad96.tistory.com/41)  
[size_t, unsigned int](https://pvs-studio.com/en/blog/posts/cpp/a0050/)  
[size_t, unsigned int](https://pvs-studio.com/en/blog/posts/cpp/a0050/)  
[size_t, unsigned int](https://pvs-studio.com/en/blog/posts/cpp/a0050/)  

- ++ ++ a O, a ++ ++ X  
  - 오른쪽에서 왼쪽으로 실행되기 대문에  
  - 무튼 연산자 만들 때 그래서 위쪽은 되게, 아래쪽은 안되게 만들어야함  
  - 이걸 간단히 구현하게 해주는 방법이 있음  
  - 객체& operator++() 에서 &을 붙여주는 이유  
  - 예를 들어 Temp a = v1 + v2 를 봤을 때  
  - v1 + v1 의 결과값은 임시 객체임, v1이나 v2의 실체 객체가 아니라는 것  
  - 이를 바탕으로 ++ ++ a 를 보면  
  - 객체를 반환값으로 보내면  
  - a = a + 1 에서 a(왼쪽) 를 반환하지 않고 a + 1(오른쪽) 의 임시 객체를 보내버림  
  - 그래서 자기 자신을 반환하기 위해 레퍼런스를 보냄  

- C++ time  

```cpp
#include <time.h>

using namespace std;

int main()
{
	time_t cur;
	time(&cur);
	tm* gmTM = gmtime(&cur);
	printf("%d\n%02d\n%02d", 1900 + gmTM->tm_year, gmTM->tm_mon + 1, gmTM->tm_mday);
}
```

- [[C++] 코딩테스트를 위한 C++ 기본](https://suyeoniii.tistory.com/13)
- [코딩 테스트 입문 (with C++)](https://gamedevlog.tistory.com/6?category=892157)

for (auto item : ~)  
for (auto& item : ~)  

[iter find](https://modoocode.com/261)  
[string find](https://naakjii.tistory.com/104)  

find(v.begin(), b.end(), )  
s.find(c)  

string::npos == -1  
find 실패 시 리턴  

pow sqrt -> cmath  
min max -> algorithm  

[rotate](https://notepad96.tistory.com/59)  

toupper, tolower  
isupper, islower, isdigit, isalpha  

split 대신  

```cpp
#include <sstream>
stringstream ss(s);  
string word;
while (ss >> word)
{
	cout << word << endl;
}
```

ceil ceiling 올림  
round 반올림  
floor floor 내림  

vector<T> v2(v1)  

memset(ptr, value, size)  

오름차순 정렬되어 있는 자료구조에 대하여,  
lower_bound : k <= 요소가 배열 몇 번째에 처음 등장하는 지  
upper_bound : k < 요소가 배열 몇 번째에 처음 등장하는 지  
iterator로 반환되므로 자료구조 주소를 빼주면 인덱스가 나옴  

특정 범위의 숫자가 몇 번 나오는 지  

```cpp
while(!cin.eof())
	cin >> temp;
```

> [C++ C3861](https://docs.microsoft.com/ko-kr/cpp/error-messages/compiler-errors-2/compiler-error-c3861?view=msvc-170)  
> 에러 : '뭐시깽' 식별자를 찾을 수 없습니다.  
> 해결 : 함수 위치 밑 선언 확인  

---

> [C++ C2360](https://docs.microsoft.com/ko-kr/cpp/error-messages/compiler-errors-1/compiler-error-c2360?view=msvc-170), [C++ C2361](https://docs.microsoft.com/ko-kr/cpp/error-messages/compiler-errors-1/compiler-error-c2361?view=msvc-170)  
> 에러 : '뭐시깽' 초기화가 'case'/'default' 레이블에 의해 생략되었습니다.  
> 해결 : 변수 선언하는 case에 스코프 {} 달아주기  
> [설명](https://ansohxxn.github.io/cpp/chapter5-1/) : case/default 이전 공간에서는 메모리 할당 안됨

포인터 delete 후 어떤 코드가 없더라도 = nullptr 대입  

---

2의배수  
int overflow  
IEEE-754 format  

실수의 성질  
저장/연산 과정에서 반드시 오차가 발생한다  
실수는 double을 쓸 것  
보통 실수를 써야하는 문제라면 오차범위를 알려주는데, 없으면 정수만으로 풀 수 있는 문제일 것  

double에 long long을 담지 말 것 (범위로 인한 오차)  

실수를 비교할 때 부호를 쓰지 말 것 (마찬가지로 오차)  
`if (abs(a-b) - 1e-12)` (10<sup>-12</sup>)  

STL을 쌩으로 함수 인자에 넣어서 보내면 **복사**해서 보낸다  

표준 입출력  

c scanf printf (C++의 string을 쓸 수 없다)  

c scanf printf  
c++ cin cout  
둘 다 공백 포함 문자열 입력을 받기 어려운데  

3가지 방법이 있다  

```cpp
// 1. scanf의 옵션
char a1[10];
scanf("%[^\n]", a1);

// 2. gets 함수 (보안상의 이유로 C++14 이상에서는 제거됨)
char a2[10];
gets(a2);
puts(a2);

// 3. getline 함수
string s;
getline(cin, s);
cout << s;

// cin cout을 쓸 때  
// 입출력이 많으면 시간초과가 날 수 있음

```cpp
ios::sync_with_stdio(0);
// or
ios::sync_with_stdio(false);

// scanf printf 에서 쓰는 c stream과  
// cin cout 에서 쓰는 cpp stream이 분리되어있다  

// 근데  

cout << "11111\n";
printf("22222\n");
cout << "33333\n";

// 같이 섞어 쓰는 상황이면  
// 순서대로 실행 되는게 일단 직관적이기 때문에 c stream과 cpp stream을 동기화 시켜주고 있다  

// 근데 cpp stream만 쓰는 거면 굳이 동기화 할 필요가 없음  
// 시간적 이득을 얻기 위해 끊어주기  

// vs2017 2019에서는 써도 강제적으로 동기화를 해버림  
// 채점 서버는 gcc라 차이가 있음  

cin.tie(0);
// or
cin.tie(nullptr);

// 입출력 버퍼  
// 버퍼에서 모았다가 입력/출력  

for (~)
{
	cin >> a >> b;
	cout << a + b << '\n';
}

// 이것도 순서대로 나오는 게 직관적이니까
// 지본적으로는 cin 명령을 수행하기 전에 cout 버퍼를 비워준다 (출력을 한다)

// 근데 온라인 채점 서버는 그냥 출력값만 보고 채점을 한다
// 굳이 cin 명령을 수행하기 전에 cout을 비워주지 않아도 됨
// 그걸 끊어주는

// endl
// 개행문자를 출력하고 버퍼를 비워주는
// 버퍼를 비워줄 이유가 없으니까 절대 쓰지 말 것
```

코딩 테스트와 개발은 다르다  
클린코드를 짜는게 아니라, 제한된 시간안에 내가 편한 방법으로 정답을 맞추는 게 더 중요  

출력 마지막에 공백, 줄바꿈이 추가로 있어도 상관이 없다  

디버거는 굳이 사용하지 않아도 된다.  
그냥 cout  

- VS C
  - C + 객체지향 = C++
  - class : 클래스를 이용하여 하나의 객체의 속성과 동작들을 한곳으로 모아서 정의할 수 있다
  - inheritance : 클래스를 상속받아서 기존의 코드를 재사용할 수 있다
  - polymorphism 다형성: 동일한 함수가 객체의 종류에 따라서 다르게 동작하는 것이다
  - 연산자 중복 operator overloading : 대상에 따라서 동일한 연산자로 새로운 연산을 정의할 수 있다
  - 참조 타입 Reference Type : 변수의 별명을 만들어서 변수와 같이 사용할 수 있다.
  - 훨씬 큰 표준 라이브러리 : C와 비교가 되지 않는 풍부한 표준 라이브러리 제공
  - 함수 중복 Function Overloading : 매개변수만 다르면 동일한 이름의 함수를 여러 개 만들 수 있다
  - new 와 delete 연산자 : 동적 메모리 할당과 해제를 담당하는 연산자
  - 제네릭 : 클래스 정의를 자료형에 상관없이 재사용하는 기술

- 비교적 최신 버전 CPP에 추가된
  - 자동 타입 추론 (auto 키워드 사용)
  - 범위 기반 루프
  - 람다식
  - 스마트 포인터
  - 벡터, 목록 및 맵과 같은 표준 템플릿 라이브러리 (STL) 컨테이너
  - STL 알고리듬
  - std::string 및 std::wstring 형식
  - 오류 조건을 보고하고 처리하는 예외
  - STL std::atomic\<\> 를 사용하여 잠금 없는 스레드 간 통신

- vs java C#
  - java C#은 가상 기계의 코드를 생성, 이식성이 좋음
  - C++은 그것은 불가능하지만 빠른 속도로 실행이 가능

- 절차지향 Procedual (프로시저 Procedure)
  - 절차 : 함수, 서브루틴, 프로시저
- vs 절차지향
  - 절차지향 : 작업을 프로시저들로 분리
  - 객체지향 : 주어진 작업을 객체 (Object)로 분리

- 객체지향 최대목표 : 재사용 Reuse

```to_string(10)```  

```cpp
auto add(int x, int y)
{
	return x + y;
}

int main()
{
	// add()는 정수값을 반환하므로 sum은 int형이 된다
	auto sum = add(5, 6);
	return 0;
}
```

```cpp
if (int condition = get_status())
{
	// ...
}
```

```cpp
// function prototype
int spuare(int n);
int spuare(int);
```

```cpp
void modify(int& x, int& y)
{
	x = x * 2;
	y = y * 2;
}

int main()
{
	int a = 2, b = 3;
	modify(a, b);
	return 0;
}
```

함수의 시그니처 (매개변수개수, 타입, 순서)  

문자열 \> \< 사전순 비교  
크면 앞에 있는  

```cpp
cin.ignore(); // 엔터키 없애기
getline(cin, s);
get(cin, s);
```

```cpp
class Circle
{
	public:
	double calcArea();

	int radius;
	// ...
}

double Circle::calcArea()
{
	// ...
}
```

멤버 함수 이름 관례적으로 소문자, 동사 - 명사/형용사  

멤버 함수를 클래스 외부에 저장할 수 있는 기능  
멤버 함수를 클래스 외부에서 정의하려면 함수들의 원형(프로토타입)만 정의한다.  

:: 연산자는 이름공간 (namespace)를 지정하는 연산자  

```cpp
int value; // 선언과 정의
double sqrt (double); // 선언
double sqrt (double) { /* ... */ } // 선언과 정의
```

멤버 함수들을 외부에 정의하는것은 그 자체로도 상당한 의미가 있다.  
우리가 클래스를 작성하는 이유는 여러 소스 파일에서 이 클래스를 사용하기 위해서이다.  
다른 소스 파일에서 클래스를 사용하려면 클래스 선언을 포함하여야 한다.  

만약 하나의 파일에 클래스에 대한 모든 것이 들어 있다면, 상당한 양이 될 수 있다.  
따라서 대부분의 프로그래머들이 선호하는 방법을 클래스를 헤더 파일과 소스 파일로 나누어서 작성하는 방법이다.  

\+ 클래스를 사용하는 사람들은 클래스의 자세한 구현에는 관심이 없다  
클래스를 사용하는데 필요한 최소한의 정보만 있으면 된다.  
개발자 자신도 헤더를 여러 소스 파일에서 사용할 수도 있다  

```cpp
class SomeClass
{
	int hour;
	int m;
	SomeClass(int h, int n = 0) : hour(h), minute(m); // Initializer List 초기화 리스트
	{

	}
	SomeClass(int h, int n = 0) : hour{h}, minute{m}; // Initializer List 초기화 리스트
	{
		
	}
};

//생성자
SomeClass a; // X
SomeClass a(10, 25);// Old, 함수 생성과 혼동 가능성
SomeClass a { 10, 25 };
SomeClass a = { 10, 25 };

int i { 5 };
```

객체복사된다  
C#은 ref으로 들어가는데  
C++은 & 참조자 연산자 함수 인수에다 붙여야 한다  
C처럼 주소를 넘기지 않아도 된다  

객체 배열, 객체에 기본 생성자가 정의 되어 있어야 한다  

```int* p``` 포인터 선언용 *  
```p = &num;``` 주소 연산자 (참조자 연산자 아님)  
```a = *p;``` 간접 참조 연산자 Dereferecing, Indirection  

NULL == 0 (정수로 인식)  
nullptr  

동적 메모리 할당 Dynamic Memory Allocation  
히프에 할당받는 메모리  

요청 시 메모리가 부족하면 bad_alloc 오류 exception  

Smart Pointer  
동적 메모리 할당 후에 해제를 잊어도 자동으로 해제  
자동으로 nullptr 초기화  

```cpp
unique_ptr<int> p(new int); // new int : 포인터 초기화
unique_ptr<int[]> p(new int[]);
```

unique_ptr  
스마트 포인터의 일종  
기존 포인터를 감싼 객체  
객체가 삭제되면, 포인터가 가리키는 메모리 공간도 해제  
실행 시간의 부담이 전혀 없어서 타 언어 GC에 비하면 성능의 향상을 꾀할 수 있다  

@ TODO  
\* unique_ptr  
포인터에 대해 오직 하나의 소유자만 허용한다. shared_ptr이 필요하다는 점을 확실히 알지 못하는 경우에만 사용한다. 새 소유자로 이동할 수 있지만 복사하거나 공유할 수 없다. 노후된 auto_ptr을 대체한다.  

\* shared_ptr  
참조 횟수가 계산되는 스마트 포인터. 원시 포인터 하나를 여러 소유자에게 할당하려고 할 경우 사용한다. 원시 포인터는 모든 shared_ptr 소유자가 범위를 벗어나거나 소유권을 포기할 때까지 삭제되지 않는다.  

```cpp
const int *p1; // 포인터를 통해 참조되는 값이 바뀔 수 없음
int* const p2; // 상수 포인터, 참조하는 값이 바뀔 수는 있지만, 참조하는 주소가 바뀔 수 없음
const int* const p3; // 참조 값도, 참조하는 주소고 바뀔 수 없음

// const ~ * 객체 불변
// * ~ const 포인터 자체 불변
```

```cpp
int getRadius() const
{
	return radius;
}
// 함수안에서 멤버 변수를 변경하는 것이 금지됨

const SomeClass *pConstObj = new SomeClass();
pConstObj.getRaius();
// const 객체를 가리키는 포인터는, const 함수만 호출할 수 있다. (일반함수 호출 불가능)
}
```

```cpp
#include <utility>
pair<int, int> p;

{
	pair<int, int> p = make_pair(10, 13);
	pair<int, int> p = {4, 6}; // C++11
}

p.first
p.second

if (p1 < p2>) // 앞쪽 뒤쪽 비교
```
