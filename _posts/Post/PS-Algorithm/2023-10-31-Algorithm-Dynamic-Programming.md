---
title: "🌓 다이나믹 프로그래밍"
date: 2023-10-31. 14:16
# last_modified_at: 2023-11-16. 10:34
# last_modified_at: 2023-11-21. 13:52
last_modified_at: 2023-11-28. 13:36
categories: ⭐Computer 🌓PS-Algorithm
tags: Algorithm Dynamic-Programming DP
---

Dynamic Programming  
→ 동적 프로그래밍  
→ 동적 계획법  

미리 풀어놓고 저장하긴 하는데  
해답을 구할때 쓰일지 안쓰일지는 모름  

분할정복은 문제 자체를 나누고 푸는거라  
다 해답을 구할 때 쓰임  

중첩된 부문제 스탈이면 동적 계획법, 아니면 분할 정복  

Memoization - 메모이제이션  
분할정복의 장점/외관 (직관적이고 간결)  
동적계획법의 장점/내부 (성능 - 부문제 해답의 재사용)  
결합  

분할정복의 개선 or DP의 하향식 접근?  
(어느쪽을 개선시켰는가에 대한 의견이 있지만 일단은)  

메모리를 희생시켜 실행 시간의 이점을 얻음  

## 💫 0-1 배낭 문제

---

배낭에 어떤 물건을 담아야 최대 이익을 낼 수 있는지 알아내는 문제이다.  

- 문제의 이해
  - 배낭의 용량을 넘지 않으면서 배낭에 담을 수 있는 물건들의 최대 이익이 얼마인지(정확하게는 최대 이익을 얻어내기 위해 어떤 물건을 담아야 하는지)  알아내는 문제
  - 각 물건을 통째로 넣거나 아예 안 넣거나 택일
  - 물건의 무게에 양의 실수를 허용한다면 동적 계획법을 이용하는데 어려움이 있음 (why??)

n개의 물건 S = { Object<sub>1</sub>, ..., Object<sub>n</sub> }  
각 물건의 무게 W = { w<sub>1</sub>, ..., w<sub>n</sub> } (양의 정수)  
각 물건의 이익 P = { p<sub>1</sub>, ..., p<sub>n</sub> } (양의 정수)  

- 무작위 기법
  1. 가능한 모든 물건의 조합(2<sup>n</sup>개)을 구하고
  2. 배낭의 용량을 초과하는 조합은 모두 제외한 다음
  3. 남은 조합들 가운데 이익이 최대인 것을 찾음

- 최적 부분구조
  - 배낭 용량=M이고 최적해=K(n, M)일 때, 최적해 상태의 배낭을 관찰
    1. object<sub>n</sub>이 배낭에 없다: 애초에 object<sub>n</sub>이 없는 상태에서 문제를 풀어도 같은 결과. 즉 K(n, M)=K(n-1, M)
    2. object<sub>n</sub>이 배낭에 있다: 배낭에 object<sub>n</sub>을 미리 넣어둔 상태의 최적해와 동일. 즉 K(n, M)=K(n-1, M-w<sub>n</sub>)+p<sub>n</sub>
    - ∴ 최적 부분구조를 가짐
  - 두 조건에 따른 부문제의 최적해를 이용하면 원래 문제를 해결 가능
    - i.e. M=30, W={5, 10, 25}, P={150, 150, 200}이 주어졌을 때 최적해 K(3,30) ?
      -  3번째 물건이 최적해의 배낭에 포함되지 않는다는 가정하의 최적해인 K(2, 30)과 3번째 물건이 최적해의 배낭에 포함된다는 가정하의 최적해인 K(2, 5)+200  가운데 더 큰 값
  - 부문제를 정의하는 형식
    - 연속된 행렬 곱셈, 최적 이진 탐색 트리의 부문제는 시작과 끝이 매우 중요
      - i.e. 부문제 M<sub>i</sub>…M<sub>j</sub> 에서 조금씩 i와 j의 차를 늘려 최종적으로 M<sub>1</sub>…M<sub>n</sub>의 최적해를 구함
    - 동전 거스름돈 문제, 0-1 배낭 문제는 부문제의 한쪽 경계는 언제나 일정
      - i.e. 부문제 { object<sub>1</sub>, … , object<sub>i</sub> }에서 조금씩 i를 늘려 최종적으로 {object<sub>1</sub>, … , object<sub>n</sub>}에 대한 최적해를 구함
      - 부문제가 항상 K(1, j, m)으로 정의되기 때문에 상수 부분을 제외한 K(n, M)으로도 충분

- 문제의 순환적 정의
  - 최종 목표: 최대 이익을 가져다 주는 물건의 조합
  - 최우선 목표: 최대 이익
    - n개의 물건이 주어지고 배낭 용량이 M인 0-1 배낭 문제의 최적해 K(n, M)
      - object<sub>n</sub>이 배낭에 포함되지 않는다는 가정하의 최적해와 포함된다는 가정하의 최적해 중 더 큰 값
      - K(n, M) = Max { K(n - 1, M), K(n - 1, M - w<sub>n</sub>) + p<sub>n</sub> }
  - 일반화
    - i개의 물건이 주어지고 배낭 용량이 w인 0-1 배낭 문제의 최적해 K(i, w)
      - object<sub>i</sub>가 배낭에 포함되지 않는다는 가정하의 최적해와 포함된다는 가정하의 최적해 중 더 큰 값
      - 물건이 없거나 배낭 용량이 0  최적해가 0
      - objecti의 무게가 배낭의 용량을 넘어서는 상황  objecti가 최적해의 배낭에 포함되지 않을 경우만 고려
      - K(i, w) = 0, if (i = 0 or w = 0)
      - K(i, w) = K(i-1, w), if (w < w<sub>i</sub>)
      - K(i, w) = max(K(i-1, M), K(i-1, M-w<sub>i</sub>) + p<sub>i</sub>), o.w.

```c
// w[]와 p[]는 각 물건의 무게와 이익을 담은 배열
int DC_01_ks(int i, int w)
{
	if (i == 0 || w == 0) return 0;
	if (w < W[i]) return DC_01_ks(i-1,w);
	return max(DC_01_ks(i-1,w), DC_01_ks(i-1,w-W[i])+P[i]);
}
```

- 중첩된 부문제와 분할정복
  - 복잡도 ∝ 트리에 있는 노드 수 = 최대 ∑_(𝑙=0)^𝑛▒〖"2" 𝑙〗 = 최대 2^(n+1)-1 = O(2^n)
    - 무작위 기법 Ɵ(2n)과 비슷, but 실제로 호출되는 노드 수는 보통 이보다 적음
    - 알고리듬을 개선하면 단말 노드 호출을 없앨 수 있음
  - 중첩된 부문제 특성
    - 물건 개수가 많을수록 배낭 용량이 작을수록 부문제가 중복될 가능성이 커짐

@ 가방 공간이 적어서 계산하지 않는, 부문제가 하나 밖에 없는 케이스가 생길 수 있음  

동적 계획법으로 풀기 : 함수 대신 배열로  

@ 배열 B가 반드시 있어야 하나? 없어도됨 근데 일단 하던데로 계산하려고

PPT 배낭문제 13 14 15
y축 평행 이동으로 구하는 방법  

각 함수는 정렬된 정점 리스트  
원래는 최대한 많은 점을 기억해서 원래 함수의 모습을 기억하는 것이 좋은데, 게단식 그래프를 가지는 이런 상황에서는 단순히 점 몇 개 만을 기억하고도 x에 대한 y 값을 알아낼 수 있음  

각 물건에 대해서는, 각 함수에 물건의 무게와 가치를 평행이동한 것으로  

그리고 이전 함수와 평행 이동한 함수를 하나의 리스트로 합친다, 두 리스트는 정렬되어있다 (계단식) (정렬된 두 리스트를 하나로 합하기? => 합병 정렬)  

각 x와 y값을 비교,  
좌표 A와 B에 대해, x y가 둘 다 작은 좌표가 그래프에 그려지고,  
x나 y 중 하나만 작은 경우에는, A와 B 중 x가 더 큰 쪽에 정렬과정에서 제외가 된다 (왜냐하면 x가 더 작은 쪽이 그 x보다 큰 값도 설명할 수 있으니까)  

S<sub>0</sub>, 평행이동 SP<sub>0</sub>,  
합치고 S<sub>1</sub>, 평행이동 SP<sub>1</sub>,  
...  

'최악의 경우'가 붙으면 세타가 더 적절하다 O도 틀린 건 아니지만..  
최악의경우 세타와 그냥O는 같은 뜻인가? X

등차등비 

호프만코딩

다익스트라 

 최소신장트리, 가중치가 중복되는게 없다면 어떤 알고리듬써도 간선 모양 같음
 크러스컬 프림

퀵 안정적이지 않다, 는 무슨 의미냐면 똑같은 값의 순서가 그대로 유지되지 않는다

6.8 / 40 이게 점수인가?  
13.9 전체 평균  
14.4 중앙  
19 30% A  
7 70% B  

기말고사 20일쯤 시험  

단일 시작점 최단경로  
벨먼-포드 알고리듬  

- 문제의 이해: 단일 시작점 최단 경로를 찾는 알고리듬
  - 출발 지점으로부터 나머지 다른 모든 지점까지의 최단 경로를 찾는 문제
  - 음의 사이클(negative cycle)이 없어야 최단 경로를 찾을 수 있음 (실제 문제에서 음의 사이클이 있는지없는지 여부는 확신할 수 없음, 그래서 벨먼포드가 좋음, 여부를 확실히 몰라도 예방이 되니까)
  - 종류
    - 다익스트라 알고리듬
      - 욕심쟁이 방법을 사용하기 때문에 빠름
      - 그래프의 간선 가중치가 음수가 아니라고 가정 (범용성이 떨어짐)
    - 벨먼-포드 알고리듬(Bellman-Ford algorithm)
      - 동적 계획법을 사용
      - 음수의 간선 가중치를 갖는 그래프에 대해서도 정확하게 동작
      - 출발점에서 도달할 수 있는 음의 사이클이 존재하지 않는 한 정확한 최단 경로를 구하며 음의 사이클이 있다면 그 존재를 알려줌
- 무작위 기법: 2장 참조, n!
- 최적 부분구조: 2장 참조

음의 사이클  
A -( 1 )→ B -( 2 )→ C -( -3 )→  
돌떄마다 가중치가 무한히 작아짐  

## 💫 벨먼-포드 알고리듬 - Bellman-Ford Algorithm

---

포드이 먼저 만들었지만, 이를 개선한 벨먼이 더 네임드여서.  
포드 알고리듬이라고도 부름  

- 문제의 순환적 정의
  - 최종 목표: 시작 정점에서 각 정점으로의 최단 경로
  - 최우선 목표: 시작 정점에서 각 정점으로의 최단 경로의 길이
    - V ={1, …, n}, E가 주어졌을 때 출발점에서 정점 d까지 최단경로는 최대 n-1개 간선을 거침
    - 출발점에서 최대 n-1개 간선을 거쳐 정점 d에 도달하는 최단 경로의 길이는 다음 중 최소값
      - • 출발점에서 최대 n-2개 간선을 거쳐 정점 1에 도달하는 최단 경로 길이+<1,d> 가중치
      - • 출발점에서 최대 n-2개 간선을 거쳐 정점 2에 도달하는 최단 경로 길이+<2,d> 가중치
      - • …
      - • 출발점에서 최대 n-2개 간선을 거쳐 정점 n에 도달하는 최단 경로 길이+<n,d> 가중치
      - d도 1~n이라 중복되는 경우 (갔던 곳 또 가는 경우)가 있을 수잇음
    - 수학적 귀납법
      - 귀납 조항: 출발점에서 각 정점까지 최대 i-1개의 간선을 거치는 최단 경로를 안다면 출발점에서 각 정점까지 최대 i개의 간선을 거치는 최단 경로를 구할 수 있음
      - 기본 조항: 출발점에 대한 최단 경로는 0이고 나머지 정점들에 대한 최단 경로는 ∞
  - 출발점 s에서 최대 i개의 간선을 거쳐 정점 d에 도달하는 최단 경로의 길이를 D<sub>i</sub>(d)라 하고 간선 <v<sub>1</sub>, v<sub>2</sub>>의 가중치를 w(v<sub>1</sub>, v<sub>2</sub>)라 하면

원칙은 2차원인데, 뒤에 공부하다보면 1차원으로도 충분해짐 (i가 사라짐) 그래서 D<sub>i<sub>(d) 처럼 아래첨자로 i르 둠 

PPT 사진  

식 의미  
모든 간선들 중, k에서 d로 가는 간선들 중, 가장 짧은 놈을 대상으로..  

d가 10이라 치고, d와 이어진 정점이 2 3 6이라고 하면, k는 2, 3, 6이고 이중에서 가장 가중치가 짧은 놈이 대상  

min[D<sub>i-1<sub>(d) 는 없어도 되는데  
왜Why, 일단 더 길어질 수는 없어, 최적이었으닌까  
적어지면 최단 경로가 짧아진다
근데 이게 변하지 않을 수 있다!! = 기존 값을 유지할 수 있다!! 를 의미하기 위해 둔 것, 없어도 의미는 같음  

다익스트라 알고리듬에서 보았던 정의와 매우 유사(실제로 같은 정의, distance 배열 썻던것처럼)
각 간선 <k, d>를 n-1번 완화(relaxation: 더 나은 경로로 변경, 더 나은 경로를 찾는 것)

~번 완화 한다

@ TODO : 왜 e 지수..?

2차원 배열
x = 정점
y = 각 시행 (i-1, i, i+1, ...)
x, y = 거리

(1,5) 4  
(5,7) 6  

i-1 1=10 5=20 7=40
i 1=8 5=14 7=26
i+1 i= 5=12 7=20

어차피 값이 바뀌었으면 다음 시행 때 값이 갱신되는 것이 자명 (변경이 짧아지는 경우 밖에 없으니까)

그러면 계산할때 그냥 새로 갱신된 값을 기준으로 바로 계산 하자  
→ 변경되는 값을 기존거에 덮어쓰기 하자
→ 1차원 배열만 잇어도 된다

### 🫧 벨먼-포드 알고리듬_예시

n-1 만큼 루프를 돌리고, 한 번 더 기준 연산을 하는데, 또 줄어들면 그건 음의 사이클이다.  

### 🫧 벨먼-포드 알고리듬_개선

#### 어떤 순서로 처리하느냐에 따라 계산량이 줄 수 있다

A -(1)→ B -(1)→ C -(1)→ D -(1)→ E  
A를 시작점으로 할 때  

ㄱ) (D, E), (C, D), (B, C), (A, B)  
ㄴ) (A, B), (B, C), (C, D), (D, E)  

ㄱ은 마지막 반복까지 가서야 최단 경로가 결정  
ㄴ은 첫 반복 (한 번의 반복) 으로 최단경로가 결정  

따라서 배열에 더 변화가 없으면, 반복을 멈추고 알고리듬의 실행을 종료  
세타(ne) → O(ne)  

#### Moore의 SPFA (Shortest Path Faster Algorithm)

앞 단계와 현 단계에서 D[u]가 변경된 간선 (u, v)만 살펴본다.  
완화 횟수를 줄일 수 있다.  

## 💫 플로이드-웨셜 알고리듬 - Floyd-Warshall Algorithm

---

워셜이 먼저 만들었지만, 이를 개선한 플로이드가 더 네임드여서.  

- 문제의 이해: 모든 쌍 최단경로 알고리듬
  - 모든 지점들 간의 최단 경로를 알려줌
  - 유형
    1. 단일 시작점 최단 경로 알고리듬을 여러 번 반복
       - i.e. 벨먼-포드 알고리듬을 n번 반복: Ɵ(n^2 e), 고밀도 그래프의 경우 최대 Ɵ(n^4)
    2. 플로이드-워셜 알고리듬(Floyd-Warshall  algorithm)
       - 음의 가중치 간선을 허용하는 방향 그래프에서 모든 쌍 최단 경로를 Ɵ(n^3)에 찾음
       - 음의 사이클은 허용되지 않음
       - 기본 아이디어
         - 정점 V={1, 2, …, n}과 간선 E가 주어졌을 때 A와 B 두 정점간 최단 경로 길이
         - = 정점 {1, 2, …, n}에 속한 정점들을 가지고 만들 수 있는 최단 경로 길이
         - ≤ 정점 {1, 2, …, n-1}에 속한 정점들을 가지고 만들 수 있는 최단 경로 길이 (최단 경로가 n을 거치면 같고, Like 배낭문제)
         - …
         - ≤ 정점 {1, 2, …, k}에 속한 정점들을 가지고 만들 수 있는 최단 경로 길이
         - …
         - ≤ 정점 {1}에 속한 정점들을 가지고 만들 수 있는 최단 경로 길이
         - ≤ 정점 { }에 속한 정점들을 가지고 만들 수 있는 최단 경로 길이(아무 정점도 거치지 않음)
         - 주어진 문제의 크기가 가장 크고 점점 문제의 크기가 작아져서 가장 마지막에 있는 문제의 크기가 가장 작음 🡺 가장 작은 문제의 최적해로부터 점점 큰 문제의 최적해를 구할 수 있다면!!

모든 쌍 최단 경로는, 플로이드-워셜 알고리듬을 몰라도, 단일 시작점 최단 경로 알고리듬을 시작점을 다르게 n번 반복 시켜 풀 수는 있다. (n^4)  
그런데 플로이드-워셜 알고리듬을 쓰면 n^3으로 풀 수 있다.  

알고리듬.. 많이 알아야겠지?  

- 문제의 순환적 정의
  - 최종 목표: 모든 정점들 간의 최단 경로
  - 최우선 목표: 모든 정점들 간의 최단 경로 길이
    - 정점 i에서 정점 j까지(i∼>j) 최단 경로 길이
    - = 정점 {1, 2, …, n}에 속한 정점들만 거치는 i∼>j의 최단 경로 길이 D<sub>n</sub>(i, j)
    - = 다음 두 최단 경로 중 더 짧은 경로
    1. 정점 n을 안거치는/안쓰는 최단 경로
       - 정점 {1, 2, …, n-1}에 속한 정점들만 거치는 최단 경로
       - → D<sub>n-1</sub>(i, j)
    2. 정점 n을 거치는/쓰는 최단 경로
       - 정점 i에서 정점 n을 거쳐 정점 j에 도달하는 최단 경로, i ~> n ~> j
       - i∼>n도 최단 경로로 이동하고 n∼>j도 최단 경로로 이동해야 하므로 D<sub>n</sub>(i, n) + D<sub>n</sub>(n, j)
       - 이때, i∼>n의 최단 경로는 중간에 정점 n을 거치지 않음 (정점 수 : n-1)
       - 이때, n∼>j의 최단 경로는 중간에 정점 n을 거치지 않음 (정점 수 : n-1)
       - → D<sub>n</sub>(i, n) + D<sub>n</sub>(n, j) = D<sub>n-1</sub>(i, n) + D<sub>n-1</sub>(n, j)
  - 일반화
    - 정점 {1, 2, …, k}에 속한 정점만 거치는 i∼>j의 최단 경로 길이 Dk(i, j)
    - = 다음 두 최단 경로 중 더 짧은 경로
    1. 정점 k를 안거치는/안쓰는 최단 경로
       - 정점 {1, 2, …, k-1}에 속한 정점들만 거치는 최단 경로
       - → D<sub>k-1</sub>(i, j)
    2. 정점 k를 거치는/쓰는 최단 경로
       - i -{(1, 2, ..., k-1)에 속한 정점}→ k -{(1, 2, ..., k-1)에 속한 정점}→ j
       - i∼>k∼>j의 최단 경로
       - i∼>k와 k∼>j도 최단 경로로 이동해야 함:  D<sub>k</sub>(i, k) + D<sub>k</sub>(k, j)
       - 이때, i∼>k의 최단 경로는 중간에 정점 k를 거치지 않음 (정점 수 : k-1)
       - 이때, k∼>j의 최단 경로는 중간에 정점 k를 거치지 않음 (정점 수 	: k-1)
       - 🡺 D<sub>k</sub>(i, k) + D<sub>k</sub>(k, j) = D<sub>k-1</sub>(i, k) + D<sub>k-1</sub>(k, j)

D<sub>n</sub>(i, j)는 D(n, i, j)로 써도 되긴하는데, 이렇게 되면 3차원 배열을 써야하고, 3차원 배열은 다루기 복잡하니까  
상대적으로 다루기 쉬운 2차원 배열을 여러 개 만들어 쓰는 식으로 쓰기 위해 n을 아래첨자로 쓴다.  
Like 배낭 문제  

D<sub>n</sub>(i, j) = Min { D<sub>n-1</sub>(i, j), D<sub>n-1</sub>(i, n) + D<sub>n-1</sub>(n, j) }  

D<sub>n</sub>(i, j) =  
`if (k > 0)` Min { D<sub>n-1</sub>(i, j), D<sub>n-1</sub>(i, n) + D<sub>n-1</sub>(n, j) }  
`if (k == 0)` (i, j)의 가중치  

일반화시키면  
D<sub>k</sub>(i, j) = Min { D<sub>k-1</sub>(i, j), D<sub>k-1</sub>(i, k) + D<sub>k-1</sub>(k, j) }  

동적 계획법으로 만든다 = 배열로 만든다  
