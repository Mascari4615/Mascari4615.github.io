---
title: "🌓 Dynamic Programming"
date: 2023-10-31. 14:16
# last_modified_at: 2023-11-16. 10:34
# last_modified_at: 2023-11-21. 13:52
# last_modified_at: 2023-11-28. 13:36
# last_modified_at: 2023-11-30. 10:30
# last_modified_at: 2023-12-05. 15:54
last_modified_at: 2023-12-19. 01:09
categories: ⭐Computer 🌓PS-Algorithm
tags: Algorithm Dynamic-Programming DP
---

## 💫 Dynamic Programming (동적 프로그래밍, 동적 계획법)

---

부분제를 미리 풀고 저장해두긴 하는데, 이게 해답을 구할때 쓰일지 안쓰일지는 모름.  
아무튼 일단 미리 구해놓고 보는것이다.  

각 부문제의 해답을 풀어서 저장하고 나중에 같은 부문제의 답이 필요한 경우 저장된 해답을 찾아서 해결  

- 부문제를 이용한 다른 알고리듬
  - 욕심쟁이 방법: 각 단계에서 해답의 일부를 선택한 후 남은 부문제를 해결
  - 분할정복: 귀납적 정의를 이용하여 부문제로 분할, 정복, 결합

### 🫧 vs Divide-Conquer

분할정복은 문제 자체를 나누고 푸는거라, 풀어둔 것들이 나중에 해답을 구할 때 다 쓰인다.  
중첩된 부문제 스탈이면 동적 계획법, 아니면 분할 정복  

- 공통점
  - 순환적으로 정의된 문제로부터 출발

@ 4_0000  

- 중첩된 부문제 (Overlapping Subproblems) 특성
  - 부문제들이 심하게 중복되는 문제
  - DC : 같은 함수를 반복해서 순환 호출 (4_0000), 즉 부문제를 독립적으로 처리하기 때문에 동일한 부문제도 매번 새로 풀어야 함
  - DP : 동일한 부문제가 몇 번 등장하건 간에 한번만 풀면 되기 때문에, 중복된 부문제의 수가 증가하면 할수록 유리
  - 부문제가 중복되지 않는 문제 : DP의 장점이 의미가 없고, 오히려 최종 해답에 쓰이지 않을 답을 미리 계산하느라 많은 시간을 낭비

- DC
  - 적합한 예: 합병정렬, 퀵정렬
    - 부문제들이 중복되지 않음: 중첩된 부문제 특성이 없음
  - 큰 문제를 작은 문제로 쪼갠 후 부문제를 해결하려는 전략 → 하향식

- DP
  - 적합한 예: 피보나치 수열 계산
    - 부문제들이 심하게 중복: 중첩된 부문제 특성을 가짐
  - 부문제를 풀고 이를 이용하여 더 큰 문제를 해결하는 전략 → 상향식

```cs
int IterativeFib(int n)
{
	int[] fib = new int[MAX_SIZE];
	fib[0] = 0;
	fib[1] = 1;
	for (int i = 2; i <= n; i++)
		fib[i] = fib[i - 1] + fib[i - 2];
	return fib[n];
}
```

### 🫧 vs Greedy

- 공통점: 최적 부분 구조를 갖는 최적화 문제를 해결

최적해 : 최고 좋은 해답  

- 그리디
  - 최적해를 보장한다는 증명만 되면 가장 효율적
  - 최적해의 일부를 먼저 선택한 후 남은 부문제를 해결하려는 전략 → 하향식

- 동적 계획법
  - 일반적인 문제 + 최적화 문제: 범용성
  - 문제를 해결하기 위한 모든 대안들의 답을 구하고 그 가운데 최적의 해답을 찾음 → 지능적인 무작위 기법, 상향식

### 🫧 동적 계획법의 적용

- ➊ 최적화 문제의 경우 최적 부분구조를 갖는지 검증
- ➋ 문제를 순환적으로 정의
- ➌ 중첩된 부문제 특성을 갖는지 조사
- ➍ 부문제의 해답을 저장하고 이로부터 최적해를 구성하는 알고리즘을 구축

### 🫧 Memoization

[Memoization](https://mascari4615.github.io/posts/Algorithm-Memoization/)  

## 💫 벨먼-포드 알고리듬 - Bellman-Ford Algorithm

---

포드이 먼저 만들었지만, 이를 개선한 벨먼이 더 네임드여서.  
포드 알고리듬이라고도 부름  

- 문제의 순환적 정의
  - 최종 목표: 시작 정점에서 각 정점으로의 최단 경로
  - 최우선 목표: 시작 정점에서 각 정점으로의 최단 경로의 길이
    - V ={1, …, n}, E가 주어졌을 때 출발점에서 정점 d까지 최단경로는 최대 n-1개 간선을 거침
    - 출발점에서 최대 n-1개 간선을 거쳐 정점 d에 도달하는 최단 경로의 길이는 다음 중 최소값
      - • 출발점에서 최대 n-2개 간선을 거쳐 정점 1에 도달하는 최단 경로 길이+<1,d> 가중치
      - • 출발점에서 최대 n-2개 간선을 거쳐 정점 2에 도달하는 최단 경로 길이+<2,d> 가중치
      - • …
      - • 출발점에서 최대 n-2개 간선을 거쳐 정점 n에 도달하는 최단 경로 길이+<n,d> 가중치
      - d도 1~n이라 중복되는 경우 (갔던 곳 또 가는 경우)가 있을 수잇음
    - 수학적 귀납법
      - 귀납 조항: 출발점에서 각 정점까지 최대 i-1개의 간선을 거치는 최단 경로를 안다면 출발점에서 각 정점까지 최대 i개의 간선을 거치는 최단 경로를 구할 수 있음
      - 기본 조항: 출발점에 대한 최단 경로는 0이고 나머지 정점들에 대한 최단 경로는 ∞
  - 출발점 s에서 최대 i개의 간선을 거쳐 정점 d에 도달하는 최단 경로의 길이를 D<sub>i</sub>(d)라 하고 간선 <v<sub>1</sub>, v<sub>2</sub>>의 가중치를 w(v<sub>1</sub>, v<sub>2</sub>)라 하면

원칙은 2차원인데, 뒤에 공부하다보면 1차원으로도 충분해짐 (i가 사라짐) 그래서 D<sub>i<sub>(d) 처럼 아래첨자로 i르 둠 

PPT 사진  

식 의미  
모든 간선들 중, k에서 d로 가는 간선들 중, 가장 짧은 놈을 대상으로..  

d가 10이라 치고, d와 이어진 정점이 2 3 6이라고 하면, k는 2, 3, 6이고 이중에서 가장 가중치가 짧은 놈이 대상  

min[D<sub>i-1<sub>(d) 는 없어도 되는데  
왜Why, 일단 더 길어질 수는 없어, 최적이었으닌까  
적어지면 최단 경로가 짧아진다
근데 이게 변하지 않을 수 있다!! = 기존 값을 유지할 수 있다!! 를 의미하기 위해 둔 것, 없어도 의미는 같음  

다익스트라 알고리듬에서 보았던 정의와 매우 유사(실제로 같은 정의, distance 배열 썻던것처럼)
각 간선 <k, d>를 n-1번 완화(relaxation: 더 나은 경로로 변경, 더 나은 경로를 찾는 것)

~번 완화 한다

@ TODO : 왜 e 지수..?

2차원 배열
x = 정점
y = 각 시행 (i-1, i, i+1, ...)
x, y = 거리

(1,5) 4  
(5,7) 6  

i-1 1=10 5=20 7=40
i 1=8 5=14 7=26
i+1 i= 5=12 7=20

어차피 값이 바뀌었으면 다음 시행 때 값이 갱신되는 것이 자명 (변경이 짧아지는 경우 밖에 없으니까)

그러면 계산할때 그냥 새로 갱신된 값을 기준으로 바로 계산 하자  
→ 변경되는 값을 기존거에 덮어쓰기 하자
→ 1차원 배열만 잇어도 된다

### 🫧 벨먼-포드 알고리듬_예시

n-1 만큼 루프를 돌리고, 한 번 더 기준 연산을 하는데, 또 줄어들면 그건 음의 사이클이다.  

### 🫧 벨먼-포드 알고리듬_개선

#### 어떤 순서로 처리하느냐에 따라 계산량이 줄 수 있다

A -(1)→ B -(1)→ C -(1)→ D -(1)→ E  
A를 시작점으로 할 때  

ㄱ) (D, E), (C, D), (B, C), (A, B)  
ㄴ) (A, B), (B, C), (C, D), (D, E)  

ㄱ은 마지막 반복까지 가서야 최단 경로가 결정  
ㄴ은 첫 반복 (한 번의 반복) 으로 최단경로가 결정  

따라서 배열에 더 변화가 없으면, 반복을 멈추고 알고리듬의 실행을 종료  
세타(ne) → O(ne)  

#### Moore의 SPFA (Shortest Path Faster Algorithm)

앞 단계와 현 단계에서 D[u]가 변경된 간선 (u, v)만 살펴본다.  
완화 횟수를 줄일 수 있다.  

## 💫 정리

---

- 정리
  - 최적 부분구조를 갖는 최적화 문제를 해결하는데 사용
  - 특히 부문제가 중첩되는 정도가 높을수록 유용
  - 크기 별로 가능한 모든 문제를 미리 풀어놓고 재사용하기 때문에 지능화된 무작위 기법이라는 별칭

중첩도가 높으면, 부문제가 똑같은 걸 많이 쓰면, 미리 다 풀어두고 쓰는 동적 계획법  
낮으면 미리 풀어둔 부문제를 안써서 효율이 낮으니까, 차라리 분할정복을 고려해볼것  

- 기타 예제
  - 데이터의  유사성을  알아내는데  유용한  최장  공통  부분순서 (longest common subsequence) 문제
  - 2장에서 다룬 여행하는 외판원 문제
  - 음성 인식이나 합성에서 사용되는 비터비(Viterbi) 알고리즘
