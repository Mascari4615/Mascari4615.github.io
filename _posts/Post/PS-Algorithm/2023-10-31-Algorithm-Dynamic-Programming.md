---
title: "🌓 다이나믹 프로그래밍"
date: 2023-10-31. 14:16
last_modified_at: 2023-11-16. 10:34
categories: ⭐Computer 🌓PS-Algorithm
tags: Algorithm Dynamic-Programming DP
---

Dynamic Programming  
→ 동적 프로그래밍  
→ 동적 계획법  

미리 풀어놓고 저장하긴 하는데  
해답을 구할때 쓰일지 안쓰일지는 모름  

분할정복은 문제 자체를 나누고 푸는거라  
다 해답을 구할 때 쓰임  

중첩된 부문제 스탈이면 동적 계획법, 아니면 분할 정복  

Memoization - 메모이제이션  
분할정복의 장점/외관 (직관적이고 간결)  
동적계획법의 장점/내부 (성능 - 부문제 해답의 재사용)  
결합  

분할정복의 개선 or DP의 하향식 접근?  
(어느쪽을 개선시켰는가에 대한 의견이 있지만 일단은)  

메모리를 희생시켜 실행 시간의 이점을 얻음  

## 💫 0-1 배낭 문제

---

배낭에 어떤 물건을 담아야 최대 이익을 낼 수 있는지 알아내는 문제이다.  

n개의 물건 S = { Object<sub>1</sub>, ..., Object<sub>n</sub> }  
각 물건의 무게 W = { w<sub>1</sub>, ..., w<sub>n</sub> } (양의 정수)  
각 물건의 이익 P = { p<sub>1</sub>, ..., p<sub>n</sub> } (양의 정수)  

  - 각 물건을 통째로 넣거나 아예 안 넣거나 택일
  - 물건의 무게에 양의 실수를 허용한다면 동적 계획법을 이용하는데 어려움이 있음 (why??)

- 무작위 기법
  1) 가능한 모든 물건의 조합(2^n개)을 구하고
  2) 배낭의 용량을 초과하는 조합은 모두 제외한 다음
  3) 남은 조합들 가운데 이익이 최대인 것을 찾음

- 최적 부분구조
  - 배낭 용량=M이고 최적해=K(n, M)일 때, 최적해 상태의 배낭을 관찰
    - ➊ objectn이 배낭에 없다: 애초에 objectn이 없는 상태에서 문제를 풀어도 같은 결과. 즉 K(n, M)=K(n-1, M) 
    - ➋ objectn이 배낭에 있다: 배낭에 objectn을 미리 넣어둔 상태의 최적해와 동일. 즉 K(n, M)=K(n-1, M-wn)+pn 
    -  최적 부분구조를 가짐
  - 두 조건에 따른 부문제의 최적해를 이용하면 원래 문제를 해결 가능
    - 예) M=30, W={5, 10, 25}, P={150, 150, 200}이 주어졌을 때 최적해 K(3,30) ?
      -  3번째 물건이 최적해의 배낭에 포함되지 않는다는 가정하의 최적해인 K(2, 30)과 3번째 물건이 최적해의 배낭에 포함된다는 가정하의 최적해인 K(2, 5)+200  가운데 더 큰 값
  - 부문제를 정의하는 형식
    - 연속된 행렬 곱셈, 최적 이진 탐색 트리의 부문제는 시작과 끝이 매우 중요
      - 예) 부문제 Mi…Mj 에서 조금씩 i와 j의 차를 늘려 최종적으로 M1…Mn의 최적해를 구함
    - 동전 거스름돈 문제, 0-1 배낭 문제는 부문제의 한쪽 경계는 언제나 일정
      - 예) 부문제 {object1, … , objecti}에서 조금씩 i를 늘려 최종적으로 {object1, … , objectn}에 대한 최적해를 구함
      - 부문제가 항상 K(1, j, m)으로 정의되기 때문에 상수 부분을 제외한 K(n, M)으로도 충분

- 문제의 순환적 정의
  - 최종 목표: 최대 이익을 가져다 주는 물건의 조합
  - 최우선 목표: 최대 이익
    - 물건 수 n, 배낭 용량이 M, 최적해 K(n, M)
      - object<sub>n</sub>이 배낭에 포함되지 않는다는 가정하의 최적해와 포함된다는 가정하의 최적해 중 더 큰 값
      - K(n, M) = max(K(n-1, M), K(n-1, M-w<sub>n</sub>) + p<sub>n<sub>)
    - 일반화: i개의 물건이 주어지고 배낭 용량이 w인 0-1 배낭 문제의 최적해 K(i, w)
      - objecti가 배낭에 포함되지 않는다는 가정하의 최적해와 포함된다는 가정하의 최적해 중 더 큰 값
      - 물건이 없거나 배낭 용량이 0  최적해가 0
      - objecti의 무게가 배낭의 용량을 넘어서는 상황  objecti가 최적해의 배낭에 포함되지 않을 경우만 고려
      - K(i, w) = 0, if (i = 0 or w = 0)
      - K(i, w) = K(i-1, w), if (w < w<sub>i</sub>)
      - K(i, w) = max(K(i-1, M), K(i-1, M-w<sub>i</sub>) + p<sub>i<sub>), o.w.

```c
// w[]와 p[]는 각 물건의 무게와 이익을 담은 배열
int DC_01_ks(int i, int w)
{
	if (i == 0 || w == 0) return 0;
	if (w < W[i]) return DC_01_ks(i-1,w);
	return max(DC_01_ks(i-1,w), DC_01_ks(i-1,w-W[i])+P[i]);
}
```

- 중첩된 부문제와 분할정복
  - 복잡도 ∝ 트리에 있는 노드 수 = 최대 ∑_(𝑙=0)^𝑛▒〖"2" 𝑙〗 = 최대 2^(n+1)-1 = O(2^n)
    - 무작위 기법 Ɵ(2n)과 비슷, but 실제로 호출되는 노드 수는 보통 이보다 적음
    - 알고리즘을 개선하면 단말 노드 호출을 없앨 수 있음
  - 중첩된 부문제 특성
    - 물건 개수가 많을수록 배낭 용량이 작을수록 부문제가 중복될 가능성이 커짐

@ 가방 공간이 적어서 계산하지 않는, 부문제가 하나 밖에 없는 케이스가 생길 수 있음  

동적 계획법으로 풀기 : 함수 대신 배열로  

@ 배열 B가 반드시 있어야 하나? 없어도됨 근데 일단 하던데로 계산하려고
