---
title: "🌓 Back Tracking"
date: 2023-12-05. 13:36
last_modified_at: 2023-12-07. 10:29
categories: ⭐Computer 🌓PS-Algorithm
tags: Algorithm Back-Tracking
---

## 💫 Back Tracking

---

Like 보물찾기  

어딘가 숨어 있는 보물(해답)을 찾는 것  
보물을 찾으려면 힌트가 있는 지도(Map)가 있어야함  

모든 곳을 뒤져봐도 되지만,  
보다 빨리, 효울적으로 찾아보자는 것  

보물을 찾아내는 전략이 중요 (전략에 따라 백트래킹의 효율이)  
i.e. 보물이 있을 만한 곳만 찾아본다던지 (없는 곳은 패스)  

`Backtracking - 되돌아간다`  
되돌아가거나 되짚어 가려면, 이미 지나온 길이 당연히 반드시 존재  
Why, 더 이상 이 길로 갈 수가 없거나 (필요가 없나), 이미 다 가본 길  
(지나간 길을 기억)  
So, 되돌아가서 새로운 길을 찾기 위함  

i.e. 미로 찾기  
출구룰 찾을 때까지 다음 반복  

1. 분기점이 나올 때까지 길을 따라 간다. 이 때 지나가는 길은 표시
2. 분기점을 만나면 한 길을 선택하여 역시 표시하면서 계속 진행
3. `길이 막혀 있으면 직전 분기점으로 되돌아감`
4. 시도하지 않은 다른 길을 선택하여 1 시작
5. `모든 길을 시도하였다면 직전 분기점까지 되돌아가고, 4 시작`

백트래킹은 어떤 일을 한 이후에 그 일을 되물리는(Undo, 없던 일로) 것까지 포함  

i.e. 깊이우선탐색 DFS  
노드를 방문하고 기록, 아직 방문하지 않은 자식 노드들에 대해 다시 DFS  
더 이상 방문할 자식 노드가 없으면, 부모 노드로 돌아감 (Backtracking)  

`지도`  
결론적으로 모든 지도는 Tree로 나타냄, Tree를 따라다니며 해결  
Tree를 구성하는 노드들을, `상태`  

### 🫧 핵심

1. 트리를 어떻게 만들거냐/모델링 할거냐
2. 전략을 세우는 일 (전체 트리 중에 안 방문해도 되는 서브트리/노드 발굴)

## 💫 상태 State

---

`상태 State`  
시작해서 주어진 문제를 해결하는 과정 중을 특정 순간, 스냅샷을 상태로 (물론 의미있게 구분되는 순간)  

i.e. 0-1 배낭 문제 : 어떤 한 순간의 배낭 모습 (어떤 물건이 들어있고 총 뭄게의 이익은 얼마인가)  
i.e. 바둑/체스/오목/틱택토 등 턴제 보드 게임 : 어떤 한 순간의 바둑판/체스판/판 모습  

1. 시작 상태에서 출발
   - i.e. 0-1 배낭 문제 : 빈 배낭
2. 주어진 규칙에 따라 상태를 계속해서 변화
   - i.e. 0-1 배낭 문제 : 해당 물건을 집어넣거나 집어넣지 않거나를 결정할 때마다 (상태가 변화)
3. 최종 상태
   - i.e. 0-1 배낭 문제 : 모든 물건에 대한 결정이 끝난 상태
   - i.e. 오목 : 누가 승리한 상태
4. 원하는 해답인 최종 상태일 수도 있고, 해답이 아닌 최종 상태도 가능
   - i.e. 0-1 배낭 문제 : 이익이 최대인 최종 상태와 그보다는 작은 최종 상태
   - i.e. 오목 : 우리편이 이긴 최종 상태와 상대방이 이긴 최종 상태

최종상태는 `후보해 Candidate Solution`라 부르기도 함  
주의 : 대부분은 최종 상태에 해답이 있는데, 어떤 문제는 최종 상태가 아니더라도 해답을 찾을 수 있음  

## 💫 상태 공간 트리 - State Space, Prolem Space

---

@ 미래 루트 짤  

가능한 모든 상태를 트리로 묶어 낸 것  
각 상태는 이전 상태로부터 변한 것이고, 이후 상태로 변화해나감  
시작 상태에서 출발하여 전이(Transition)가 가능한 이후 상태를 자식 노드로 연결하고 이 과정을 최종 상태에 이르기까지 반복 -> 상태 공간 트리  

노드 : 상태, 부모 노드 : 이전 상태, 자식 노드 : 이후 상태  

i.e. 0-1 배낭 문제의 상태 공간 트리  
`1', 2`, `1', 2, 3'`, `1', 2, 3', 4'` 는 배낭 모양은 똑같지만 (물건 2만 들어가 있지만), 서로 다른 상태  

유망하지 않은 노드(Nonpromising Node) : 자식의 상태를 확인할 필요가 없음 (거기로 가봐야 보물이 없어, 답이 없어, 난가?)  
유망한 노드 (Promising Node) : 해답을 얻기 위해 자식 노드로 진행할 필요가 있음 (요오망한 노드 ㄷㄷ; 미래가 창창한, 가능성이 있는)  

`유망하지 않은 노드를 가능한 많이 걸러내는 전략이 매우 중요 - 가지치기 Proning`  
@ 노답들을 쳐내는 객관안  

## 💫 코드 구조와 최적화

---

상태 공간 트리의 탐색 : DFS  
그래프 DFS를 수정하면 트리 DFS를 구할 수 있음  

(이진트리에서) 전위순회 = DFS  
근데 문제 일반적으로 이진트리가 아니라서 이진 트리의 전위 순회를 트리의 전위 순회로 일반화, 가장 왼쪽/오른쪽에 있는 노드 부터  

Why DFS, Not BFS?  
최종 단계, 답이 일반적으로 최종 노드/말단 노드에 있기 때문에, 하나라도 빨리 말단 노드까지 가서 답인지 아닌지 확인해보는게 빠름  

그리고 상태를 쓰기 때문  
이전 상태를 기억해야 하는데, BFS는 이전 상태가 아닌 정보도 기억해야 됨 - 비효율  
DFS에서는 이게 명확하기 때문에 효율적이기도 하고 보다 자연스러움  
모든 자식 노드는 이전에 방문하지 않은 노드이고, 자식 노드만을 대상으로 DFS가 이루어지기 때문에 노드를 방문했다는 사실을 기억하거나 확인할 필요가 없음  

상태 공간 트리 탐색을 효율적으로 하기 위해  
상탵 변화를 추적하기 용이한  

1. 유망하지 않은 노드 걸러내기 Pruning 가지치기
2. 유망한 노드에 대해서만 순환호출(Backtracking)

```cs
// 백트래킹의 공통된 구조
void Backtracking(Node v)
{
	if (Promising(v)) // 1. 요망한 놈에 대해서만 (가지치기, Pruning)
		return;

	if (IsSolution(v)) // 해답이라면 ?
	{
		OutputSolution(v); // 끝 (진행을 끝내는 코드가 생략됨)
	}
	else // 해답이 아니라면 ?
	{
		// 2. (요망한 놈에 대해서만 Backtracking하는 코드가 생략됨)
		foreach (var child in v.Childs)
			Backtracking(child);
	}
}
```

근데 트리를 만드는 과정이 너무 오래 걸림 (이진트리일때, 2^n), 그리고 트리가 너무 큼 (메모리 낭비)  
So, 실제 구현에서는 트리를 안만들고 시작한다 (대안)  

각 레이어/레벨에서 기억해야 할 정보는 넣었냐 안넣었냐 정보 딱 하나  
따라서 각 단계마다, 현재 레이어/레벨에 들어갈 정보 하나를 넣음  
그래서 각 레이어/레벨을 오르락 내리락하면서 답을 찾음 -> 필요한 데이터를 저장하기 위해서는 레이어 높이 만큼의 1차원 배열 하나만 있으면 됨  

@ PPT  

- 주의
  1) 메모리 낭비를 줄이기 위해 순환 함수를 호출할 때 값이 변하는 변수만 파라미터로 넘기고 순환호출에서 변하지 않는 변수는 전역 변수로 선언
  2) 백트래킹 알고리즘에서는 실제로 상태 공간 트리를 만드는 것이 아니라 탐색하는 노드의 상태를 배열에 기록하고 추적
     - 상태 공간 트리의 탐색 과정을 배열을 이용하여 시뮬레이션
     - 유망한 노드에 대해서만 배열에 기록하는 작업이 필요

## 💫 이용

---

[N-Queen](https://mascari4615.github.io/posts/N-Queen/)  

해밀턴 사이클 @ 강의에서 패스  

