---
title: "🌓 Baekjoon 7569 - '토마토'"
date: 2024-02-24. 18:56
# last_modified_at: 2024-02-24. 18:56
categories: [⭐Computer, 🌓PS-Algorithm]
tags: [PS, Baekjoon, BFS, Breadth-First-Search]
---

## **💫 [문제](https://www.acmicpc.net/problem/7569)**

---

### **🫧 Example Input/Output 1**

```cpp
// In
5 3 1 // m, n, h
0 -1 0 0 0
-1 -1 0 1 1
0 0 0 1 1

// Out
-1 // 토마토가 모두 익는 최소 날짜, 모두 익지 못한다면 -1
```

<br>
<!-- ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ---- -->

### **🫧 Example Input/Output 2**

```cpp
// In
5 3 2
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 1 0 0
0 0 0 0 0

// Out
4
```

<br>
<!-- ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ---- -->

### **🫧 Example Input/Output 3**

```cpp
// In
4 3 2
1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1
-1 -1 -1 -1
1 1 1 -1

// Out
0
```

<br>
<!-- ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ---- -->

## **💫 C++ 풀이**

---

```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <tuple>
using namespace std;

int board[105][105][105];
int day[105][105][105];

int dx[6]{1, -1, 0, 0, 0, 0};
int dy[6]{0, 0, 1, -1, 0, 0};
int dz[6]{0, 0, 0, 0, 1, -1};

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int n, m, h;
	cin >> m >> n >> h;

	queue<tuple<int, int, int>> q;

	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			fill(day[i][j], day[i][j] + h, -1);

	for (int k = 0; k < h; k++)
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
			{
				cin >> board[i][j][k];

				if (board[i][j][k] == 1)
				{
					day[i][j][k] = 0;
					q.push({i, j, k});
				}
			}

	while (q.empty() == false)
	{
		tuple<int, int, int> cur = q.front();
		q.pop();

		for (int k = 0; k < 6; k++)
		{
			int newX = get<0>(cur) + dx[k];
			int newY = get<1>(cur) + dy[k];
			int newZ = get<2>(cur) + dz[k];

			if (newX < 0 || newX >= n || newY < 0 || newY >= m || newZ < 0 || newZ >= h)
				continue;
			if ((day[newX][newY][newZ] > -1) || (board[newX][newY][newZ] == -1))
				continue;

			day[newX][newY][newZ] = day[get<0>(cur)][get<1>(cur)][get<2>(cur)] + 1;
			q.push({newX, newY, newZ});
		}
	}

	int maxDay = 0;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			for (int k = 0; k < h; k++)
			{
				if ((board[i][j][k] == 0) && (day[i][j][k] == -1))
				{
					cout << -1;
					return 0;
				}

				if (maxDay < day[i][j][k])
					maxDay = day[i][j][k];
			}

	cout << maxDay;
}
```

<br>
<!-- ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ---- -->

## **💫 Memo**

---

- 2차원 배열로 풀 수 있었던 기존 [토마토](https://mascari4615.github.io/posts/Baekjoon-7576/) 문제 풀이에서, 단순히 2차원 배열을 3차원 배열로 바꿔 풀었다.
- C++ `tuple` 을 배웠다.

<br>
<!-- ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ---- -->
