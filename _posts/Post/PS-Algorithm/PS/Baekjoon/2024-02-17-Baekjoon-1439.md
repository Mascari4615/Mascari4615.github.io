---
title: "🌓 Baekjoon 1439 - '뒤집기'"
date: 2024-02-17. 20:27
# last_modified_at: 2024-02-17. 20:27
categories: [⭐Computer, 🌓PS-Algorithm]
tags: [PS, Baekjoon, String, Greedy]
---

## **💫 [문제](https://www.acmicpc.net/problem/1439)**

---

### **🫧 Example Input**

```cpp
1100110001111
```

<br>

<!-- ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ---- -->

### **🫧 Example Output**

```cpp
2
```

<br>

<!-- ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ---- -->

## **💫 C++ 풀이**

---

```cpp
#include <iostream>

using namespace std;

// 숫자가 두 번 변화하면 (두 번 바뀌어 원래 숫자로 돌아오면)
// 카드를 한 번 뒤집어야 한다

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	string s;
	cin >> s;

	// MISS
	// lastNum을 '0', '1'이 아닌 다른 문자로 초기화 했으면, cout 할 때 numChangeCount에 1을 더해줄 필요가 없다.
	char lastNum = s[0];
	int numChangeCount = 0;

	for (int i = 0; i < s.length(); i++)
	{
		if (lastNum != s[i])
		{
			lastNum = s[i];
			numChangeCount++;
		}
	}

	// MISS
	// 홀수 체크할 필요 없이, 그냥 cout << (numChangeCount + 1) / 2 했어도 됐다.
	if (numChangeCount % 2 == 1)
		cout << (numChangeCount + 1) / 2;
	else 
		cout << numChangeCount / 2;
}
```

<br>

<!-- ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ----  ---- ---- ---- ---- -->

## **💫 Memo**

---

1. 똑같은 숫자 뭉탱이를 압축하고
   - i.e. 1100110001111 -> 10101
2. Min(0 개수, 1 개수)

- 남의 풀이 : Replace, Split
  - `0Count = Replace("0", " ").Split.Length`
  - `1Count = Replace("1", " ").Split.Length`
  - `Min(0Count, 1Count)`
