---
title: "🌓 Binary-Search-Tree"
date: 2024-02-19. 20:52
last_modified_at: 2024-07-15. 06:12
categories: [⭐Computer, 🌓PS-Algorithm]
tags: [Data-Stucture, Tree, Binary-Tree, Binary-Search-Tree, Self-Balancing-Tree]
---

{% include embed/youtube.html id='IKnjzmyk70U' %}
{% include embed/youtube.html id='nehRy6hAJsA' %}

## **💫 Binary-Tree**

---

각 노드의 자식이 2개 이하인 트리  
자식이 2개 이하이기 때문에 자식을 왼쪽과 오른쪽으로 구분할 수 있다.  

## **💫 Binary-Search-Tree**

---

자가 균형 트리가 아니라면 이진 검색 트리는 시간복잡도가 안 좋아서 써먹을 수 없다.  
그런데 자가 균형 트리는 구현이 어렵다.  
STL을 이용하자.  

만약 STL을 쓰지 못하는 상황이라면?  
어떻게든 해시나 이분 탐색 같은, 이진 검색 트리를 쓰지 않는 다른 풀이를 찾아야 한다.  
구현 자체도 실수할 여지가 많고, 자가 균형 트리가 아니라면 시간복잡도가 안좋아서 높은 확률로 시간 초과가 발생한다.  

Binary-Search-Tree | 이진 탐색 트리  

왼쪽 서브트리의 모든 값은 부모의 값보다 작고,  
오른쪽 서브트리의 모든 값은 부모의 값보다 큰,  
이진 트리  

이진 탐색 개념을 그래프의 트리 구조 사용하여 표현  
마찬가지로 각 노드는 최대 두 개의 자식 노드를 가짐  

### 왜?

탐색, 삽입, 삭제 연산을 O(logN)에 할 수 있기 때문  

배열은 insert는 제일 뒤에 붙이면 되니 O(1)이라고 해도, erase는 배열 중간에 있는 원소가 제거될 상황이 나올 수 있으니 O(N), find, update도 O(N)이다.  
그런데 이진 탐색 트리는 O(logN)이다.  
때문에 erase, find, update가 많은 상황에서는 이진 탐색 트리를 쓰는 것이 좋다.  

해시는 비록 충돌 때문에 성능이 안 좋아질 수 있지만, 저 4개의 연산이 O(1)이긴한데,  
해시에는 없는 이진 검색 트리의 강력한 특징은 원소가 크기 순으로 정렬되어 있다는 것이다.  

1, 3, 5, 7,9를 해시에 넣었다고 가정.  
5보다 큰 최초의 원소가 무엇인지 찾으라고 하면, 해시는 O(N)이다.  
그러나 이진 검색 트리는 O(logN)이다.  

때문에 insert, erase, find, update 등이 빈번하면서, 동시에 뭔가 원소의 대소와 관련한 성질이 필요한 경우에는 이진 검색 트리를 사용해야 한다.  

### 성질

- 모든 노드는 왼쪽 가지에 포함되는 어떤 숫자보다 큰 숫자
- 모든 노드는 오른쪽 가지에 포함되는 어떤 숫자보다 작은 숫자
- -> 따라서 최상단 노드로부터 왼쪽 가지만 쭉 따라가면 최소노드 (최솟값)이 나옴
- -> 따라서 최상단 노드로부터 오른쪽 가지만 쭉 따라가면 최대노드 (최댓값)이 나옴

### Binary-Search-Tree 구현

#### 추가/삽입 Insert

1. 루트부터
2. 추가하려는 노드가 현재 노드 값과 비교해서 작으면 왼쪽, 크면 오른쪽으로 진행
3. 더 이상 비교할 수 없으면 정착 (비어있는 곳에 새로 추가해야 하는 상황)

#### 탐색 Find/Search

1. 루트부터
2. 찾으려는 숫자가 현재 노드와 비교해서 작으면 왼쪽으로, 크면 오른쪽으로 진행

탐색, 추가할 때의 최적의 위치는 찾는 과정,  
트리의 높이 (깊이 또는 단계) 만큼만 비교하면 되므로 노드가 n개 있고 트리가 균형잡힌 경우라면 최대 Log<sub>2</sub>N회의 비교로 이동할 수 있습니다.  

단, 트리가 치우쳐서 직선에 가까운 모양인 경우에는 트리가 높아져서 O(N)이 될 수도 있음  

#### 삭제 Erase

1. 자식 노드가 없으면 대상 노드만 삭제하면 끝
2. 자식 노드가 하나면 자식 노드를 기존 노드 위치로 이동
3. 자식 노드가 두 개 이상이면
   - 삭제한 노드의 왼쪽 가지에서 최대 (기존 노드 값보다 작은 것들 중 가장 큰) 노드를 찾아 기존 노드 위치로 이동
   - 혹은 삭제한 노드의 오른쪽 가지에서 최소 (기존 노드 값보다 큰 것들 중 가장 작은) 노드를 찾아 기존 노드 위치로 이동
   - 이동한 자식 노드가 자식 노드를 가지고 있으면, 해당 노드에 대해 3번 재귀적 반복

### 문제점

![문제점](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAsFh1%2Fbtrj3Wq2wSl%2Fx0uT0lByKesX8MFjcLWmA0%2Fimg.png)

트리의 삽입, 검색, 삭제는 모두 트리의 높이가 얼마인지에 따라서 시간 복잡도가 정해진다.  

만약 왼쪽 트리처럼 각 정점이 대부분 2개의 자식을 가지고 있다면, 높이가 하나 내려갈 때 마다 자식의 수가 1, 2, 4, 8, ... 이렇게 2배씩 증가하기 때문에 정점이 N개 있다고 하면 높이가 대략 log<sub>2</sub>N이 된다.  
이 경우 삽입, 검색, 삭제 모두 O(logN)이 된다.  

반면 오른쪽 트리처럼 트리가 편향되어 있다면 높이가 O(N)에 가깝기 때문에,  
이 경우 삽입, 검색, 삭제 모두 O(N)이 된다.  

각 연산을 O(logN)로 쓰려고 이진 검색 트리를 쓰는 건데, 만역 트리가 오른쪽 트리처럼 편향되어 있다면 이진 검색 트리를 쓰는 의미가 없어진다.  
그리고 1, 2, 3, 4, ... 이렇게 크기 순으로 주어진 원소를 삽입한다면 1이 루트이고 나머지 원소들이 오른쪽에 일직서느올 연결되는 편향된 트리가 되니, 편향된 트리가 만들어지는 상황은 아주 잘 발생할 수 있다.  

## **💫 Self-Balancing Tree**

---

대표적으로 AVL-Tree, Red-Black-Tree 등이 있다.  
구현은 AVL이 상대적으로 쉬운 편인데, 성능 자체는 Red-Black이 더 좋아서 STL에서는 Red-Black을 쓴다.  

![간단하게 설명하면](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8HccL%2Fbtrj6deGDl3%2FtKUQbYJA9KYoKW1fKK0zO0%2Fimg.png)

간단하게 설명하면 불균형이 발생했을 때 트리를 꺾어버린다.  
이러면 불균형을 없앨 수 있다.  

이렇게 편향성을 해소해주는 자가 균형 트리를 사용할 때 비로소 이진 검색 트리에서 삽입, 검색, 삭제가 모두 O(lg N)이 됩니다.

## **💫 메모**

---

- `B-Tree` : 자식 수를 m개로 확장해서 자식 수에 제한을 두지 않고 트리의 균형을 도모한 B트리
- @TODO : <https://blog.encrypted.gg/1019> 이진 트리의 순회~  
- @TODO : <https://blog.encrypted.gg/1013> STL~  
