---
title: "🌓 0-1 배낭 문제"
date: 2023-12-13. 11:04
last_modified_at: 2023-12-19. 01:47
categories: ⭐Computer 🌓PS-Algorithm
tags: Algorithm 0-1-Knapsack-Problem Dynamic-Programming Back-Tracking
math: true
---

## 💫 0-1 배낭 문제

---

배낭에 어떤 물건을 담아야 최대 이익을 낼 수 있는지 알아내는 문제이다.  

각 물건을 통째로 넣거나 아예 안 넣거나 택일해야 한다는 조건이 있을 때, 배낭의 용량을 넘지 않으면서 배낭에 담을 수 있는 물건들의 최대 이익이 얼마인지(정확하게는 최대 이익을 얻어내기 위해 어떤 물건을 담아야 하는지) 알아내는 문제  

- 욕심쟁이 방법으로 해결할 수 없음(2장)
- 분할정복과 동적 계획법을 이용하여 해결(4장)

최적화 문제  

@ TODO : Tex 괄호  

- n개의 물건 $ S = \{ Object_1, ..., Object_n \} $
- 각 물건의 무게 $ W = \{ w_1, ..., w_n \} where\ w_i > 0 $
- 각 물건의 이익 $ P = \{ p_1, ..., p_n \} where\ p_i > 0 $
- 각 물건이 배낭에 넣어지는 부분 $ X = \{ x_1, ... x_i \} where\ x_i = 0 or 1 $
- 배낭의 용량 $ M > 0 $
- 최적해 $ K(n, M) $ 은 $ \sum_{i = 1}^n p_i x_i $ 의 최댓값. 단. $ \sum_{i = 1}^n w_i x_i \le M $

## 💫 Solve By [Dynamic-Programming](https://mascari4615.github.io/posts/Algorithm-Dynamic-Programming/)

---

물건의 무게에 양의 실수를 허용한다면 동적 계획법을 이용하는데 어려움이 있음 (why??)

- 무작위 기법
  1. 가능한 모든 물건의 조합(2<sup>n</sup>개)을 구하고
  2. 배낭의 용량을 초과하는 조합은 모두 제외한 다음
  3. 남은 조합들 가운데 이익이 최대인 것을 찾음

- 최적 부분구조
  - 배낭 용량=M이고 최적해=K(n, M)일 때, 최적해 상태의 배낭을 관찰
    1. object<sub>n</sub>이 배낭에 없다: 애초에 object<sub>n</sub>이 없는 상태에서 문제를 풀어도 같은 결과. 즉 K(n, M)=K(n-1, M)
    2. object<sub>n</sub>이 배낭에 있다: 배낭에 object<sub>n</sub>을 미리 넣어둔 상태의 최적해와 동일. 즉 K(n, M)=K(n-1, M-w<sub>n</sub>)+p<sub>n</sub>
    - ∴ 최적 부분구조를 가짐
  - 두 조건에 따른 부문제의 최적해를 이용하면 원래 문제를 해결 가능
    - i.e. M=30, W={5, 10, 25}, P={150, 150, 200}이 주어졌을 때 최적해 K(3,30) ?
      -  3번째 물건이 최적해의 배낭에 포함되지 않는다는 가정하의 최적해인 K(2, 30)과 3번째 물건이 최적해의 배낭에 포함된다는 가정하의 최적해인 K(2, 5)+200  가운데 더 큰 값
  - 부문제를 정의하는 형식
    - 연속된 행렬 곱셈, 최적 이진 탐색 트리의 부문제는 시작과 끝이 매우 중요
      - i.e. 부문제 M<sub>i</sub>…M<sub>j</sub> 에서 조금씩 i와 j의 차를 늘려 최종적으로 M<sub>1</sub>…M<sub>n</sub>의 최적해를 구함
    - 동전 거스름돈 문제, 0-1 배낭 문제는 부문제의 한쪽 경계는 언제나 일정
      - i.e. 부문제 { object<sub>1</sub>, … , object<sub>i</sub> }에서 조금씩 i를 늘려 최종적으로 {object<sub>1</sub>, … , object<sub>n</sub>}에 대한 최적해를 구함
      - 부문제가 항상 K(1, j, m)으로 정의되기 때문에 상수 부분을 제외한 K(n, M)으로도 충분

- 문제의 순환적 정의
  - 최종 목표: 최대 이익을 가져다 주는 물건의 조합
  - 최우선 목표: 최대 이익
    - n개의 물건이 주어지고 배낭 용량이 M인 0-1 배낭 문제의 최적해 K(n, M)
      - object<sub>n</sub>이 배낭에 포함되지 않는다는 가정하의 최적해와 포함된다는 가정하의 최적해 중 더 큰 값
      - K(n, M) = Max { K(n - 1, M), K(n - 1, M - w<sub>n</sub>) + p<sub>n</sub> }
  - 일반화
    - i개의 물건이 주어지고 배낭 용량이 w인 0-1 배낭 문제의 최적해 K(i, w)
      - object<sub>i</sub>가 배낭에 포함되지 않는다는 가정하의 최적해와 포함된다는 가정하의 최적해 중 더 큰 값
      - 물건이 없거나 배낭 용량이 0  최적해가 0
      - objecti의 무게가 배낭의 용량을 넘어서는 상황  objecti가 최적해의 배낭에 포함되지 않을 경우만 고려
      - K(i, w) = 0, if (i = 0 or w = 0)
      - K(i, w) = K(i-1, w), if (w < w<sub>i</sub>)
      - K(i, w) = max(K(i-1, M), K(i-1, M-w<sub>i</sub>) + p<sub>i</sub>), o.w.

```c
// w[]와 p[]는 각 물건의 무게와 이익을 담은 배열
int DC_01_ks(int i, int w)
{
	if (i == 0 || w == 0) return 0;
	if (w < W[i]) return DC_01_ks(i-1,w);
	return max(DC_01_ks(i-1,w), DC_01_ks(i-1,w-W[i])+P[i]);
}
```

- 중첩된 부문제와 분할정복
  - 복잡도 ∝ 트리에 있는 노드 수 = 최대 ∑_(𝑙=0)^𝑛▒〖"2" 𝑙〗 = 최대 2^(n+1)-1 = O(2^n)
    - 무작위 기법 Ɵ(2n)과 비슷, but 실제로 호출되는 노드 수는 보통 이보다 적음
    - 알고리듬을 개선하면 단말 노드 호출을 없앨 수 있음
  - 중첩된 부문제 특성
    - 물건 개수가 많을수록 배낭 용량이 작을수록 부문제가 중복될 가능성이 커짐

@ 가방 공간이 적어서 계산하지 않는, 부문제가 하나 밖에 없는 케이스가 생길 수 있음  

동적 계획법으로 풀기 : 함수 대신 배열로  

@ 배열 B가 반드시 있어야 하나? 없어도됨 근데 일단 하던데로 계산하려고

PPT 배낭문제 13 14 15
y축 평행 이동으로 구하는 방법  

각 함수는 정렬된 정점 리스트  
원래는 최대한 많은 점을 기억해서 원래 함수의 모습을 기억하는 것이 좋은데, 게단식 그래프를 가지는 이런 상황에서는 단순히 점 몇 개 만을 기억하고도 x에 대한 y 값을 알아낼 수 있음  

각 물건에 대해서는, 각 함수에 물건의 무게와 가치를 평행이동한 것으로  

그리고 이전 함수와 평행 이동한 함수를 하나의 리스트로 합친다, 두 리스트는 정렬되어있다 (계단식) (정렬된 두 리스트를 하나로 합하기? => 합병 정렬)  

각 x와 y값을 비교,  
좌표 A와 B에 대해, x y가 둘 다 작은 좌표가 그래프에 그려지고,  
x나 y 중 하나만 작은 경우에는, A와 B 중 x가 더 큰 쪽에 정렬과정에서 제외가 된다 (왜냐하면 x가 더 작은 쪽이 그 x보다 큰 값도 설명할 수 있으니까)  

S<sub>0</sub>, 평행이동 SP<sub>0</sub>,  
합치고 S<sub>1</sub>, 평행이동 SP<sub>1</sub>,  
...  

단일 시작점 최단경로  
벨먼-포드 알고리듬  

- 문제의 이해: 단일 시작점 최단 경로를 찾는 알고리듬
  - 출발 지점으로부터 나머지 다른 모든 지점까지의 최단 경로를 찾는 문제
  - 음의 사이클(negative cycle)이 없어야 최단 경로를 찾을 수 있음 (실제 문제에서 음의 사이클이 있는지없는지 여부는 확신할 수 없음, 그래서 벨먼포드가 좋음, 여부를 확실히 몰라도 예방이 되니까)
  - 종류
    - 다익스트라 알고리듬
      - 욕심쟁이 방법을 사용하기 때문에 빠름
      - 그래프의 간선 가중치가 음수가 아니라고 가정 (범용성이 떨어짐)
    - 벨먼-포드 알고리듬(Bellman-Ford algorithm)
      - 동적 계획법을 사용
      - 음수의 간선 가중치를 갖는 그래프에 대해서도 정확하게 동작
      - 출발점에서 도달할 수 있는 음의 사이클이 존재하지 않는 한 정확한 최단 경로를 구하며 음의 사이클이 있다면 그 존재를 알려줌
- 무작위 기법: 2장 참조, n!
- 최적 부분구조: 2장 참조

음의 사이클  
A -( 1 )→ B -( 2 )→ C -( -3 )→  
돌떄마다 가중치가 무한히 작아짐  

## 💫 Solve By [BackTracking](https://mascari4615.github.io/posts/Algorithm-Back-Tracking/)

---

- $ p_i/w_i > p_{i + 1}/w_{i + 1} $

BT에서는 요소 내림차순 정렬 조건이 붙음  

Backtracking 최적화 문제 해결을 위한 구조 (링크 참고)  

### 🫧 상태 공간 트리

- 주요 변수
  - `weight` = 현재까지 담은 물건의 무게 합
  - `profit` = 현재까지 담은 물건의 이익 합
  - `max_profit` (optimal) = 현재까지의 최적해 즉 현재까지의 최대 이익

- 최적해를 변경하는 조건
  - 배낭에 물건을 넣어야 하는 노드를 방문 → `weight`와 `profit`의 값이 증가
  - 배낭의 용량을 넘어서지 않으면서 지금까지의 최대 이익보다 큰 이익이 발생하면 `max_profit` 값은 변경된 `profit` 값으로 바뀌어야 함
  - 따라서 다음 조건을 만족하면 최적해가 변경
  - $ (weight \le M) ^(and) (profit > max profit) $

@ TODO : and 기호  

### 🫧 알고리듬

- 유망하지 않은 노드의 판별(현재 i번째 물건까지 결정된 상태)
  - 규칙 1) 더 이상 물건을 담을 수 없는 경우, $ weight \ge M $
  - 규칙 2) 아직은 배낭에 여유가 있지만 현 상태에서 어떻게 진행하더라도 현재까지의 최대 이익보다 더 큰 이익을 기대하지 못하는 경우(현재까지 담은 물건의 이익에다가 남아있는 물건들을 최적으로 추가하여 얻을 수 있는 이익을 합한다 하더라도 현재까지의 최대 이익을 능가하지 못하는 경우)
    - 부분 배낭 문제로 풀었을 때의 최대 이익 >= 0-1 배낭 문제로 풀었을 때의 최대 이익
      - ∴ 최대 이익의 상한을 구하기 위해 부분 배낭 문제로 변신
    - 현재까지 담은 물건의 이익(`profit`) + 남은 물건을 대상으로 부분 배낭 문제로 전환하여 풀었을 때의 최대 이익(`exp_profit`)이 현재까지의 최대 이익(`max_profit`)보다 작다면 절대로 유망할 수가 없음 → 처음에 물건을 단위 무게 당 이익의 순에 따라 내림차순으로 정렬한 이유
      - $ profit + expProfit \ge maxProfit $
      - @ 배낭 0001

@ KP_0000  
@ KP_0001  

Back-Tracking, 실제로 트리를 만들지는 않고, 각 레벨에 해당하는 상태 정보를 배열에 저장한다.  

- 배열을 이용하여 상태 공간 트리를 관리하는 방법
  - 부분 집합의 합 문제와 동일
  - 기억해야 할 정보는 “걸어온 길”
  - 레벨 i 노드는 i 개 물건가운데 배낭에 넣은 물건들을 기억해야 함
    - 해당 노드가 유망하여 자식 노드로 내려간다면 i+1개 물건가운데 배낭에 넣은 물건들을 기억
    - 유망하지 않아 부모 노드로 백트래킹한다면 i -1개 물건가운데 배낭에 넣은 물건들을 기억

| 인덱스 | 1 | 2 | 3 | 4 |
| 포함여부 | false | true | true | - |

단말 노드가 아닌 노드가 해답이라면 해답 노드의 레벨까지 저장된 값만이 유효

- 배열 인덱스 : 물건
- 배열 값: 물건의 포함 여부

∴ n 개의 값(true/false)을 저장할 수 있는 1차원 배열이 필요

### 🫧 구현

`_01_ks_BT(0,0,0)` 을 호출함으로써 시작  
전역 변수 `max_profit`의 초기값은 0  

```cs
void _01_ks_BT(int i, int profit, int weight)
{
	if (weight <= M && profit > max_profit)
	{
		max_profit = profit;	// 최대 이익의 변경 
		optimal = (X[1]..X[i]); // i 개의 물건들의 포함 여부
	}

	if (Promising(i, profit, weight))
	{
		X[i + 1] = true;
		_01_ks_BT(i + 1, profit + P[i + 1], weight + W[i + 1]);
		X[i + 1] = false;
		_01_ks_BT(i + 1, profit, weight);
	}
}

bool Promising(int i, int profit, int weight)
{
	int k, exp_weight = 0;
	float exp_profit = 0;

	// 꽉 차거나 찢어짐
	if (weight >= M)
		return false;

	for (k = i + 1; k <= n; k++)
	{
		if (weight + exp_weight + W[k] > M)
			break;
		exp_weight += W[k];
		exp_profit += P[k];
	}

	if (k <= n)
		exp_profit += (M - (weight + exp_weight)) * P[k] / W[k];

	if (profit + exp_profit <= max_profit)
		return false; 

	return true;
}
```

### 🫧 분석

#### 상태 공간 트리의 노드 수

$$ 1 + 2 + 2^2  + … + 2^n = 2^{n+1} - 1 $$

부분집합의 합 문제와 상태 공간 트리가 동일  
NP-완전 문제 중에는 비교적 노드수가 적지만 여전히 지수 복잡도  

#### 유망한 노드 수

- 유망한 노드 개수를 계산할 수 없음
- 같은 개수의 노드를 갖더라도 배낭 용량이나 물건 무게에 따라 유망한 노드의 수가 달라짐
- 최적화 문제 → 상태 공간 트리를 모두 뒤져야 함. 단지 탐색하는 노드의 수가 달라질 뿐

#### 동적 계획법 vs. 백트래킹

- Horowitz와 Sahni의 명저 “Fundamentals  of  Computer  Algorithms”에는 Venkatesh가 실제 컴퓨터상에서 실행시켜 본 결과가 수록: 다음 4가지 경우의 데이터 집합 사용
  - ➊ 각 물건의 무게와 이익을 1~1,000 범위 안에서 임의로 생성한 경우
  - ➋ 각 물건의 무게와 이익을 1~100 범위 안에서 임의로 생성한 경우
  - ➌ 각 물건 무게를 1~100 범위 안에서 임의로 생성하고 이익은 무게에 10을 더한 경우
  - ➍ 각 물건 무게를 1~100 범위 안에서 임의로 생성하고 이익은 무게에 1.1을 곱한 경우
  - 배낭 용량 M은 물건 무게의 합에 절반이 되도록 하고 물건의 개수 n에 대해 10개씩의 인스턴스에 대한 측정값을 비교 → 일반적으로 백트랙킹 알고리즘이 동적 계획법 알고리즘보다 우수
