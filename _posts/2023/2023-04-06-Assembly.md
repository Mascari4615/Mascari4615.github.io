---
title: "ğŸŒ’ Assembly"
date: 2023-04-06. 11:16
last_modified_at: 2023-05-08. 13:23
categories: â­Computer ğŸŒ’Programming
---

[https://coding-factory.tistory.com/651](https://coding-factory.tistory.com/651)  
[https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=ndb796&logNo=221054682271](https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=ndb796&logNo=221054682271)  
[http://yuchi.duckdns.org/xe/Programming_QA/5934](http://yuchi.duckdns.org/xe/Programming_QA/5934)  
[http://yuchi.duckdns.org/xe/Programming_QA/5950](http://yuchi.duckdns.org/xe/Programming_QA/5950)  
[https://sunrinjuntae.tistory.com/24](https://sunrinjuntae.tistory.com/24)  
[https://araikuma.tistory.com/600](https://araikuma.tistory.com/600)  
[https://nan491.tistory.com/entry/%EC%8A%A4%ED%83%9DStack-PUSH-POP](https://nan491.tistory.com/entry/%EC%8A%A4%ED%83%9DStack-PUSH-POP)  
[https://wikidocs.net/145932](https://wikidocs.net/145932)  

RAM, DRAM  

ISA, Instruction Set Architecture, í”„ë¡œê·¸ë¨ ëª…ë ¹ êµ¬ì¡°  
ISAë¥¼ ì–¼ë§ˆë‚˜ Abstraction ì¶”ìƒí™” í–ˆëŠ”ì§€ì— ë”°ë¼,  
â†’ HLL High-Level Language  
â†’ LLL Low-Level Language (= Machine L/ê¸°ê³„ì–´, Assemble L/Assembly)  
â†’ ì¶”ìƒí™” ìˆ˜ì¤€, Machine L < Assembly < HLL

Assembly ì–´ì…ˆë¸”ë¦¬  
Machine L ëª…ë ¹ì–´ì™€ 1:1 ëŒ€ì‘ë˜ëŠ” ëª…ë ¹ì–´ ì§‘í•©, Machine L â‰ˆ Assembly  
â†’ ë‘˜ ë‹¤ CPUì— ì§ì ‘ ì§€ì‹œí•  ëª…ë ¹ì–´ì˜ ì§‘í•©ì„ ë§Œë“œëŠ” ê²ƒ  
â†’ ì œì•½ ì‚¬í•­, Machine L = Assembly  

Assembly ì£¼ë¡œ,
ê°€ë³€ì¸ì í•¨ìˆ˜ ì§ì ‘ êµ¬í˜„, HLL/HLLë¬¸ë²•ìœ¼ë¡œ í•  ìˆ˜ ì—†ëŠ” ì¼, MMX/SSE ë“± íŠ¹ìˆ˜ ê¸°ëŠ¥  

ê°™ì€ ëª…ë ¹ì–´ë„ CPU/CPU ë²„ì „ë§ˆë‹¤ ê¸°ê³„ì–´/Assemblyê°€ ë‹¤ë¦„  
I.E. Intel x86 ê³„ì—´ CPU ê¸°ê³„ì–´/Assembly â‰  ë‹¤ë¥¸ ë²¤ë” CPU  
(AMD/Cyrix CPUëŠ” ì›ë˜ Intel í˜¸í™˜ì¹©, ëª¨í† ë¡¤ë¼ì˜ x68ê³„ì—´ì´ ëŒ€í‘œì ì¸ ë¹„ í˜¸í™˜ì¹©)  
â†’ ê¸°ê³„ì–´/AssemblyëŠ” CPU ì¢…ì†ì , CPUê°€ ë‹¬ë¼ì§€ë©´ ìƒˆ ì–¸ì–´ë¥¼ ë°°ì›Œì•¼..  
â†’ High-Level ì–¸ì–´ì˜ ë“±ì¥  

Assembler, Assemble, Assembly â†’ Machine L  
Compiler, Compile, HLL â†’ Machine L, Assembly  
VM, HLL â†’ VM(HW/SW Simulation), VM ì„¤ì • í›„ í•´ë‹¹ VMìš© Machine Lë¡œ Compile  
I.E. JAVA, PCì— ë„ì›Œì§„ SWì¸ JVMìœ¼ë¡œ ëŒì•„ê°  

UNIX OSê°€ Cë¡œ ì“°ì¸ ì´í›„, OS ê±°ì˜ ëŒ€ë¶€ë¶„ C  
ë¬¼ë¡  HW ì§ì ‘ ë‹¤ë£¨ê±°ë‚˜, ì†ë„ì— ë¯¼ê°í•œ ì¼ë¶€ëŠ” Assemblyë¡œ  
Windows, Unix, Linuxë„ ëŒ€ë¶€ë¶„ì˜ C + ì¼ë¶€ Assemblyë¡œ  

---

GUI vs CUI (Console)  

Dos (Disk Operating System)  
IBM PCê°€ ì²˜ìŒ ë³´ê¸‰ë ë•Œ ë¼ì›ŒíŒ OS  
Windows 98ê¹Œì§€ë§Œí•´ë„ ìƒˆê¹Œë§Œ í™”ë©´ì— í”„ë¡¬í”„íŠ¸ í•˜ë‚˜ ëœ¨ëŠ” ë„ìŠ¤ ë¶€íŒ…ì´ ìˆì—ˆìŒ  
Windows 2000/XP ì´í›„ ë„ìŠ¤ ë¶€íŒ…ì€ ë¶ˆê°€ëŠ¥  
OS ëœ¨ê³ ë‚˜ë©´ Command Promptì°½ì„ ë„ìš¸ ìˆ˜ ìˆëŠ”ë°, ì—„ì—°íˆ NTì»¤ë„ ì•„ë˜ ëŒì•„ê°€ëŠ” ë””ìì¸ë§Œ ë„ìŠ¤ì°½ ê°™ì€ UI  
CUI í”„ë¡œê·¸ë¨ì˜ ëŒ€í‘œì ì¸ ì˜ˆëŠ” ê°ì¢… ì˜¨ë¼ì¸ ê²Œì„ì˜ ì„œë²„ í”„ë¡œê·¸ë¨  

---

- Preprocessor (ì „ì²˜ë¦¬ê¸°)
  - ì„ í–‰ì #, Like #include
  - Library, ê¸°ëŠ¥ ì§‘í•©,  \*.lib (\*.dllë„ ì‚¬ìš©í•˜ì§€ë§Œ Compile í•  ë• \*.lib)
  - Header File, Library ê°€ì ¸ë‹¤ ì“¸ ìˆ˜ ìˆê²Œ ì„ ì–¸í•´ë‘” ê²ƒ, \*.h
  - #include, Header File ì“¸ ìˆ˜ ìˆê²Œ í•˜ëŠ” ì§€ì‹œì–´  

- Variable, ë°ì´í„°ë¥¼ ë‹´ì„ ìˆ˜ ìˆëŠ” ì¼ì • ë‹¨ìœ„ì˜ Register/Memory
- Struct, í¬í•¨ëœ Variable(Data Type, Struct)ë“¤ì€ ë©”ëª¨ë¦¬ ìœ„ì— ì—°ì†ì ìœ¼ë¡œ ì¡´ì¬
- Array
  - Struct ë‚´ì˜ í•„ë“œ(Variable)ë“¤ì˜ ì‚¬ì´ì¦ˆëŠ” ë¶ˆê·œì¹™
  - Array í•œ ì¹¸ì˜ ì‚¬ì´ì¦ˆëŠ” ëª¨ë‘ ë™ì¼
  - ìˆ«ìë¡œ ì •í™•í•˜ê²Œ ì°¾ì•„ë‚¼ ìˆ˜ ìˆëŠ” ê²ƒì´ë‹¤. ì¸ë±ìŠ¤ * í•œì¹¸ ì‚¬ì´ì¦ˆ

- Pointer
  - ë©”ëª¨ë¦¬ì˜ ì£¼ì†Œë¥¼ ë‹¤ë£¨ëŠ”ë° ì‚¬ìš©í•˜ëŠ” ë°ì´í„° íƒ€ì…
  - VS unsigned ì •ìˆ˜í˜•
    - 1. ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ íƒ€ì… ì²´í¬ê°€ ì´ë£¨ì–´ì§
    - 2. ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ëª‡ ê°€ì§€ ì‚°ìˆ  ì—°ì‚° ì œí•œ
    - 3. ++/--, ê°€ë¦¬í‚¤ëŠ” ë°ì´í„° íƒ€ì… ì‚¬ì´ì¦ˆ ë§Œí¼

- *.exe (pe Fileì˜ í•œ ì¢…ë¥˜)
  - pe Headerì— main() Addressì˜ ìƒëŒ€ë²ˆì§€ê°€ Entry Pointë¡œ ê¸°ë¡  
  - *.exeê°€ ë¡œë“œë˜ê³  ì‹¤í–‰ë˜ë©´ ì´ ì£¼ì†Œë¥¼ ì½ì–´ main() ë¶€í„° ì‹¤í–‰  

---

ì¸ì Argument ì „ë‹¬  
ì¼ë°˜ì ìœ¼ë¡œ ìŠ¤íƒ  
32/64-bit ì´í•˜ ë°ì´í„° ë¸”ë¡ì€ ìŠ¤íƒì— push, ì´ˆê³¼ëŠ” mov ë“±ìœ¼ë¡œ ì¹´í”¼í•˜ê³  í•¨ìˆ˜ì— ì§„ì…í•˜ì—¬ ìŠ¤íƒ ì—ì„œ popí•˜ê±°ë‚˜ mov ë“±ìœ¼ë¡œ ì¹´í”¼ëœ ë°ì´íƒ€ë¥¼ ì–µì„¸ìŠ¤  
í° ë©”ëª¨ë¦¬ ë¸”ëŸ­ì„ ë°”ë¡œ ì „ë‹¬í•˜ë ¤ í•˜ë©´ ë‹¤ ìŠ¤íƒì— ì¹´í”¼í•´ì•¼ í•˜ë¯€ë¡œ, í•¨ìˆ˜ ì§„ì…ì‹œ ì†ë„ ì €í•˜  
â†’ Pointer, push í•œë²ˆì´ë©´ ë˜ë‹ˆê¹Œ  

ì§€ì—­ë³€ìˆ˜, í•¨ìˆ˜ë¥¼ ë²—ì–´ë‚ ë•Œ ì†Œë©¸ (ë‹¤ë¥¸ ì½”ë“œë“¤ì— ì˜í•´ Overwrite ê°€ëŠ¥)  
í•¨ìˆ˜ ì§„ì… ì‹œ, ìŠ¤íƒí¬ì¸í„°(%SP) - ì‚¬ì´ì¦ˆ (ì‚¬ìš©í•˜ëŠ” ì§€ì—­ë³€ìˆ˜ì˜ ì´ ì‚¬ì´ì¦ˆë¥¼ ê³„ì‚°í•´ì„œ ìŠ¤íƒ ê³µê°„ í™•ë³´)  
í•¨ìˆ˜ ë¦¬í„´ ì‹œ, SP ì›ë˜ëŒ€ë¡œ  

Debug Interrupt  
CPUì˜ ì‘ë™ íë¦„ì„ ê°„ì„­í•˜ëŠ” ì¼ì¢…ì˜ ê¸´ê¸‰ ì‹ í˜¸  
HW Interrupt, íƒ€ì´ë¨¸ì¹©/íƒ€ì´ë¨¸ Interrupt, ì£¼ë³€ì¥ì¹˜ì˜ IO/HW Interrupt  
SW Interrupt, CPUê°€ ì—°ì‚°ë„ì¤‘ ë°œìƒì‹œí‚¤ëŠ” Interrupt  
/0, ê¸ˆì§€ëœ ë©”ëª¨ë¦¬ ì˜ì—­ì„ Access -> Interrupt ë°œìƒ  
ê²Œì„ ì¤‘ 'ì˜ëª»ëœ ì—°ì‚°ì˜¤ë¥˜~' ë¥¼ ë³¸ë‹¤ë©´ ì´ì™€ ê°™ì€ SW Interruptë¡œ ì¸í•´ APP Crash  
SW InterruptëŠ” Exception, SWì ìœ¼ë¡œ í”„ë¡œê·¸ë˜ë¨¸ê°€ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆìŒ, __asm int 3  

ë²„ê·¸ ìœ í˜•ê³¼ ì›ì¸, ëŒ€ì²˜ ìš”ë ¹  
í”„ë¡œê·¸ë¨ì´ í¬ë˜ì‰¬í•˜ê²Œ ë§Œë“œëŠ” ë²„ê·¸:

- commit ë˜ì§€ ì•Šì€ ë©”ëª¨ë¦¬ ì–´ë“œë ˆìŠ¤ ì–µì„¸ìŠ¤
  - ì •ìƒ OSí•˜ì— ëŒì•„ê°€ëŠ” ëª¨ë“  SWëŠ”, OSë¡œë¶€í„° ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹ë°›ì•„ì•¼ë§Œ ì“¸ ìˆ˜ ìˆìŒ  
  - ìŠ¤íƒ ì˜ì—­ë„ í”„ë¡œì„¸ìŠ¤ ì´ˆê¸°í™”ì‹œì— í• ë‹¹ë°›ì€ ì˜ì—­  
  - ë³´í†µ reserveì™€ commitì´ë¼ëŠ” ê³¼ì •ì„ ê±°ì³ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë˜ëŠ”ë° commitì´ ì´ë£¨ì–´ì ¸ì•¼ í• ë‹¹ë°›ì€ ì–´ë“œë ˆìŠ¤ê°€ ì‹¤ì œ ë¬¼ë¦¬ ë©”ëª¨ë¦¬ì— ë§µí•‘ëœë‹¤.  
  - ë§Œì•½ commit ë˜ì§€ ì•Šì€, ê·¸ëŸ¬ë‹ˆê¹Œ ë¬¼ë¦¬ ë©”ëª¨ë¦¬ì— ë§µí•‘ ë˜ì§€ ì•Šì€ ì˜ì—­ì„ ì–µì„¸ìŠ¤ í•˜ë ¤ê³  í•˜ë©´ CPUëŠ” Exception ë°œìƒ  
  - ë˜í•œ 0ë²ˆì§€ëŠ” ì‚¬ìš©ì´ ë¶ˆê°€í•˜ë„ë¡ OSê°€ ì„¤ì •í•´ë†“ì•˜ìœ¼ë¯€ë¡œ commit/ì–µì„¸ìŠ¤ ë¶ˆê°€  

- Heap Crash
  - HEAP : ë©”ëª¨ë¦¬ë¥¼ ë¯¸ë¦¬ ë©ì–´ë¦¬ë¡œ ë°›ì•„ë†“ê³  ëŠì–´ì“°ëŠ” ë©”ëª¨ë¦¬ í’€  
  - I.E. malloc()/free(), new/delete  
  - í™ì˜ íŠ¹ì„±ìƒ í• ë‹¹ë°›ì€ ì‚¬ì´ì¦ˆë¥¼ ë„˜ê²¨ì„œ ë®ì–´ì“°ê²Œ ë˜ë©´ ë‹¤ë¥¸ ë¸”ëŸ­ì´ ê¹¨ì§  
  - Heap Crashê°€ ë°œìƒí•˜ë©´ êµ¬í˜„í•˜ê¸° ë‚˜ë¦„ì´ì§€ë§Œ ëˆˆì¹˜ì±„ì§€ ëª»í•˜ê²Œ ì¡°ìš©í•˜ê²Œ ëŒì•„ê°ˆìˆ˜ë„ ìˆê³  APP Crash í•  ìˆ˜ë„, íŒŒì¼ì´ ì—´ë¦¬ì§€ ì•Šê¸°ë„  

---

```Assembly

; ë ˆì§€ìŠ¤í„°
; CPU ì•ˆì— ë“¤ì–´ìˆëŠ” ê³ ì† ë©”ëª¨ë¦¬, ë°ì´í„° ì´ë™, ì‚°ìˆ  ì—°ì‚° ë“±ì˜ ê¸°ëŠ¥

; x86 CPU ê¸°ì¤€
; íŠ¹ìˆ˜í•œ ëª‡ ê°œì˜ ë ˆì§€ìŠ¤í„°ë“¤ì„ ì œì™¸í•˜ê³ ëŠ” ëª¨ë‘ 32ë¹„íŠ¸ ë ˆì§€ìŠ¤í„°
; 16ë¹„íŠ¸, 32ë¹„íŠ¸ëŠ” ì„ í–‰ì E (32ë¹„íŠ¸ 386ë¶€í„°), 64ë¹„íŠ¸ëŠ” ì„ í–‰ì R

; ë²”ìš© ë ˆì§€ìŠ¤í„° AX, BX, CX, DX

; 8ë¹„íŠ¸ì”© ìª¼ê°œì„œ ì‚¬ìš© ê°€ëŠ¥, ê·¸ëƒ¥ ë‚˜ëˆ  ì“°ê¸° ìœ„í•¨ë„ ìˆê³ , ê³¼ê±° 8086ê³¼ í˜¸í™˜ì„± ìœ ì§€ë¥¼ ìœ„í•´
; I.E. AXì˜ ê²½ìš°, AL (LOWë°”ì´íŠ¸), AH (HIë°”ì´íŠ¸), AL + AH = 16-bit AX, + 16-bit = 32-bit EAX, 32-bit = 64bit RAX, 
; X, E EXtended, R Register, [ì°¸ê³ ](https://stackoverflow.com/questions/43933379/what-do-the-e-and-r-prefixes-stand-for-in-the-names-of-intel-32-bit-and-64-bit-r)
; ë„¤ ê°œì˜ ë ˆì§€ìŠ¤í„° ëª¨ë‘ ê°™ì€ ê·œì¹™ì„ ë”°ë¥¸ë‹¤, ë³´í†µ ì‚°ìˆ  ì—°ì‚°ì— ë§ì´ ì“°ì´ê³ , ëª‡ ê°€ì§€ íŠ¹ìˆ˜í•œ ê¸°ëŠ¥

; AX, DX
; ê³±ì…ˆ ë‚˜ëˆ—ì…ˆì„ í•  ë•ŒëŠ” ë°˜ë“œì‹œ ì´ ë ˆì§€ìŠ¤í„°ë“¤ì„ ì‚¬ìš©í•´ì•¼
; ì—°ì‚°ì˜ ê²°ê³¼ í˜¹ì€ ì†ŒìŠ¤ì˜ ê°’ì´ 64ë¹„íŠ¸ì¼ ë•Œ í•˜ìœ„ 32ë¹„íŠ¸ = EAX, ìƒìœ„ 32ë¹„íŠ¸ = EDXì— ì €ì¥ëœë‹¤.
; ì¸í…”ê³„ ì»´íŒŒì¼ëŸ¬ì—ì„œëŠ” í•¨ìˆ˜ì˜ ë¦¬í„´ê°’ì´ eaxë ˆì§€ìŠ¤í„°ë¥¼ í†µí•´ ì „ë‹¬ëœë‹¤.

; BX
; ë²”ìš© ë ˆì§€ìŠ¤í„° Default

; CX
; Counter, loop/movs ë“±ì˜ ëª…ë ¹ê³¼ í•¨ê»˜ ì“°ì¼ ê²½ìš° ì¹´ìš´í„°ë¡œ ì“°ì„

; ë‚¨ì€ 4ê°œì˜ ë ˆì§€ìŠ¤í„°ëŠ” ì£¼ë¡œ ê°’ì„ ì €ì¥í•˜ê¸° ìœ„í•´
; Cì™€ êµ³ì´ ë¹„êµí•˜ë©´ í¬ì¸í„° ë³€ìˆ˜ì™€ ìœ ì‚¬í•œ ì—­í• 
; ê·¸ëŸ¬ë‚˜ ì£¼ë¡œ ë‹¤ë¥¸ ê°’ì„ ì´ë¯¸ ì €ì¥í•˜ê³  ìˆê¸° ë•Œë¬¸ì—, íŠ¹ìˆ˜í•œ ëª©ì ì´ ì•„ë‹ˆë©´ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê²ƒì´ ì¢‹ë‹¤.
; ì´ì™€ ê°™ì´ ë ˆì§€ìŠ¤í„°ì— ì“°ì„ì´ êµ¬ë¶„ë˜ì–´ ìˆëŠ” ê²ƒì„ ë³´ë©´ ë§ˆì¹˜ ì €ì¥í•´ì•¼ í•  íƒ€ì…ì´ ëª…ì‹œëœ ê²ƒì²˜ëŸ¼ ë³´ì´ë‚˜, ì–´ì…ˆë¸”ë¦¬ì˜ ë ˆì§€ìŠ¤í„°ëŠ” 32bitì˜ ë¹ˆ ê³µê°„ì— ë¶ˆê³¼í•˜ë‹¤.
; ì¦‰, ë©”ëª¨ë¦¬ ì£¼ì†Œ ì—­ì‹œ í•˜ë‚˜ì˜ ì •ìˆ˜ ê°’ì— ì§€ë‚˜ì§€ ì•Šê¸°ì— ë ˆì§€ìŠ¤í„°ì— ì €ì¥í•œë‹¤.
; ë”°ë¼ì„œ %eax ê°™ì€ ë ˆì§€ìŠ¤í„°ê°€ ì£¼ì†Œê°’ ì—­ì‹œ ì €ì¥í•  ìˆ˜ ìˆê³ , ì‹¤ì œë¡œë„ ì´ë ‡ê²Œ í™œìš©í•˜ëŠ” ê²½ìš°ê°€ ë¹ˆë²ˆí•˜ë‹¤.

; Stack Pointer, SP/ESP/RSP
; í˜„ì¬ ìŠ¤íƒì˜ ìœ„ì¹˜ë¥¼ ê°€ë¦¬í‚¤ëŠ” ë ˆì§€ìŠ¤í„°
; ì„ì˜ë¡œ ì¡°ì‘í•  ìˆ˜ë„ ìˆì§€ë§Œ ì¼ë°˜ì ì¸ í”„ë¡œê·¸ë¨ì„ ì§¤ë•ŒëŠ” ê±´ë“œë¦¬ì§€ ì•ŠëŠ” ê²ƒì´ ì¢‹ë‹¤.
; push, pop ëª…ë ¹ê³¼ ì—°ë™ëœë‹¤. pushí•˜ë©´ 4ë°”ì´íŠ¸ ê°ì†Œ, popí•˜ë©´ 4ë°”ì´íŠ¸ ì¦ê°€í•œë‹¤.
; ìŠ¤íƒì€ ë¯¸ë¦¬ ì¼ì • ì‚¬ì´ì¦ˆë¥¼ í™•ë³´í•´ë†“ê³  ê·¸ ìƒíƒœì—ì„œ ì‚¬ìš©í• ë•Œë§ˆë‹¤ 0ì„ í–¥í•´ì„œ ê°ì†Œí•´ê°€ëŠ” í˜•íƒœì´ê¸° ë•Œë¬¸ì— pushí–ˆì„ ë•Œ ìŠ¤íƒí¬ì¸í„°ê°€ ê°ì†Œí•˜ëŠ” ê²ƒì´ë‹¤.
; ë©”ëª¨ë¦¬ ê³µê°„ì—ì„œ Push==í• ë‹¹, pop==í•´ì œ ë¼ê³  ìƒê°í•˜ë©´ ëœë‹¤.

; Base Pointer, BP/EBP/RBP
; ì¼ë°˜ì ìœ¼ë¡œ í•¨ìˆ˜ ì§„ì… ì‹œì— ìŠ¤í… í”„ë ˆì„ê³¼ í•¨ìˆ˜ ì•ˆì—ì„œ ììœ ë¡­ê²Œ ì‚¬ìš©í•˜ê²Œ ë (push, pop) ìŠ¤íƒê³µê°„ê³¼ì˜ ê²½ê³„ë¥¼ ì§€ì •í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•œë‹¤.

; ë¬¼ë¡  ebpë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ë°”ë¡œ espë¡œ ì–µì„¸ìŠ¤ í•´ë„ ë˜ì§€ë§Œ(ì‹¤ì œë¡œ ì»´íŒŒì¼ëŸ¬ê°€ ìµœì í™”í• ë• ê·¸ë ‡ê²Œ í•œë‹¤)
; ì‚¬ëŒì´ ì§¤ ë•ŒëŠ” ì—„ì²­ë‚˜ê²Œ í—·ê°ˆë¦°ë‹¤.
; ê°€ë ¹ í•¨ìˆ˜ì— ì§„ì…í–ˆì„ ë•Œ ì²« ë²ˆì§¸ ì¸ìëŠ” ebp+8ì˜ ë©”ëª¨ë¦¬ì— ì¡´ì¬í•˜ì§€ë§Œ esp ê¸°ì¤€ìœ¼ë¡œëŠ” ì–´ë””ê°€ ë ì§€ ëª¨ë¥¸ë‹¤.
; push, popí• ë•Œë§ˆë‹¤ espì˜ ê°’ì´ ë°”ë€Œê¸° ë•Œë¬¸ì— ê¸°ì¤€ì ìœ¼ë¡  ì‚¼ì„ ìˆ˜ê°€ ì—†ëŠ” ê²ƒì´ë‹¤.

; ì¸ë±ìŠ¤ ë ˆì§€ìŠ¤í„°
; ì¸ë±ìŠ¤ ë ˆì§€ìŠ¤í„°ëŠ” ë²”ìš© ë ˆì§€ìŠ¤í„°ë“¤ì²˜ëŸ¼ ìª¼ê°œì„œ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.
; 32ë¹„íŠ¸ ê·¸ ìì²´ë¡œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
; ë°ì´í„° ì´ë™ì— ê´€ë ¨ëœ íŠ¹ìˆ˜í•œ ëª…ë ¹ë“¤ì„ ì‚¬ìš©í•  ë•Œ sourceì™€ destination ì–´ë“œë ˆìŠ¤ë¥¼ ì§€ì •í•˜ëŠ” ë“± ì£¼ì†Œì§€ì •ì— ê´€ë ¨ëœ íŠ¹ìˆ˜ ê¸°ëŠ¥ì„ ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì— ì¸ë±ìŠ¤ ë ˆì§€ìŠ¤í„°ë¼ê³  í•œë‹¤.

; Source Index SI(16-bit)/ESI/RSI
; ì™œ sourceì¸ê³  í•˜ë‹ˆ íŠ¹ìˆ˜í•œ ë°ì´í„° ì´ë™ ëª…ë ¹ movs ë“±ì„ ì‚¬ìš©í•  ë•Œ esiì— source ë©”ëª¨ë¦¬ì˜ ì–´ë“œë ˆìŠ¤ë¥¼ ë„£ì–´ì•¼ í•˜ê¸° ë•Œë¬¸ì´ë‹¤.
; ê·¸ ë°–ì—ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ë©”ëª¨ë¦¬ì˜ ì£¼ì†Œë¥¼ ì§€ì¹­í•  ë•Œ ì´ ë ˆì§€ìŠ¤í„°ë¥¼ ì‚¬ìš©í•œë‹¤.

; Destination DI(16-bit)/EDI/RDI
; ESIì™€ ê¸°ë³¸ì ìœ¼ë¡œ ê°™ê³  movsë“±ì„ ì‚¬ìš©í•  ë•Œ destination ì–´ë“œë ˆìŠ¤ë¥¼ ë„£ì–´ì•¼ í•œë‹¤.

; ----

; Instruction Pointer IP ë ˆì§€ìŠ¤í„°
; í”„ë¡œê·¸ë˜ë¨¸ê°€ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ë ˆì§€ìŠ¤í„°, ë‹¤ìŒìœ¼ë¡œ ì‹¤í–‰ë  í”„ë¡œê·¸ë¨ ëª…ë ¹í–‰ì˜ ìœ„ì¹˜ë¥¼ ì €ì¥
; IP + 1, ì—°ì†ì ìœ¼ë¡œ ì‹¤í–‰í•´ ëª…ë ¹í–‰ì„ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰
; IP = n, ë‹¤ë¥¸ ìœ„ì¹˜ë¡œ í•œë²ˆì— ì´ë™í•´ if, while ê³¼ ê°™ì€ ëª…ë ¹ì„ ìˆ˜í–‰

; ë””ë²„ê·¸ ë ˆì§€ìŠ¤í„°, í”Œë˜ê·¸ ë˜ì§€ìŠ¤í„° ê°™ì€ íŠ¹ìˆ˜í•œ ë ˆì§€ìŠ¤í„°ë“¤ ìœ ì ¸ëª¨ë“œ í”„ë¡œê·¸ë˜ë°ì—ì„  ì“¸ ì¼ 

; MMXë ˆì§€ìŠ¤í„°
; MMXë ˆì§€ìŠ¤í„°ëŠ” íœí‹°ì—„ í´ë˜ì‹ MMXë²„ì „ë¶€í„° ì¶”ê°€ë˜ì—ˆë‹¤.
; ì •í™•íˆëŠ” ë¬¼ë¦¬ì ìœ¼ë¡œ ì¡´ì¬í•˜ëŠ” ë ˆì§€ìŠ¤í„°ê°€ ì•„ë‹ˆê³  FPU ìŠ¤íƒì„ ë ˆì§€ìŠ¤í„°ì²˜ëŸ¼ ì‚¬ìš©í•œë‹¤. MM0ë¶€í„°  MM7 ê¹Œì§€ 8ê°œê°€ ìˆë‹¤.

; SSEë ˆì§€ìŠ¤í„°
; íœí‹°ì—„3ë¶€í„° ì¶”ê°€ë˜ì—ˆë‹¤.
; 32ë¹„íŠ¸ float ë°ì´íƒ€ 4ìƒ˜í”Œì„ ë™ì‹œì— ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” 128ë¹„íŠ¸ ë ˆì§€ìŠ¤í„°ì´ë‹¤.
; XMM0ë¶€í„° XMM7ê¹Œì§€ 8ê°œê°€ ìˆë‹¤.

; ----

; ALU Arithmetic And Logic Unit
; CPU ë‚´ì˜ ì‹¤ì§ˆì ì¸ ì—°ì‚°, ì‚°ìˆ /ë…¼ë¦¬ ì—°ì‚°
; ì—°ì‚° ì‹œ ë ˆì§€ìŠ¤í„°ë¥¼ ì°¸ì¡°
; ì—°ì‚° ì˜ˆì™¸ì²˜ë¦¬
; I.E. ì˜¤ë²„í”Œë¡œìš° Overflow, OF Overflow Flag í‚¤ê¸°
; ZF Zero flag, OF Overflow Flag, CF Carry Flag, SF Sign Flag

; Bus
; ëª¨ë“  ì»´í“¨í„° ìš”ì†Œë“¤ì„ ì—°ê²°ì‹œí‚¤ëŠ” ê¸¸ê³  ë„“ì€ í†µë¡œ (ê°ê° ì—°ê²°ì‹œí‚¤ë©´ ë¹„ìš©ì´ í¬ë‹ˆê¹Œ)
; ì—®ë‹¤ Omni'bus'

; Memory

; Kernel
; OSê°€ ì‚¬ìš©, í”Œë¨¸ëŠ” ì‚¬ìš© ê¸ˆì§€/ë¶ˆê°€

; Stack
; Assemblyê°€ ë¹ˆë²ˆí•˜ê²Œ, ì €ì¥ë˜ëŠ” ê°’ ì €ì¥, Subroutine, Procedure ë“±
; Stack ìë£Œ êµ¬ì¡°
; BasePointer ì‹œì‘ ìœ„ì¹˜ë¥¼ BP ë ˆì§€ìŠ¤í„°, StackPointer ì œì¼ ìœ„ ìœ„ì¹˜ë¥¼ SP ë ˆì§€ìŠ¤í„°
; Glow Down, ë‹¤ë¥¸ ë©”ëª¨ë¦¬ ì˜ì—­ê³¼ ë‹¬ë¦¬ ê±°ê¾¸ë¡œ ìë€ë‹¤

; Heap
; ì£¼ë¡œ ë©”ëª¨ë¦¬ ë™ì  í• ë‹¹
; I.E. malloc, calloc, realloc

; DLLs
; Linkerê°€ ì™¸ë¶€ì—ì„œ ê°€ì ¸ì˜¨ ì½”ë“œë¥¼ í•©ì¹  ë•Œ ì‚¬ìš©

; Data
; ì „ì—­ ë³€ìˆ˜ ë“±ì´ ì €ì¥

; Text
; ì‹¤ì œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œ ë“±ì´ ì €ì¥

; Endianness
; Byte Order, Byteë¥¼ ë°°ì—´í•˜ëŠ” ë°©ë²•
; Big Endian, í° ë‹¨ìœ„ê°€ ì•ì—
; Little Endian, ì‘ì€ ë‹¨ìœ„ê°€ ì•ì—

; ----

; ë¬¸ë²• { Intel (ì£¼ë¡œ ì“°ì„), AT&T }
; ëª…ë ¹ì–´ ìˆ˜í–‰ ë°©ì‹ (ADD EAX EBX, Intelì€ EAX += EBX, AT&TëŠ” EBX += EAX)
; ê°’/ìˆ«ì í‘œê¸° ë°©ì‹ (Intelì€ 16ì§„ìˆ˜ Prefix hì™€ 2ì§„ìˆ˜ Prefix b, AT&TëŠ” Prefix $)
; ë ˆì§€ìŠ¤í„° í‘œê¸° ë°©ì‹ (Intelì€ ê·¸ëŒ€ë¡œ, AT&TëŠ” Prefix %)

; í•œ ì¤„ ì£¼ì„  

COMMENT !
ì—¬ëŸ¬ ì¤„ ì£¼ì„
ëŠë‚Œí‘œ ëŒ€ì‹  @, #, $, % ë“±ë„ ê°€ëŠ¥
!

COMMENT !

C ì¸ë¼ì¸ ì–´ì…ˆë¸”ë¦¬
__asm
{
    ;
}

!

; ëŒ€ì†Œë¬¸ì ìƒê´€ ì—†ìŒ

; NOP, 0x90
; ì•„ë¬´ ì‘ì—…ë„ ì•ˆí•¨, í´ëŸ­ ì†Œëª¨, 1Byteì˜ ë¹ˆ ê³µê°„ ì°¨ì§€

; MOV A B
; MOVE, Aì— B ê°’ ë„£ê¸°, ì—°ì‚° í¬í•¨ ë¶ˆê°€ëŠ¥

; ëª…ë ¹ì–´ì™€ ì¡°í•©í•˜ì—¬ í¬ê¸°ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì ‘ë¯¸ì‚¬
; l Long 4-Byte
; w Word 2-Byte
; b Byte 1-Byte

; I.E. movl, 4-Byte ë©”ëª¨ë¦¬ë¥¼ ì˜®ê¸´ë‹¤
; = í¬ê¸°ê°€ ê³ ì •ë˜ì–´ ìˆëŠ” ë ˆì§€ìŠ¤í„°ë¥¼, ê° í¬ê¸°ë³„ë¡œ ìª¼ê°œì–´ ì“¸ ìˆ˜ ìˆë‹¤

; LEA A B
; Load Effective Address, ì—°ì‚° í¬í•¨ ê°€ëŠ¥
; LEA EAX, [EAX + 1000]

; INC
; Increase í”¼ ì—°ì‚°ìì— 1ì„ ë”í•˜ê¸°
; ì—°ì‚° ê²°ê³¼ì— ë”°ë¼ Zero Flag ZF, Overflow Flag OF ì„¸íŠ¸ ê°€ëŠ¥

; JMP A
; íŠ¹ì • ìœ„ì¹˜ Aë¡œ ì í”„
; JA, JB, JE ë“±
; ---
; 004013D4     EB 01
; 004013D6     CC
; ---
; 215:      jmp     label_1
; 216:      int     3
; 217:  label_1:
; ---
; jmp == 0xEB 0x01  
; ì–´ì…ˆë¸”ë¦¬ì—ì„œ JMPëŠ” í•œê°œì§€ë§Œ ì‹¤ì œë¡œ ê¸°ê³„ì–´ì½”ë“œë¡œ ë°”ë€”ë•ŒëŠ” ì˜†ì˜ ì˜¤í¼ëœë“œ(ìœ„ì—ì„œëŠ” 0x01)ì— ë”°ë¼ ê°ê° ë‹¤ë¥¸ ëª…ë ¹ìœ¼ë¡œ ëŒ€ì¹˜ëœë‹¤.  
; ì´ ëª…ë ¹ì€ 1ë°”ì´íŠ¸ ê±´ë„ˆë›°ë¼ëŠ” ëœ»ì´ ë˜ê² ë‹¤.

; CALL
; í•¨ìˆ˜ë¥¼ í˜¸ì¶œí–ˆë‹¤ê°€ ë‹¤ì‹œ ì›ë˜ ìœ„ì¹˜ë¡œ ëŒì•„ì˜¬ ë•Œ
; JMPì™€ ë‹¤ë¥¸ ì ì€ ì‹¤í–‰í•œ ë’¤ì— ëë‚˜ë©´ RETì— ì €ì¥í•˜ê³  ë‹¤ì‹œ ì›ë˜ ìƒíƒœë¡œ ëŒì•„ì˜´

! RET
; í˜„ì¬ í•¨ìˆ˜ê°€ ëë‚œ ë’¤ì— ëŒì•„ê°ˆ ì£¼ì†Œë¥¼ ì§€ì •í•˜ê¸° ìœ„í•´ ì‚¬ìš©

; PUSH
; ìŠ¤íƒì— ê°’ ë„£ê¸°

; POP
; ìŠ¤íƒì— ìˆëŠ” ê°’ ë¹¼ë‚´ê¸°

; INT 3, 0xCC
; ë””ë²„ê·¸ ì¸í„°ëŸ½íŠ¸

; LEAVE
; í˜„ì¬ê¹Œì§€ì˜ ë©”ëª¨ë¦¬ ìŠ¤íƒ ë¹„ìš°ê³ , EBPë¥¼ ìì‹ ì´ í˜¸ì¶œí•œ ë©”ëª¨ë¦¬ë¡œ ì±„ì›€
; ì‹¤í–‰ì¤‘ì¸ í•¨ìˆ˜ë¥¼ ì¢…ë£Œí•˜ê¸° ìœ„í•´ ì •ë¦¬í•˜ëŠ” ì‘ì—…ì— ì‚¬ìš©

; ë¬¸ë²•
; í•¨ìˆ˜ ë¦¬í„´ ê°’ì€ RAX, EAXì— ì €ì¥
; ëª©ì ì§€ëŠ” RDI, ì¶œë°œì§€ëŠ” RSI
; RBP Base Pointer
; RSP Stack Pointer
; RIP í˜„ì¬ ì‹¤í–‰í•  ì½”ë“œì˜ ì£¼ì†Œ

; ì‹œìŠ¤í…œ ì½œ

; ë ˆì§€ìŠ¤í„° 0 ì´ˆê¸°í™”

; MOV AX, 0
; (í¬ê¸° 3~4)

; SUB AX, AX
; XOR AX, AX
; (í¬ê¸° 1~2)

add eax, edx;
; eaxì™€ edxì˜ ë‚´ìš©ì„ ë”í•œë‹¤.

; ë”í•œê°’ì€ eax ë ˆì§€ìŠ¤í„°ì— ì €ì¥ëœë‹¤.

```

---

```c

// Inline Assembly

int a = 0;

if (a) a = 0;
else a = 1;

//

int a = 0;

__asm
{
    mov eax,dword ptr[a]
    cmp eax,0
    jz lb_set_a1

lb_set_a0:
    xor eax,eax
    mov dword ptr[a],eax

lb_set_a1:
    inc eax
    mov dword ptr[a],eax
}

//

int i = 0, s = 0;

lb_loop:
    if (i >= 100)
    goto lb_exit_loop;
    s += i;
    I++;
    goto lb_loop;

lb_exit_loop:

//

int s = 0;

__asm
{
    xor ecx,ecx
    xor edx,edx

lb_loop:
    inc ecx
    add edx,ecx

    cmp ecx,100
    jnz lb_loop

    mov dword ptr[s],edx
}

```
